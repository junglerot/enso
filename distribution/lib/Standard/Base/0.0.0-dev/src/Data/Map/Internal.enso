import project.Data.Any.Any
import project.Data.Ordering.Ordering
import project.Data.Map.Map
import project.Data.Numbers.Integer

## PRIVATE
   Compares keys allowing for the possibility that one or both keys are Nothing.
compare_allow_nothing : Any -> Any -> Ordering
compare_allow_nothing x y = if x == y then Ordering.Equal else
    if x.is_nothing then Ordering.Less else
        if y.is_nothing then Ordering.Greater else
            x.compare_to y

## PRIVATE

   A helper used in the insert operation to insert into the left subtree.

   Arguments:
   - key: The key to insert.
   - value: The value to insert.
   - k: The previous top key of the left subtree.
   - v: The previous top value of the left subtree.
   - l: The left subtree.
   - r: The right subtree.
insert_l : Any -> Any -> Any -> Any -> Map -> Map -> Map
insert_l key value k v l r =
    new_left = insert l key value
    balance_left k v new_left r

## PRIVATE

   A helper used in the insert operation to insert into the right subtree.

   Arguments:
   - key: The key to insert.
   - value: The value to insert.
   - k: The previous top key of the right subtree.
   - v: The previous top value of the right subtree.
   - l: The left subtree.
   - r: The right subtree.
insert_r : Any -> Any -> Any -> Any -> Map -> Map -> Map
insert_r key value k v l r =
    new_right = insert r key value
    balance_right k v l new_right

## PRIVATE

   Helper for inserting a new key-value pair into a map.

   Arguments:
   - map: The map into which the insertion is performed.
   - key: The key for which to insert the value into the map.
   - value: The value to insert into the map at the given key.

   The algorithm used here is based on the paper "Implementing Sets Efficiently
   in a Functional Language" by Stephen Adams.  The implementation is based on
   Haskell's `Data.Map.Strict` as implemented in the `containers` package.
insert : Map -> Any -> Any -> Map
insert map key value = case map of
    Map.Bin s k v l r -> case compare_allow_nothing key k of
        Ordering.Less -> @Tail_Call insert_l key value k v l r
        Ordering.Greater -> @Tail_Call insert_r key value k v l r
        Ordering.Equal -> Map.Bin s key value l r
    _ -> Map.Bin 1 key value Map.Tip Map.Tip

## PRIVATE

   Re-balances the map after the left subtree grows.

   Arguments:
   - k: The old top key of the left subtree.
   - x: The old top value of the left subtree.
   - l: The left subtree.
   - r: The right subtree.
balance_left : Any -> Any -> Map -> Map -> Map
balance_left k x l r = case r of
    Map.Bin rs _ _ _ _ -> case l of
        Map.Bin ls lk lx ll lr ->
            if ls <= delta*rs then Map.Bin 1+ls+rs k x l r else
                lls = size ll
                case lr of
                    Map.Bin lrs lrk lrx lrl lrr ->
                        if lrs < ratio*lls then Map.Bin 1+ls+rs lk lx ll (Map.Bin 1+rs+lrs k x lr r) else
                            lrls = size lrl
                            lrrs = size lrr
                            Map.Bin 1+ls+rs lrk lrx (Map.Bin 1+lls+lrls lk lx ll lrl) (Map.Bin 1+rs+lrrs k x lrr r)
        _ -> Map.Bin 1+rs k x Map.Tip r
    _ -> case l of
        Map.Tip -> Map.Bin 1 k x Map.Tip Map.Tip
        Map.Bin _ _ _ Map.Tip Map.Tip -> Map.Bin 2 k x l Map.Tip
        Map.Bin _ lk lx Map.Tip (Map.Bin _ lrk lrx _ _) -> Map.Bin 3 lrk lrx (Map.Bin 1 lk lx Map.Tip Map.Tip) (Map.Bin 1 k x Map.Tip Map.Tip)
        Map.Bin _ lk lx ll Map.Tip -> Map.Bin 3 lk lx ll (Map.Bin 1 k x Map.Tip Map.Tip)
        Map.Bin ls lk lx ll lr -> case lr of
            Map.Bin lrs lrk lrx lrl lrr ->
                lls = size ll
                if lrs < ratio*lls then Map.Bin 1+ls lk lx ll (Map.Bin 1+lrs k x lr Map.Tip) else
                    lrls = size lrl
                    lrrs = size lrr
                    Map.Bin 1+ls lrk lrx (Map.Bin 1+lls+lrls lk lx ll lrl) (Map.Bin 1+lrrs k x lrr Map.Tip)

## PRIVATE

   Re-balances the map after the right subtree grows.

   Arguments:
   - k: The old top key of the right subtree.
   - x: The old top value of the right subtree.
   - l: The left subtree.
   - r: The right subtree.
balance_right : Any -> Any -> Map -> Map -> Map
balance_right k x l r = case l of
    Map.Bin ls _ _ _ _ -> case r of
        Map.Bin rs rk rx rl rr ->
            if rs <= delta*ls then Map.Bin 1+ls+rs k x l r else
                case rl of
                    Map.Bin rls rlk rlx rll rlr ->
                        rrs = size rr
                        if rls < ratio*rrs then Map.Bin 1+ls+rs rk rx (Map.Bin 1+ls+rls k x l rl) rr else
                            rlls = size rll
                            rlrs = size rlr
                            Map.Bin 1+ls+rs rlk rlx (Map.Bin 1+ls+rlls k x l rll) (Map.Bin 1+rrs+rlrs rk rx rlr rr)
        _ -> Map.Bin 1+ls k x l Map.Tip
    _ -> case r of
        Map.Tip -> Map.Bin 1 k x Map.Tip Map.Tip
        Map.Bin _ _ _ Map.Tip Map.Tip -> Map.Bin 2 k x Map.Tip r
        Map.Bin _ rk rx Map.Tip rr -> Map.Bin 3 rk rx (Map.Bin 1 k x Map.Tip Map.Tip) rr
        Map.Bin _ rk rx (Map.Bin _ rlk rlx _ _) Map.Tip -> Map.Bin 3 rlk rlx (Map.Bin 1 k x Map.Tip Map.Tip) (Map.Bin 1 rk rx Map.Tip Map.Tip)
        Map.Bin rs rk rx rl rr -> case rl of
            Map.Bin rls rlk rlx rll rlr -> case rr of
                Map.Bin rrs _ _ _ _ ->
                    if rls < ratio*rrs then Map.Bin 1+rs rk rx (Map.Bin 1+rls k x Map.Tip rl) rr else
                        srll = size rll
                        srlr = size rlr
                        Map.Bin 1+rs rlk rlx (Map.Bin 1+srll k x Map.Tip rll) (Map.Bin 1+rrs+srlr rk rx rlr rr)

## PRIVATE

   Controls the difference between inner and outer siblings of a heavy subtree.
   Used to decide between a double and a single rotation.

   The choice of values for `ratio` and `delta` is taken from the Haskell
   implementation.
ratio : Integer
ratio = 2

## PRIVATE

   Controls the maximum size difference between subtrees.

   The choice of values for `ratio` and `delta` is taken from the Haskell
   implementation.
delta : Integer
delta = 3

## PRIVATE

   Gets the size of a map.

   Arguments:
   - m: The map to get the size of.
size : Map -> Integer
size m = case m of
    Map.Bin s _ _ _ _ -> s
    _ -> 0

