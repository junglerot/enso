import project.Any.Any
import project.Data.Map.Map
import project.Data.Pair.Pair
import project.Data.Set.Set
import project.Data.Text.Text
import project.Data.Time.Duration.Duration
import project.Data.Vector.Vector
import project.Error.Error
import project.Errors.Common.Forbidden_Operation
import project.Errors.Illegal_Argument.Illegal_Argument
import project.Meta
import project.Network.HTTP.Header.Header
import project.Network.HTTP.HTTP_Method.HTTP_Method
import project.Network.HTTP.HTTP_Version.HTTP_Version
import project.Network.HTTP.Request.Request
import project.Network.HTTP.Request_Body.Request_Body
import project.Network.HTTP.Response.Response
import project.Network.Proxy.Proxy
import project.Network.URI.URI
import project.Nothing.Nothing
import project.Panic.Panic
import project.Runtime.Context
import project.System.File.File
from project.Data.Boolean import Boolean, False, True
from project.Data.Json.Extensions import all

polyglot java import java.lang.Exception as JException
polyglot java import java.net.http.HttpClient
polyglot java import java.net.http.HttpRequest
polyglot java import java.net.http.HttpRequest.BodyPublisher
polyglot java import java.net.http.HttpResponse
polyglot java import java.net.InetSocketAddress
polyglot java import java.net.ProxySelector
polyglot java import java.nio.file.Path
polyglot java import org.enso.base.Http_Utils

type HTTP
    ## ADVANCED
       Create a new instance of the HTTP client.

       Arguments:
       - timeout: The length of time the client will wait for responses.
       - follow_redirects: Whether or not the client should follow redirects.
       - proxy: The proxy that the client should use, if any.
       - version: The HTTP version supported by the client.

       > Example
         Create an HTTP client with default settings.
             HTTP.new

       > Example
         Create an HTTP client with extended timeout.
             HTTP.new timeout=(Duration.new seconds=30)

       > Example
         Create an HTTP client with extended timeout and proxy settings.

             import Standard.Base.Data.Time.Duration.Duration
             import Standard.Base.Network.HTTP.HTTP
             import Standard.Base.Network.Proxy.Proxy

             example_new =
                HTTP.new (timeout = (Duration.new seconds=30)) (proxy = Proxy.Address "example.com" 8080)
    new : Duration -> Boolean -> Proxy -> HTTP_Version -> HTTP
    new (timeout = (Duration.new seconds=10)) (follow_redirects = True) (proxy = Proxy.System) (version = HTTP_Version.HTTP_1_1) =
        HTTP.Value timeout follow_redirects proxy version

    ## PRIVATE

       An HTTP client.

       Arguments:
       - timeout: The length of time the client will wait for responses.
       - follow_redirects: Whether or not the client should follow redirects.
       - proxy: The proxy that the client should use, if any.
       - version: The HTTP version supported by the client.
    Value timeout follow_redirects proxy version

    ## ADVANCED
       Create a request

       Arguments:
       - req: The HTTP request to send using `self` HTTP client.
       - try_auto_parse_response: If true, attempt to auto-parse the result
         body.

       > Example
         Send a Get request with headers.
         Note: This example will send a network request.

             import Standard.Base.Network.HTTP.HTTP
             import Standard.Base.Network.HTTP.HTTP_Method.HTTP_Method
             import Standard.Base.Network.HTTP.Request.Request

             example_request =
                 req = Request.new HTTP_Method.Get "http://httpbin.org/get" . with_header "X-Trace-Id" "00000"
                 res = Examples.http_client.request req
                 res.body

       > Example
         Open a connection and send a Post request with form.
         Note: This example will send a network request.

             import Standard.Base.Network.HTTP.Request.Request
             import Standard.Base.Network.HTTP.Request_Body.Request_Body
             import Standard.Examples

             example_request =
                 req = Request.post "http://httpbin.org/post" Body.Empty
                 with_form = req.with_form (Map.from_vector [["key", "value"]])
                 with_header = with_form.with_header "X-Trace-Id" "123456789"
                 res = Examples.http_client.request with_header
                 res.code

       > Example
         Send a Post request with urlencoded form data.
         Note: This example will send a network request.

             import Standard.Base.Network.HTTP.Request.Request
             import Standard.Base.Network.HTTP.Request_Body.Request_Body
             import Standard.Examples

             example_request =
                 form = Map.from_vector [["name", "John Doe"], ["license.txt", enso_project.root / "LICENSE"]]
                 req = Request.post "http://httpbin.org/post" Request_Body.Empty . with_form form
                 Examples.http_client.request req

       > Example
         Send a Post request with form encoded as "multipart/form-data".
         Note: This example will send a network request.

             import Standard.Base.Network.HTTP.Header.Header
             import Standard.Base.Network.HTTP.Request.Request
             import Standard.Base.Network.HTTP.Request_Body.Request_Body
             import Standard.Examples

             example_request =
                 form = Map.from_vector [["name", "John Doe"], ["license.txt", enso_project.root / "LICENSE"]]
                 req = Request.post "http://httpbin.org/post" Request_Body.Empty
                 with_form = req.with_form form
                 with_headers = with_form.with_headers [Header.multipart_form_data]
                 Examples.http_client.request with_headers

       > Example
         Configure HTTP client and send a Post request with form.
         Note: This example will send a network request.

             import Standard.Base.Data.Time.Duration.Duration
             import Standard.Base.Network.HTTP.HTTP
             import Standard.Base.Network.HTTP.HTTP_Method.HTTP_Method
             import Standard.Base.Network.HTTP.Request.Request

             example_request =
                 form = Map.from_vector [["name", "John Doe"]]
                 req = Request.new HTTP_Method.Post "http://httpbin.org/post" . with_form form
                 http = HTTP.new (timeout = (Duration.new seconds=30))
                 http.request req

       > Example
         Send a Get request with headers, and auto-parse the result
         Note: This example will send a network request.

             import Standard.Base.Network.HTTP.HTTP
             import Standard.Base.Network.HTTP.HTTP_Method.HTTP_Method
             import Standard.Base.Network.HTTP.Request.Request

             example_request =
                 req = Request.new HTTP_Method.Get "http://httpbin.org/get" try_auto_parse_response=True
                 res = Examples.http_client.request req
                 res.body
    request : Request -> Boolean -> Response ! Request_Error
    request self req try_auto_parse_response=False =
        # Prevent request if the method is a write-like method and output context is disabled.
        check_output_context ~action =
            if fetch_methods.contains req.method || Context.Output.is_enabled then action else
                Error.throw (Forbidden_Operation.Error ("Method " + req.method.to_text + " requests are forbidden as the Output context is disabled."))
        handle_request_error =
            Panic.catch JException handler=(cause-> Error.throw (Request_Error.Error 'IllegalArgumentException' cause.payload.getMessage))

        resolved_req = req.resolve_content_type
        resolved_req.if_not_error <| Panic.recover Any <| handle_request_error <| check_output_context <|
            body_publishers = HttpRequest.BodyPublishers
            builder = HttpRequest.newBuilder

            # set uri
            uri = case resolved_req.uri of
                _ : Text -> resolved_req.uri.to_uri
                _ : URI -> resolved_req.uri
            builder.uri uri.internal_uri

            # Generate body publisher, possibly generating additional headers
            body_publisher_and_headers = case resolved_req.body of
                Request_Body.Text text encoding _ ->
                    ## We ignore the content_type field of the request body,
                       since any value it had was moved to the headers list in resolve_content_type
                    headers = [Header.new "Content-Encoding" encoding.character_set]
                    Pair.new (body_publishers.ofString text encoding.to_java_charset) headers
                Request_Body.Json x ->
                    json = x.to_json
                    json.if_not_error <|
                        Pair.new (body_publishers.ofString json) [Header.application_json]
                Request_Body.Binary file ->
                    path = Path.of file.path
                    Pair.new (body_publishers.ofFile path) [Header.application_octet_stream]
                Request_Body.Form_Data form_data url_encoded ->
                    build_form_body_publisher form_data url_encoded
                Request_Body.Empty ->
                    Pair.new (body_publishers.noBody) []
                _ ->
                    Error.throw (Illegal_Argument.Error ("Unsupported POST body: " + resolved_req.body.to_display_text + "; this is a bug in the Data library"))

            # Send request
            body_publisher_and_headers.if_not_error <|
                body_publisher = body_publisher_and_headers.first
                additional_headers = body_publisher_and_headers.second

                # set method and body
                builder.method resolved_req.method.to_http_method_name body_publisher

                # set headers
                all_headers = resolved_req.headers + additional_headers
                all_headers.map h-> builder.header h.name h.value

                http_request = builder.build
                body_handler = HttpResponse.BodyHandlers . ofByteArray

                response = Response.Value (self.internal_http_client.send http_request body_handler)

                if response.code.is_success.not then Error.throw (Request_Error.Error "Status Code" ("Request failed with status code: " + response.code.to_text + ". " + response.body.decode_as_text)) else
                    if try_auto_parse_response.not then response else
                        response.decode if_unsupported=response . catch handler=(_->response)

    ## PRIVATE

       Static helper for get-like methods
    fetch : (URI | Text) -> HTTP_Method -> Vector (Header | Pair Text Text) -> Boolean -> Any
    fetch (uri:(URI | Text)) (method:HTTP_Method=HTTP_Method.Get) (headers:(Vector (Header | Pair Text Text))=[]) (try_auto_parse_response:Boolean=True) =
        check_method fetch_methods method <|
            request = Request.new method uri (parse_headers headers) Request_Body.Empty
            HTTP.new.request request try_auto_parse_response

    ## PRIVATE

       Static helper for post-like methods
    post : (URI | Text) -> Request_Body -> HTTP_Method -> Vector (Header | Pair Text Text) -> Boolean -> Any
    post (uri:(URI | Text)) (body:Request_Body=Request_Body.Empty) (method:HTTP_Method=HTTP_Method.Post) (headers:(Vector (Header | Pair Text Text))=[]) (try_auto_parse_response:Boolean=True) =
        check_method post_methods method <|
            request = Request.new method uri (parse_headers headers) body
            HTTP.new.request request try_auto_parse_response

    ## PRIVATE

       Build an HTTP client.
    internal_http_client : HttpClient
    internal_http_client self =
        builder = HttpClient.newBuilder
        builder.connectTimeout self.timeout
        # redirect
        redirect = HttpClient.Redirect
        redirect_policy = case self.follow_redirects of
            True -> redirect.ALWAYS
            False -> redirect.NEVER
        builder.followRedirects redirect_policy
        # proxy
        case self.proxy of
            Proxy.Address proxy_host proxy_port ->
                proxy_selector = ProxySelector.of (InetSocketAddress.new proxy_host proxy_port)
                builder.proxy proxy_selector
            Proxy.System ->
                proxy_selector = ProxySelector.getDefault
                builder.proxy proxy_selector
            Proxy.None ->
                Nothing
        # version
        case self.version of
            HTTP_Version.HTTP_1_1 ->
                builder.version HttpClient.Version.HTTP_1_1
            HTTP_Version.HTTP_2 ->
                builder.version HttpClient.Version.HTTP_2
        # build http client
        builder.build

## PRIVATE
parse_headers : Vector (Header | Pair Text Text) -> Vector Header
parse_headers headers =
    headers . map h-> case h of
        _ : Vector -> Header.new (h.at 0) (h.at 1)
        _ : Pair -> Header.new (h.at 0) (h.at 1)
        _ : Header -> h
        _ -> Error.throw (Illegal_Argument.Error "Invalid header type - all values must be Vector, Pair or Header (got "+(Meta.get_simple_type_name h)+").")

## PRIVATE

   Build a BodyPublisher from the given form data.
build_form_body_publisher : Map Text (Text | File) -> Boolean -> Pair BodyPublisher [Header]
build_form_body_publisher (form_data:(Map Text (Text | File))) (url_encoded:Boolean=False) = case url_encoded of
    True ->
        body_builder = Http_Utils.urlencoded_body_builder
        form_data.map_with_key key-> value->
            case value of
                _ : Text -> body_builder.add_part_text key value
                _ : File -> body_builder.add_part_file key value.path
        Pair.new body_builder.build []
    False ->
        body_builder = Http_Utils.multipart_body_builder
        form_data.map_with_key key-> value->
            case value of
                _ : Text -> body_builder.add_part_text key value
                _ : File -> body_builder.add_part_file key value.path
        boundary = body_builder.get_boundary
        Pair.new body_builder.build [Header.multipart_form_data boundary]

## PRIVATE
fetch_methods : Set HTTP_Method
fetch_methods = Set.from_vector [HTTP_Method.Get, HTTP_Method.Head, HTTP_Method.Options]

## PRIVATE
post_methods : Set HTTP_Method
post_methods = Set.from_vector [HTTP_Method.Post, HTTP_Method.Put, HTTP_Method.Patch, HTTP_Method.Delete]

## PRIVATE
check_method : Set HTTP_Method -> Any -> Any ! Illegal_Argument
check_method allowed_methods method ~action =
    if allowed_methods.contains method then action else
        Error.throw (Illegal_Argument.Error ("Unsupported method " + method.to_display_text))

## PRIVATE
   An error when sending an HTTP request.

   Arguments:
   - error_type: The type of the error.
   - message: The message for the error.
type Request_Error
    ## PRIVATE
    Error error_type message

    ## PRIVATE
       Convert a request error to a human-readable form.
    to_display_text : Text
    to_display_text self =
        description_text = case self.message of
            Nothing -> ""
            _ -> " " + self.message
        self.error_type + " error when sending request." + description_text
