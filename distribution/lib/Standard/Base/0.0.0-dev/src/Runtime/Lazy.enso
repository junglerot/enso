import project.Any.Any
import project.Error.Error
import project.Nothing.Nothing
import project.Panic.Caught_Panic
import project.Panic.Panic
import project.Runtime.Ref.Ref

## PRIVATE
   Holds a value that is computed on first access.
type Lazy
    ## PRIVATE
    Lazy (cached_ref : Ref) (builder : Nothing -> Any)

    ## PRIVATE
    Eager (value : Any)

    ## PRIVATE
       ADVANCED
       Creates a new lazy value.
    new : Any -> Lazy
    new ~lazy_computation =
        builder _ = lazy_computation
        cached_ref = Ref.new Lazy_Not_Computed_Mark
        Lazy.Lazy cached_ref builder

    ## PRIVATE
       ADVANCED
       Creates a pre-computed lazy value.
       This can be useful if a value needs to admit the Lazy type API, but is
       known beforehand.
    new_eager value = Lazy.Eager value

    ## Returns the stored value.

       The value will be computed on first access and cached.
    get : Any
    get self = case self of
        Lazy.Lazy cached_ref builder -> case cached_ref.get of
            Lazy_Not_Computed_Mark ->
                cached_value = Cached_Value.freeze builder
                cached_ref.put cached_value
                cached_value.get
            cached_value -> cached_value.get
        Lazy.Eager value -> value

## PRIVATE
   This is a special value that should never be returned from a lazy computation
   as it will prevent the lazy value from being cached.
type Lazy_Not_Computed_Mark

## PRIVATE
type Cached_Value
    ## PRIVATE
    Value value

    ## PRIVATE
    Error error

    ## PRIVATE
    Panic (caught_panic : Caught_Panic)

    ## PRIVATE
       Accesses the cached value as if it was just computed - any stored errors
       or panics will be propagated.
    get : Any
    get self = case self of
        Cached_Value.Value value -> value
        Cached_Value.Error error -> Error.throw error
        Cached_Value.Panic caught_panic -> Panic.throw caught_panic

    ## PRIVATE
       Runs the provided `builder` with a `Nothing` argument, handling any
       errors or panics and saving them as a `Cached_Value`.
    freeze : (Nothing -> Any) -> Cached_Value
    freeze builder =
        save_panic caught_panic = Cached_Value.Panic caught_panic
        Panic.catch Any handler=save_panic <|
            result = Cached_Value.Value (builder Nothing)
            result.catch Any dataflow_error->
                Cached_Value.Error dataflow_error
