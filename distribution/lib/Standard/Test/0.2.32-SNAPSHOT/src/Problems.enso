from Standard.Base import all
import Standard.Test

import Standard.Base.Error.Problem_Behavior
import Standard.Base.Error.Warnings

## UNSTABLE
   Tests how a specific operation behaves depending on the requested
   `Problem_Behavior`.

   Arguments:
   - action: The action to execute. It takes a `Problem_Behavior` which
     specifies whether it should ignore problems, report them as warnings or
     raise a dataflow error on the first encountered problem.
   - expected_problems: a list of expected problems, in the order that they are
     expected to be reported. It should not be empty. The problems are assumed
     to be Atoms.
   - result_checker: A function which should verify that the result generated by
     the action is correct. It does not return anything, instead it should use
     the standard testing approach, like `x.should_equal y`.

   TODO [RW] Once proper Warning handling is implemented, the Warning_System
   argument will be removed.
test_problem_handling : (Warnings.Warning_System -> Problem_Behavior -> Any) -> Vector Any -> (Any -> Nothing) -> Nothing
test_problem_handling action expected_problems result_checker =
    # First, we check the action ignoring any warnings.
    result_checker <| action Warnings.default Problem_Behavior.Ignore

    # Then, we check the fail-on-first-error mode.
    first_problem = expected_problems.first
    first_problem_type = Meta.meta first_problem . constructor
    error_result = action Warnings.default Problem_Behavior.Report_Error
    error_result . should_fail_with first_problem_type frames_to_skip=1
    error_result.catch . should_equal first_problem frames_to_skip=1

    # Lastly, we check the report warnings mode and ensure that both the result is correct and the warnings are as expected.
    case Warnings.test_warnings (action _ Problem_Behavior.Report_Warning) of
        Pair result warnings ->
            result_checker result
            warnings . should_equal expected_problems frames_to_skip=1
