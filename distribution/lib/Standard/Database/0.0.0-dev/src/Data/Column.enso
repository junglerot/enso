from Standard.Base import all
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument
import Standard.Base.Errors.Illegal_State.Illegal_State

import Standard.Table.Data.Type.Enso_Types
import Standard.Table.Data.Type.Value_Type_Helpers
import Standard.Table.Data.Column.Column as Materialized_Column
import Standard.Table.Internal.Java_Problems
import Standard.Table.Internal.Problem_Builder.Problem_Builder
import Standard.Table.Internal.Widget_Helpers
from Standard.Table import Sort_Column, Data_Formatter, Value_Type, Auto
from Standard.Table.Errors import Floating_Point_Equality, Inexact_Type_Coercion, Invalid_Value_Type, Conversion_Failure
from Standard.Table.Internal.Cast_Helpers import check_cast_compatibility

import project.Connection.Connection.Connection
import project.Data.SQL_Statement.SQL_Statement
import project.Data.SQL_Type.SQL_Type
import project.Internal.Helpers
import project.Internal.IR.Context.Context
import project.Internal.IR.SQL_Expression.SQL_Expression
import project.Internal.IR.Internal_Column.Internal_Column
import project.Internal.IR.Query.Query
import project.Internal.SQL_Type_Reference.SQL_Type_Reference

from project.Data.Table import Table, freshen_columns

from project.Errors import Unsupported_Database_Operation, Integrity_Error, Unsupported_Name

polyglot java import org.enso.table.data.column.operation.map.MapOperationProblemBuilder

type Column
    ## PRIVATE

       Represents a single column backed by a database.

       Arguments:
       - name: The name of the column.
       - connection: The connection with which the column is associated.
       - sql_type_reference: Lazily computed SQL type of the column.
       - expression: The expressions to apply to the column.
       - context: The SQl context in which the column exists.

       These columns may come from the Table or can be created by combining
       other columns with operators. Expressions created in this way may be
       materialized or used to apply filters, groupings etc. to tables from
       which they come. Combined expressions must come from the same context -
       they must both have the same filtering, grouping etc. rules applied to be
       able to be combined.
    Value name:Text connection:Connection sql_type_reference:SQL_Type_Reference expression:SQL_Expression context:Context

    ## PRIVATE
       ADVANCED
       Returns a text containing an ASCII-art table displaying this data.

       Arguments:
         - show_rows: the number of initial rows that should be displayed.
         - format_terminal: whether ANSI-terminal formatting should be used
    display : Integer -> Boolean -> Text
    display self show_rows=10 format_terminal=False =
        self.to_table.display show_rows format_terminal

    ## PRIVATE
       ADVANCED
       Prints an ASCII-art table with this data to the standard output.

       Arguments:
         - show_rows: the number of initial rows that should be displayed.
    print : Integer -> Nothing
    print self show_rows=10 =
        IO.println (self.display show_rows format_terminal=True)
        IO.println ''

    ## PRIVATE
       Converts this column to JS_Object representation.
    to_js_object : JS_Object
    to_js_object self = self.to_sql.to_js_object

    ## Converts this column into a single-column table.
    to_table : Table
    to_table self =
        Table.Value self.name self.connection [self.as_internal] self.context

    ## Returns a Table describing this column's contents.

       The table behaves like `Table.info` - it lists the column name, the count
       of non-null items and the value type.
    info : Table
    info self = self.to_table.info

    ## Returns a materialized column containing rows of this column.

       Arguments:
       - max_rows: specifies a maximum amount of rows to fetch; if not set, all
         available rows are fetched.
    read : (Nothing | Integer) -> Materialized_Column
    read self max_rows=Nothing =
        self.to_table.read max_rows . at self.name

    ## Returns a vector containing all the elements in this column.
    to_vector : Vector Any
    to_vector self =
        self.to_table.read . at self.name . to_vector

    ## Returns the `Value_Type` associated with that column.

       The value type determines what type of values the column is storing and
       what operations are permitted.
    value_type : Value_Type
    value_type self =
        mapping = self.connection.dialect.get_type_mapping
        mapping.sql_type_to_value_type self.sql_type

    ## Returns an SQL statement that will be used for materializing this column.
    to_sql : SQL_Statement
    to_sql self = self.to_table.to_sql

    ## PRIVATE
       Sets up an operation of arbitrary arity.

       Arguments:
       - op_kind: The kind of the operation
       - operands: A vector of additional operation arguments (the column itself
         is always passed as the first argument).
       - new_name: The name of the resulting column.
    make_op self op_kind operands new_name =
        checked_support = if self.connection.dialect.is_supported op_kind then True else
            Error.throw (Unsupported_Database_Operation.Error "The operation "+op_kind+" is not supported by this backend.")
        checked_support.if_not_error <|
            type_mapping = self.connection.dialect.get_type_mapping
            prepare_operand operand = case operand of
                other_column : Column ->
                    if Helpers.check_integrity self other_column then other_column.expression else
                        Error.throw <| Unsupported_Database_Operation.Error "Cannot use columns coming from different contexts in one expression without a join."
                constant ->
                    SQL_Expression.Constant constant

            expressions = operands.map prepare_operand
            new_expr = SQL_Expression.Operation op_kind ([self.expression] + expressions)

            infer_from_database_callback expression =
                SQL_Type_Reference.new self.connection self.context expression
            new_type_ref = type_mapping.infer_return_type infer_from_database_callback op_kind [self]+operands new_expr
            Column.Value new_name self.connection new_type_ref new_expr self.context

    ## PRIVATE

       Creates a binary operation with given kind and operand.

       Arguments:
       - op_kind: The kind of binary operator.
       - operand: The right operand to the binary operator.
       - new_name: The name of the resulting column.
    make_binary_op : Text -> Text -> (Text | Nothing) -> Column
    make_binary_op self op_kind operand new_name=Nothing =
        effective_new_name = new_name.if_nothing <|
            self.naming_helpers.binary_operation_name op_kind self operand
        self.make_op op_kind [operand] effective_new_name

    ## PRIVATE

       Helper for implementing unary operators.

       Arguments:
       - op_kind: The kind of the unary operator.
       - new_name: The name of the resulting column. If nothing, will create a
         name based on the operator.
    make_unary_op : Text -> Text|Nothing -> Column
    make_unary_op self op_kind new_name=Nothing =
        effective_new_name = new_name.if_nothing <|
            self.naming_helpers.function_name op_kind [self]
        self.make_op op_kind [] effective_new_name

    ## UNSTABLE

       Returns the length of this column.
    length : Integer
    length self = self.to_table.row_count

    ## UNSTABLE

       Returns the number of missing items in this column.
    count_nothing : Integer
    count_nothing self =
        self.to_table.filter 0 Filter_Condition.Is_Nothing . row_count

    ## UNSTABLE

       Returns the number of non-null items in this column.
    count : Integer
    count self =
        self.to_table.filter 0 Filter_Condition.Not_Nothing . row_count

    ## Element-wise equality comparison.

       Arguments:
       - other: The value to compare `self` against. If `other` is a column, the
         comparison is performed pairwise between corresponding elements of
         `self` and `other`.

       Returns a column with results of comparing this column's elements against
       `other`.

       ! Warnings

         - If this operation results in comparing floating-point values for
           equality which is not recommended, a `Floating_Point_Equality`
           warning is attached to the result.

       > Example
         Compare two columns for pairwise equality.

             import Standard.Examples

             example_eq = Examples.integer_column == Examples.decimal_column

       > Example
         Compare a column with a number.

             import Standard.Examples

             example_eq = Examples.integer_column == 1
    == : Column | Any -> Column
    == self other =
        make_equality_check_with_floating_point_handling self other "=="

    ## Element-wise case-insensitive text equality comparison.

       Arguments:
       - other: The value to compare `self` against. If `other` is a column, the
         comparison is performed pairwise between corresponding elements of
         `self` and `other`.

       Returns a column with results of comparing this column's elements against
       `other`.
    equals_ignore_case : Column | Any -> Locale -> Column
    equals_ignore_case self other locale=Locale.default =
        Value_Type.expect_text self <|
            Value_Type.expect_text other <|
                Helpers.assume_default_locale locale <|
                    new_name = self.naming_helpers.function_name "equals_ignore_case" [self, other]
                    self.make_binary_op "equals_ignore_case" other new_name

    ## Element-wise non-equality comparison.

       Arguments:
       - other: The value to compare `self` against. If `other` is a column, the
         comparison is performed pairwise between corresponding elements of
         `self` and `other`.

       Returns a column with results of comparing this column's elements against
       `other`.

       ! Warnings

         - If this operation results in comparing floating-point values for
           equality which is not recommended, a `Floating_Point_Equality`
           warning is attached to the result.

       > Example
         Compare two columns for pairwise inequality.

             import Standard.Examples

             example_neq = Examples.integer_column != Examples.decimal_column

       > Example
         Compare a column with a number.

             import Standard.Examples

             example_neq = Examples.integer_column != 1
    != : Column | Any -> Column
    != self other =
        make_equality_check_with_floating_point_handling self other "!="

    ## UNSTABLE

       Element-wise order comparison.

       Arguments:
       - other: The other column to compare pairwise with.

       Returns a column with results of comparing this column's elements against
       `other`.  If `other` is a column, the comparison is performed pairwise
       between corresponding elements of `self` and `other`.
    >= : Column | Any -> Column
    >= self other = Value_Type.expect_comparable self other <|
        self.make_binary_op ">=" other

    ## UNSTABLE

       Element-wise order comparison.

       Arguments:
       - other: The other column to compare pairwise with.

       Returns a column with results of comparing this column's elements against
       `other`.  If `other` is a column, the comparison is performed pairwise
       between corresponding elements of `self` and `other`.
    <= : Column | Any -> Column
    <= self other = Value_Type.expect_comparable self other <|
        self.make_binary_op "<=" other

    ## UNSTABLE

       Element-wise order comparison.

       Arguments:
       - other: The other column to compare pairwise with.

       Returns a column with results of comparing this column's elements against
       `other`.  If `other` is a column, the comparison is performed pairwise
       between corresponding elements of `self` and `other`.
    > : Column | Any -> Column
    > self other = Value_Type.expect_comparable self other <|
        self.make_binary_op ">" other

    ## UNSTABLE

       Element-wise order comparison.

       Arguments:
       - other: The other column to compare pairwise with.

       Returns a column with results of comparing this column's elements against
       `other`.  If `other` is a column, the comparison is performed pairwise
       between corresponding elements of `self` and `other`.
    < : Column | Any -> Column
    < self other = Value_Type.expect_comparable self other <|
        self.make_binary_op "<" other

    ## Element-wise inclusive bounds check.

       Arguments:
       - lower: The lower bound to compare elements of `self` against. If
         `lower` is a column, the comparison is performed pairwise between
         corresponding elements of `self` and `lower`.
       - upper: The upper bound to compare elements of `self` against. If
         `upper` is a column, the comparison is performed pairwise between
         corresponding elements of `self` and `upper`.

       Returns a column with boolean values indicating whether values of this
       column fit between the lower and upper bounds (both ends inclusive).
    between : (Column | Any) -> (Column | Any) -> Column
    between self lower upper =
        Value_Type.expect_comparable self lower <|
            Value_Type.expect_comparable self upper <|
                new_name = self.naming_helpers.to_expression_text self + " between " + self.naming_helpers.to_expression_text lower + " and " + self.naming_helpers.to_expression_text upper
                self.make_op "BETWEEN" [lower, upper] new_name

    ## UNSTABLE

       Element-wise addition.

       Arguments:
       - other: The other column to add to this column.

       Returns a column containing the result of adding `other` to each element
       of `self`.  If `other` is a column, the operation is performed pairwise
       between corresponding elements of `self` and `other`.
    + : Column | Any -> Column
    + self other =
        op = Value_Type_Helpers.resolve_addition_kind self other
        op.if_not_error <|
            new_name = self.naming_helpers.binary_operation_name "+" self other
            self.make_binary_op op other new_name

    ## UNSTABLE

       Element-wise subtraction.

       Arguments:
       - other: The other column to subtract from this column.

       Returns a column containing the result of subtracting `other` from each
       element of `self`.  If `other` is a column, the operation is performed
       pairwise between corresponding elements of `self` and `other`.
    - : Column | Any -> Column
    - self other =
        Value_Type_Helpers.check_binary_numeric_op self other <|
            self.make_binary_op "-" other

    ## UNSTABLE

       Element-wise multiplication.

       Arguments:
       - other: The other column to multiply `self` by.

       Returns a column containing the result of multiplying `other` by each
       element of `self`.  If `other` is a column, the operation is performed
       pairwise between corresponding elements of `self` and `other`.
    * : Column | Any -> Column
    * self other =
        Value_Type_Helpers.check_binary_numeric_op self other <|
            self.make_binary_op "*" other

    ## ALIAS Divide Columns

       Element-wise division.

       Arguments:
       - other: The value to divide `self` by. If `other` is a column, the
         division is performed pairwise between corresponding elements of `self`
         and `other`.

       Returns a column containing the result of dividing each element of `self`
       by `other`.

       ! Warnings

         - If division by zero occurs, an `Arithmetic_Error` warning is attached
           to the result.

       > Example
         Divide the elements of one column by the elements of another.

             import Standard.Examples

             example_div = Examples.decimal_column / Examples.integer_column

       > Example
         Multiply each value in a column by a single value.

             import Standard.Examples

             example_div = Examples.integer_column / 10
    / : Column | Any -> Column
    / self other =
        Value_Type_Helpers.check_binary_numeric_op self other <|
            self.make_binary_op "/" other

    ## Element-wise modulus.

       Arguments:
       - other: The value to modulo `self` against. If `other` is a column, the
         modulus is performed pairwise between corresponding elements of `self`
         and `other`.

       Returns a column with results of modulus this column's elements against
       `other`.

       ! Warnings

         - If division by zero occurs, an `Arithmetic_Error` warning is attached
           to the result.

       > Example
         Modulus of two columns against each other.

             import Standard.Examples

             example_mod = Examples.integer_column % Examples.decimal_column

       > Example
         Modulus of a column with a number.

             import Standard.Examples

             example_mod = Examples.integer_column % 3
    % : Column | Any -> Column
    % self other =
        Value_Type_Helpers.check_binary_numeric_op self other <|
            other_type = Value_Type_Helpers.find_argument_type other
            # Different implementation may be used for integer types.
            op = if self.value_type.is_integer && (other_type.is_nothing || other_type.is_integer) then "%" else "mod"
            new_name = self.naming_helpers.binary_operation_name "%" self other
            self.make_binary_op op other new_name

    ## ALIAS Power

       Element-wise raising to the power.

       Arguments:
       - other: The exponent to raise `self` by. If `other` is a column, the
         power operation is performed pairwise between corresponding elements
         of `self` and `other`.

       Returns a column containing the result of raising each element of `self`
       by `other`.

       > Example
         Squares the elements of one column.

             import Standard.Examples

             example_div = Examples.decimal_column ^ 2

       > Example
         Raises each value in a column by the value in another column.

             import Standard.Examples

             example_div = Examples.decimal_column ^ Examples.integer_column
    ^ : Column | Any -> Column
    ^ self other =
        Value_Type_Helpers.check_binary_numeric_op self other <|
            self.make_binary_op '^' other

    ## UNSTABLE

       Element-wise boolean conjunction.

       Arguments:
       - other: The other column to compute the conjunction with.

       Returns a column containing the result of performing the boolean `and` on
       `other` and each element of `self`.  If `other` is a column, the
       operation is performed pairwise between corresponding elements of `self`
       and `other`.
    && : Column | Any -> Column
    && self other =
        Value_Type_Helpers.check_binary_boolean_op self other <|
            new_name = self.naming_helpers.binary_operation_name "&&" self other
            self.make_binary_op "AND" other new_name

    ## UNSTABLE

       Element-wise boolean disjunction.

       Arguments:
       - other: The other column to compute the disjunction with.

       Returns a column containing the result of performing the boolean `or` on
       `other` and each element of `self`.  If `other` is a column, the
       operation is performed pairwise between corresponding elements of `self`
       and `other`.
    || : Column | Any -> Column
    || self other =
        Value_Type_Helpers.check_binary_boolean_op self other <|
            new_name = self.naming_helpers.binary_operation_name "||" self other
            self.make_binary_op "OR" other new_name

    ## UNSTABLE

       Boolean negation of each element in this column.
    not : Column
    not self =
        Value_Type.expect_boolean self <|
            new_name = "not " + self.naming_helpers.to_expression_text self
            self.make_unary_op "NOT" new_name

    ## ALIAS IF

       Replaces `True` values with `when_true` and `False` with `when_false`.
       Only meant for use with boolean columns.

       Arguments:
       - when_true: value or column when `self` is `True`.
       - when_false: value or column when `self` is `False`.
    iif : Any -> Any -> Column
    iif self when_true when_false =
        Value_Type.expect_boolean self <|
            common_type = Value_Type_Helpers.find_common_type_for_arguments [when_true, when_false]
            common_type.if_not_error <|
                new_name = "if " + self.naming_helpers.to_expression_text self + " then " + self.naming_helpers.to_expression_text when_true + " else " + self.naming_helpers.to_expression_text when_false
                op_result = self.make_op "IIF" [when_true, when_false] new_name
                adapt_unified_column op_result common_type

    ## Returns a column of first non-`Nothing` value on each row of `self` and
       `values` list.

       Arguments:
       - values: list of columns or values to coalesce with `self`.

       > Example
         Get the first non-`Nothing` value in two columns.

             import Standard.Examples

             example_coalesce = Examples.decimal_column.coalesce Examples.integer_column
    coalesce : (Any | Vector Any) -> Column
    coalesce self values =
        vec = Vector.unify_vector_or_element values
        args_with_self = [self]+vec
        common_type = Value_Type_Helpers.find_common_type_for_arguments args_with_self
        common_type.if_not_error <|
            new_name = self.naming_helpers.function_name "coalesce" args_with_self
            op_result = self.make_op "COALESCE" vec new_name
            adapt_unified_column op_result common_type

    ## Returns a column of minimum on each row of `self` and `values`.

       Arguments:
       - values: list of columns or values to minimum with `self`, or a single
         column or value.

       > Example
         Get the minimum value in two columns.

             import Standard.Examples

             example_min = Examples.decimal_column.min Examples.integer_column
    min : (Any | Vector Any) -> Column
    min self values =
        Value_Type_Helpers.check_multi_argument_comparable_op self values <|
            args = Vector.unify_vector_or_element values
            new_name = self.naming_helpers.function_name "min" [self]+args
            self.make_op "ROW_MIN" args new_name

    ## Returns a column of maximum on each row of `self` and `values`.

       Arguments:
       - values: list of columns or values to maximum with `self`, or a single
         column or value.

       > Example
         Get the maximum value in two columns.

             import Standard.Examples

             example_max = Examples.decimal_column.max Examples.integer_column
    max : (Any | Vector Any) -> Column
    max self values =
        Value_Type_Helpers.check_multi_argument_comparable_op self values <|
            args = Vector.unify_vector_or_element values
            new_name = self.naming_helpers.function_name "max" [self]+args
            self.make_op "ROW_MAX" args new_name

    ## UNSTABLE

       Returns a column of booleans, with `True` items at the positions where
       this column contains a `Nothing`.
    is_nothing : Column
    is_nothing self =
        new_name = self.naming_helpers.to_expression_text self + " is null"
        self.make_unary_op "IS_NULL" new_name

    ## UNSTABLE
       Returns a column of booleans, with `True` items at the positions where
       this column contains a NaN. This is only applicable to double columns.
    is_nan : Column
    is_nan self = Value_Type.expect_floating_point self <|
        new_name = self.naming_helpers.function_name "is_nan" [self]
        self.make_unary_op "IS_NAN" new_name

    ## PRIVATE
       Returns a column of booleans, with `True` items at the positions where
       this column contains an empty string or `Nothing`.
    is_empty : Column
    is_empty self = Value_Type.expect_text self <|
        new_name = self.naming_helpers.to_expression_text self + " is empty"
        self.make_unary_op "IS_EMPTY" new_name

    ## Returns a column of booleans, with `True` items at the positions where
       this column does not contain a `Nothing`.

       > Example
         Check a column for present values.

             import Standard.Examples

             example_is_present = Examples.decimal_column.is_present
    is_present : Column
    is_present self =
        new_name = self.naming_helpers.function_name "is_present" [self]
        self.is_nothing.not . rename new_name

    ## PRIVATE
       Returns a column of booleans with `True` at the positions where this
       column contains a blank value.

       Arguments:
       - treat_nans_as_blank: If `True`, then `Number.nan` is considered as
         blank.

       ? Blank values
         Blank values are `Nothing`, `""` and depending on setting `Number.nan`.
    is_blank : Boolean -> Column
    is_blank self treat_nans_as_blank=False =
        new_name = self.naming_helpers.function_name "is_blank" [self]
        self_type = self.value_type
        is_blank = case self_type.is_text of
            True -> self.is_empty
            False -> self.is_nothing
        result = case treat_nans_as_blank && self_type.is_floating_point && self.connection.dialect.supports_separate_nan of
            True -> is_blank || self.is_nan
            False -> is_blank
        result.rename new_name

    ## UNSTABLE

       Returns a new column where missing values have been replaced with the
       provided default.
    fill_nothing : Column | Any -> Column
    fill_nothing self default =
        common_type = Value_Type_Helpers.find_common_type_for_arguments [self, default]
        common_type.if_not_error <|
            new_name = self.naming_helpers.function_name "fill_nothing" [self, default]
            op_result = self.make_binary_op "FILL_NULL" default new_name
            adapt_unified_column op_result common_type

    ## ALIAS Fill Empty

       Returns a new column where empty Text values have been replaced with the
       provided default.

       Arguments:
       - default: The value to replace missing values with. If this argument
         is a column, the value from `default` at the corresponding position
         will be used.
    fill_empty : Column | Any -> Column
    fill_empty self default =
        Value_Type.expect_text self <|
            Value_Type.expect_text default <|
                new_name = self.naming_helpers.function_name "fill_empty" [self, default]
                result = self.is_empty.iif default self
                result.rename new_name

    ## Returns a new column, containing the same elements as `self`, but with
       the given name.

       Arguments:
       - name: The new name for the column.

       > Example
         Rename a column.

             import Standard.Examples

             example_rename = Examples.integer_column.rename "My Numbers"
    rename : Text -> Column ! Illegal_Argument
    rename self name = self.naming_helpers.ensure_name_is_valid name <|
        Column.Value name self.connection self.sql_type_reference self.expression self.context

    ## UNSTABLE

       Sorts the column according to the specified rules.

       Arguments:
         - order: Specifies the default sort order for this operation.
         - missing_last: Specifies the default placement of missing values when
           compared to non-missing ones. Note that this argument is independent
           from `order`, i.e. missing values will always be sorted according to
           this rule, ignoring the ascending / descending setting.

       > Example
         Sorting `column` in ascending order.
             column.sort

       > Example
         Sorting `column` in descending order.
             column.sort Sort_Direction.Descending
    sort : Sort_Direction -> Column
    sort self order=Sort_Direction.Ascending =
        self.to_table.order_by (Sort_Column.Index 0 order) . at 0

    ## UNSTABLE
       Creates a new Column with the specified range of rows from the input
       Column.

       Arguments:
       - range: The selection of rows from the table to return.
    @range Index_Sub_Range.default_widget
    take : (Index_Sub_Range | Range | Integer) -> Column
    take self range=(First 1) =
        _ = range
        msg = "`Column.take` is not yet implemented."
        Error.throw (Unsupported_Database_Operation.Error msg)

    ## UNSTABLE
       Creates a new Column from the input with the specified range of rows
       removed.

       Arguments:
       - range: The selection of rows from the table to remove.
    @range Index_Sub_Range.default_widget
    drop : (Index_Sub_Range | Range | Integer) -> Column
    drop self range=(First 1) =
        _ = range
        msg = "`Column.drop` is not yet implemented."
        Error.throw (Unsupported_Database_Operation.Error msg)

    ## UNSTABLE

       Checks for each element of the column if it starts with `other`.

       Arguments:
       - other: A column or text to check for each item in `self`.
       - case_sensitivity: Specifies if the text values should be compared case
         sensitively.

       If `other` is a column, the operation is performed pairwise between
       corresponding elements of `self` and `other`.  If the argument is a
       missing value (a Nothing or a column with missing values), the behaviour
       on these missing values is vendor specific.
    starts_with : Column | Text -> Case_Sensitivity -> Column
    starts_with self other case_sensitivity=Case_Sensitivity.Default =
        new_name = self.naming_helpers.function_name "starts_with" [self, other]
        make_text_case_op self "starts_with" other case_sensitivity new_name

    ## UNSTABLE

       Checks for each element of the column if it ends with `other`.

       Arguments:
       - other: A column ot text to check for each item in `self`.
       - case_sensitivity: Specifies if the text values should be compared case
         sensitively.

       If `other` is a column, the operation is performed pairwise between
       corresponding elements of `self` and `other`.  If the argument is a
       missing value (a Nothing or a column with missing values), the behaviour
       on these missing values is vendor specific.
    ends_with : Column | Text -> Case_Sensitivity -> Column
    ends_with self other case_sensitivity=Case_Sensitivity.Default =
        new_name = self.naming_helpers.function_name "ends_with" [self, other]
        make_text_case_op self "ends_with" other case_sensitivity new_name

    ## UNSTABLE

       Checks for each element of the column if it contains `other`.

       Arguments:
       - other: A column ot text to check for each item in `self`.
       - case_sensitivity: Specifies if the text values should be compared case
         sensitively.

       If `other` is a column, the operation is performed pairwise between
       corresponding elements of `self` and `other`.  If the argument is a
       missing value (a Nothing or a column with missing values), the behaviour
       on these missing values is vendor specific.
    contains : Column | Text -> Case_Sensitivity -> Column
    contains self other case_sensitivity=Case_Sensitivity.Default =
        new_name = self.naming_helpers.function_name "contains" [self, other]
        make_text_case_op self "contains" other case_sensitivity new_name

    ## Checks for each element of the column if it matches an SQL-like pattern.

       Arguments:
       - pattern: The pattern to match `self` against. If it is a column, the
         operation is performed pairwise between corresponding elements of
         `self` and that column. The pattern is an SQL-like pattern, where
         `%` matches any sequence of characters and `_` matches any single
         character.

       > Example
         Check if elements of a column start with 'F' and end with a dot.

             import Standard.Examples

             example_contains = Examples.text_column_1.like "F%."
    like : Column | Text -> Column
    like self pattern =
        Value_Type.expect_text self <|
            Value_Type.expect_text pattern <|
                new_name = self.naming_helpers.binary_operation_name "like" self pattern
                self.make_binary_op "LIKE" pattern new_name

    ## This function removes the specified characters, by default any
       whitespace, from the start, the end, or both ends of the input.

       Arguments:
       - where: The location of where to trim the input. By default, this
         function trims both ends of the input.
       - what: A `Text` (or text `Column`) containing characters that should be
         removed. By default, spaces, tabs, returns and new lines are removed.
    trim : Location -> Column | Text -> Column
    trim self where=Location.Both what='' =
        Value_Type.expect_text self <|
            Value_Type.expect_text what <|
                new_name = self.naming_helpers.function_name "trim" [self]
                operator = case where of
                    Location.Both -> "TRIM"
                    Location.Start -> "LTRIM"
                    Location.End -> "RTRIM"
                if self.connection.dialect.is_supported operator then self.make_binary_op operator what new_name else
                    Error.throw (Unsupported_Database_Operation.Error ("`Column.trim "+where.to_text+"` is not supported by this connection."))

    ## Replaces the first, or all occurrences of `term` with `new_text` in each
       row. If `term` is empty, the function returns the table unchanged.

       This method follows the exact replacement semantics of the
       `Text.replace` method.

       Arguments:
       - term: The term to find.
       - replacement: The text to replace matches with.
       - case_sensitivity: Specifies if the text values should be compared case
         sensitively.
       - only_first: If True, only replace the first match.
       - use_regex: If true, the term is used as a regular expression.

       > Example
         Replace dashes with underscores.

             column.replace "-" "_"

       > Example
         Remove leading and trailing spaces from cells.

             column.replace "^\s*(.*?)\s*$" "$1" use_regex=True

       > Example
         Replace texts in quotes with parentheses.

             column.replace '"(.*?)"' '($1)' use_regex=True
    replace : Text | Column -> Text | Column -> Case_Sensitivity -> Boolean -> Boolean -> Column
    replace self term="" new_text="" case_sensitivity=Case_Sensitivity.Sensitive only_first=False use_regex=False =
        _ = [term, new_text, case_sensitivity, only_first, use_regex]
        msg = "`Column.replace` is not yet implemented."
        Error.throw (Unsupported_Database_Operation.Error msg)

    ## Gets the year as a number from the date stored in the column.

       Applies only to columns that hold the `Date` or `Date_Time` types.
       Returns a column of `Integer` type.
    year : Column ! Invalid_Value_Type
    year self = Value_Type.expect_has_date self <|
        self.make_unary_op "year"

    ## Gets the month as a number (1-12) from the date stored in the column.

       Applies only to columns that hold the `Date` or `Date_Time` types.
       Returns a column of `Integer` type.
    month : Column ! Invalid_Value_Type
    month self = Value_Type.expect_has_date self <|
        self.make_unary_op "month"

    ## Gets the day of the month as a number (1-31) from the date stored in the
       column.

       Applies only to columns that hold the `Date` or `Date_Time` types.
       Returns a column of `Integer` type.
    day : Column ! Invalid_Value_Type
    day self = Value_Type.expect_has_date self <|
        self.make_unary_op "day"

    ## Checks for each element of the column if it is contained within the
       provided vector or column.

       Arguments:
       - vector: A vector of elements or another column. The resulting column
         will contain true at the positions where the corresponding element of
         `self` is contained in `vector`.

       > Example
         Check if elements of a column are contained in a provided vector.

             import Standard.Examples

             example_contains = Examples.text_column_1.is_in [1, 2, 5]
    is_in : Column | Vector -> Column
    is_in self vector =
        new_name = self.naming_helpers.binary_operation_name "in" self vector
        case vector of
            _ : Vector ->
                ## This is slightly hacky - we don't provide operand types as we want to
                   allow any type to get through and currently we do not have a mapping
                   from Enso types to SQL types (it may be available in the future). So
                   we just rely on Nothing resolving to the current column type. That
                   type may not always match the operands, but the current
                   implementation uses this type only for two purposes: generated SQL
                   visualization (so the color will be consistent with the column type
                   and not the value type - that can be confusing, we probably want to
                   fix it later) and setting up the query - but at the set up this only
                   applies to adding nulls - setting any other object does not check the
                   type at this level anyway.
                partitioned = vector.partition .is_nothing
                nulls = partitioned.first
                non_nulls = partitioned.second
                ## Since SQL `NULL IN (NULL)` yields `NULL`, we need to handle this case
                   separately. So we handle all non-null values using `IS_IN` and then
                   `OR` that with a null check (if the vector contained any nulls to
                   begin with). The implementation also ensures that even
                   `NULL IN (...)` is coalesced to False, so that negation works as
                   expected.
                is_in_not_null = self.make_op "IS_IN" operands=non_nulls new_name=new_name
                result = case nulls.not_empty of
                    True -> is_in_not_null || self.is_nothing
                    False -> is_in_not_null
                result.rename new_name
            _ : Array -> self.is_in (Vector.from_polyglot_array vector)
            column : Column -> if Helpers.check_connection self column . not then (Error.throw (Integrity_Error.Error "Column "+column.name)) else
                ## We slightly abuse the expression syntax putting a Query as one of
                   the sub-expressions. Once type-checking is added, we may need to
                   amend the signature of `SQL_Expression.Operation` to account for
                   this. Also, unfortunately as `NULL IN (...)` is `NULL` in SQL, we
                   need to do separate handling of nulls - we check if the target
                   column has any nulls and if so, we will do `IS NULL` checks for
                   our columns too. That is because, we want the containment check
                   for `NULL` to work the same way as for any other value.
                in_subquery = Query.Select [Pair.new column.name column.expression] column.context
                has_nulls_expression = SQL_Expression.Operation "BOOL_OR" [column.is_nothing.expression]
                has_nulls_subquery = Query.Select [Pair.new "has_nulls" has_nulls_expression] column.context
                new_expr = SQL_Expression.Operation "IS_IN_COLUMN" [self.expression, in_subquery, has_nulls_subquery]
                # This mapping should never be imprecise, if there are errors we need to amend the implementation.
                sql_type = self.connection.dialect.get_type_mapping.value_type_to_sql Value_Type.Boolean Problem_Behavior.Report_Error
                new_type_ref = SQL_Type_Reference.from_constant sql_type . catch Inexact_Type_Coercion _->
                    Error.throw (Illegal_State.Error "The dialect "+self.connection.dialect.name+" does not support a boolean type. The implementation of `is_in` should be revised to account for this. This is an internal issue with the Database library.")
                Column.Value new_name self.connection new_type_ref new_expr self.context

    ## Parsing values is not supported in database columns.
    @type Widget_Helpers.parse_type_selector
    parse : Value_Type | Auto -> Text | Data_Formatter -> Problem_Behavior -> Column
    parse self type=Auto format=Data_Formatter.Value on_problems=Report_Warning =
        _ = [type, format, on_problems]
        Error.throw <| Unsupported_Database_Operation.Error "`Column.parse` is not implemented yet for the Database backends."

    ## Formatting values is not supported in database columns.
    format : Text | Column -> Locale -> Column ! Illegal_Argument
    format self format=Nothing locale=Locale.default =
        _ = [format, locale]
        Error.throw <| Unsupported_Database_Operation.Error "`Column.format` is not implemented yet for the Database backends."

    ## Cast the column to a specific type.

       Arguments:
       - value_type: The `Value_Type` to cast the column to.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

       In the Database backend, this will boil down to a CAST operation.
       In the in-memory backend, a conversion will be performed according to
       the following rules:
       - Anything can be cast into the `Mixed` type.
       - Converting to a `Char` type, the elements of the column will be
         converted to text. If it is fixed length, the texts will be trimmed or
         padded on the right with the space character to match the desired
         length.
       - Conversion between numeric types will replace values exceeding the
         range of the target type with `Nothing`.
       - Converting decimal numbers into integers will truncate or round them,
         depending on the backend. If more control is needed, use the various
         rounding functions (such as `round` or `floor`).
       - Booleans may also be converted to numbers, with `True` being converted
         to `1` and `False` to `0`. The reverse is not supported - use `iif`
         instead.
       - A `Date_Time` may be converted into a `Date` or `Time` type - the
         resulting value will be truncated to the desired type.
       - If a `Date` is to be converted to `Date_Time`, it will be set at
         midnight of the default system timezone.

        If the target type cannot fit some of the values (for example due to too
        small range), a `Conversion_Failure` may be reported according to the
        `on_problems` rules. The Database backends may fail with `SQL_Error`
        instead.

       ? Inexact Target Type

         If the backend does not support the requested target type, the closest
         supported type is chosen and a `Inexact_Type_Coercion` problem is
         reported.
    cast : Value_Type -> Problem_Behavior -> Column ! Illegal_Argument | Inexact_Type_Coercion | Conversion_Failure
    cast self value_type on_problems=Problem_Behavior.Report_Warning =
        check_cast_compatibility self.value_type value_type <|
            dialect = self.connection.dialect
            type_mapping = dialect.get_type_mapping
            target_sql_type = type_mapping.value_type_to_sql value_type on_problems
            target_sql_type.if_not_error <|
                infer_from_database new_expression =
                    SQL_Type_Reference.new self.connection self.context new_expression
                new_column = dialect.make_cast self.as_internal target_sql_type infer_from_database
                Column.Value new_column.name self.connection new_column.sql_type_reference new_column.expression self.context

    ## ALIAS Transform Column

       Applies `function` to each item in this column and returns the column
       of results.

       Arguments:
       - function: The function to apply to each element of `self` column.
       - skip_nothing: If `True`, `Nothing` values will be skipped. Otherwise,
         `Nothing` values will be passed to the `function`.

       > Example
         Multiply each element of the column by itself.

             import Standard.Examples

             example_map = Examples.integer_column.map (x -> x * x)
    map : (Any -> Any) -> Boolean -> Column
    map self function skip_nothing=True =
        _ = [function, skip_nothing]
        Error.throw <| Unsupported_Database_Operation.Error "`Column.map` is not supported in the Database backends."

    ## ALIAS Transform Columns

       Applies `function` to consecutive pairs of elements of `self` and `that`
       and returns a column of results.

       Arguments:
       - that: The column to zip with `self`.
       - function: A binary function that is applied to corresponding pairs of
         elements of `self` and `that` to produce a value.
       - skip_nothing: controls whether missing values should be passed to the
         `function`. The default value of `True` will skip the rows for which
         the value in either column is missing and automatically append
         `Nothing` to the result table. If set to `False`, every pair of values
         is passed to `function`.

       > Example
         Zip two columns together as pairs.

             import Standard.Examples

             example_zip =
                Examples.integer_column.zip Examples.text_column_1 [_, _]
    zip : Column -> (Any -> Any -> Any) -> Boolean -> Column
    zip self that function skip_nothing=True =
        _ = [that, function, skip_nothing]
        Error.throw <| Unsupported_Database_Operation.Error "`Column.zip` is not supported in the Database backends."

    ## PRIVATE
    as_internal : Internal_Column
    as_internal self = Internal_Column.Value self.name self.sql_type_reference self.expression

    ## PRIVATE
       Provides a simplified text representation for display in the REPL and errors.
    to_text : Text
    to_text self = "(Database Column "+self.name.to_text+")"

    ## PRIVATE
    sql_type : SQL_Type
    sql_type self = self.sql_type_reference.get

    ## PRIVATE
    naming_helpers self = self.connection.dialect.get_naming_helpers

    ## PRIVATE
       Helper for the expression to tell it which functions needs a Vector.
    var_args_functions : Array
    var_args_functions = ['is_in', 'coalesce', 'min', 'max']

## PRIVATE
   Helper for case case_sensitivity based text operations
make_text_case_op left op other case_sensitivity new_name =
    result = Value_Type.expect_text left <| Value_Type.expect_text other <| case case_sensitivity of
        Case_Sensitivity.Default -> left.make_binary_op op other
        Case_Sensitivity.Sensitive ->
            make_sensitive column =
                column.make_unary_op "MAKE_CASE_SENSITIVE" "MAKE_CASE_SENSITIVE"
            cs_other = if other.is_a Column then make_sensitive other else other
            (make_sensitive left) . make_binary_op op cs_other
        Case_Sensitivity.Insensitive locale -> Helpers.assume_default_locale locale <|
            fold_case column =
                column.make_unary_op "FOLD_CASE" "FOLD_CASE"
            ci_other = if other.is_a Column then fold_case other else other.to_case Case.Lower
            (fold_case left) . make_binary_op op ci_other
    result.rename new_name

## PRIVATE
make_equality_check_with_floating_point_handling column other op =
    other_name = case other of
        other_column : Column -> "["+other_column.name+"]"
        _ -> other.to_text
    location = "["+column.name+"] "+op+" "+other_name
    problem_builder = MapOperationProblemBuilder.new location
    if column.value_type.is_floating_point then
        problem_builder.reportFloatingPointEquality -1
    case other of
        other_column : Column ->
            if other_column.value_type.is_floating_point then
                problem_builder.reportFloatingPointEquality -1
        _ : Decimal ->
            problem_builder.reportFloatingPointEquality -1
        _ -> Nothing
    result = column.make_binary_op op other
    Problem_Behavior.Report_Warning.attach_problems_after result <|
        Java_Problems.parse_aggregated_problems problem_builder.getProblems

## PRIVATE
adapt_unified_column : Column -> Value_Type -> Column
adapt_unified_column column expected_type =
    dialect = column.connection.dialect
    infer_return_type expression =
        SQL_Type_Reference.new column.connection column.context expression
    adapted = dialect.adapt_unified_column column.as_internal expected_type infer_return_type
    Column.Value name=column.name connection=column.connection sql_type_reference=adapted.sql_type_reference expression=adapted.expression context=column.context
