from Standard.Base import all
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument
import Standard.Base.Errors.Illegal_State.Illegal_State
import Standard.Base.Internal.Rounding_Helpers
from Standard.Base.Widget_Helpers import make_regex_text_widget

import Standard.Table.Data.Column.Column as Materialized_Column
import Standard.Table.Data.Constants.Previous_Value
import Standard.Table.Data.Type.Enso_Types
import Standard.Table.Data.Type.Value_Type_Helpers
import Standard.Table.Internal.Column_Naming_Helper.Column_Naming_Helper
import Standard.Table.Internal.Date_Time_Helpers
import Standard.Table.Internal.Java_Problems
import Standard.Table.Internal.Problem_Builder.Problem_Builder
import Standard.Table.Internal.Widget_Helpers
from Standard.Table import Auto, Data_Formatter, Sort_Column, Value_Type
from Standard.Table.Data.Column import default_date_period
from Standard.Table.Errors import Conversion_Failure, Floating_Point_Equality, Inexact_Type_Coercion, Invalid_Value_Type
from Standard.Table.Internal.Cast_Helpers import check_cast_compatibility

import project.Connection.Connection.Connection
import project.Data.SQL_Statement.SQL_Statement
import project.Data.SQL_Type.SQL_Type
import project.Data.Table.Table
import project.Internal.Helpers
import project.Internal.IR.Context.Context
import project.Internal.IR.Internal_Column.Internal_Column
import project.Internal.IR.Query.Query
import project.Internal.IR.SQL_Expression.SQL_Expression
import project.Internal.Replace_Params.Replace_Params
import project.Internal.SQL_Type_Reference.SQL_Type_Reference
from project.Errors import Integrity_Error, Unsupported_Database_Operation

type Column
    ## PRIVATE

       Represents a single column backed by a database.

       Arguments:
       - name: The name of the column.
       - connection: The connection with which the column is associated.
       - sql_type_reference: Lazily computed SQL type of the column.
       - expression: The expressions to apply to the column.
       - context: The SQl context in which the column exists.

       These columns may come from the Table or can be created by combining
       other columns with operators. Expressions created in this way may be
       materialized or used to apply filters, groupings etc. to tables from
       which they come. Combined expressions must come from the same context -
       they must both have the same filtering, grouping etc. rules applied to be
       able to be combined.
    Value name:Text connection:(Connection | Any) sql_type_reference:SQL_Type_Reference expression:SQL_Expression context:Context

    ## PRIVATE
       ADVANCED
       Returns a text containing an ASCII-art table displaying this data.

       Arguments:
         - show_rows: the number of initial rows that should be displayed.
         - format_terminal: whether ANSI-terminal formatting should be used
    display : Integer -> Boolean -> Text
    display self show_rows=10 format_terminal=False =
        self.to_table.display show_rows format_terminal

    ## PRIVATE
       ADVANCED
       Prints an ASCII-art table with this data to the standard output.

       Arguments:
         - show_rows: the number of initial rows that should be displayed.
    print : Integer -> Nothing
    print self show_rows=10 =
        IO.println (self.display show_rows format_terminal=True)
        IO.println ''

    ## PRIVATE
       Converts this column to JS_Object representation.
    to_js_object : JS_Object
    to_js_object self = self.to_sql.to_js_object

    ## ICON data_input
       Converts this column into a single-column table.
    to_table : Table
    to_table self =
        Table.Value self.name self.connection [self.as_internal] self.context

    ## GROUP Standard.Base.Metadata
       Returns a Table describing this column's contents.

       The table behaves like `Table.info` - it lists the column name, the count
       of non-null items and the value type.
    info : Table
    info self = self.to_table.info

    ## GROUP Standard.Base.Input
       ICON data_input
       Returns a materialized column containing rows of this column.

       Arguments:
       - max_rows: specifies the maximum number of rows to read.
         If `Nothing`, all available rows are returned.
       - warn_if_more_rows: if set to `True`, a warning is attached to the
         result if the number of rows returned by the query exceeds `max_rows`.
    read : (Nothing | Integer) -> Boolean -> Materialized_Column
    read self (max_rows : Nothing | Integer = 1000) (warn_if_more_rows:Boolean = True) =
        self.to_table.read max_rows warn_if_more_rows . at 0

    ## GROUP Standard.Base.Conversions
       ICON convert
       Returns a vector containing all the elements in this column.
    to_vector : Vector Any
    to_vector self = self.read max_rows=Nothing . to_vector

    ## GROUP Standard.Base.Metadata
       Returns the `Value_Type` associated with that column.

       The value type determines what type of values the column is storing and
       what operations are permitted.
    value_type : Value_Type
    value_type self =
        mapping = self.connection.dialect.get_type_mapping
        mapping.sql_type_to_value_type self.sql_type

    ## PRIVATE
       Returns a possibly more precise `Value_Type` based on the data in the
       column.

       Most columns will return their type without changes. A mixed column may
       return a more precise type if a common type can be found for all of its
       values.
    inferred_precise_value_type : Value_Type
    inferred_precise_value_type self =
        self.value_type

    ## Returns an SQL statement that will be used for materializing this column.
    to_sql : SQL_Statement
    to_sql self = self.to_table.to_sql

    ## PRIVATE
       Sets up an operation of arbitrary arity.

       Arguments:
       - op_kind: The kind of the operation
       - operands: A vector of additional operation arguments (the column itself
         is always passed as the first argument).
       - new_name: The name of the resulting column.
       - metadata: Optional metadata for the `SQL_Expression.Operation`.
    make_op : Text -> Vector Text -> (Text | Nothing) -> (Any | Nothing) -> Column
    make_op self op_kind operands new_name metadata=Nothing =
        checked_support = if self.connection.dialect.is_supported op_kind then True else
            Error.throw (Unsupported_Database_Operation.Error "The operation "+op_kind+" is not supported by this backend.")
        checked_support.if_not_error <|
            type_mapping = self.connection.dialect.get_type_mapping
            prepare_operand operand = case operand of
                other_column : Column ->
                    if Helpers.check_integrity self other_column then other_column.expression else
                        Error.throw <| Unsupported_Database_Operation.Error "Cannot use columns coming from different contexts in one expression without a join."
                sql_expression : SQL_Expression ->
                    sql_expression
                constant ->
                    SQL_Expression.Constant constant

            expressions = operands.map prepare_operand
            new_expr = SQL_Expression.Operation op_kind ([self.expression] + expressions) metadata

            infer_from_database_callback expression =
                SQL_Type_Reference.new self.connection self.context expression
            new_type_ref = type_mapping.infer_return_type infer_from_database_callback op_kind [self]+operands new_expr
            Column.Value new_name self.connection new_type_ref new_expr self.context

    ## PRIVATE

       Creates a binary operation with given kind and operand.

       Arguments:
       - op_kind: The kind of binary operator.
       - operand: The right operand to the binary operator.
       - new_name: The name of the resulting column.
    make_binary_op : Text -> Text -> (Text | Nothing) -> Column
    make_binary_op self op_kind operand new_name=Nothing =
        effective_new_name = new_name.if_nothing <|
            self.naming_helper.binary_operation_name op_kind self operand
        self.make_op op_kind [operand] effective_new_name

    ## PRIVATE

       Helper for implementing unary operators.

       Arguments:
       - op_kind: The kind of the unary operator.
       - new_name: The name of the resulting column. If nothing, will create a
         name based on the operator.
    make_unary_op : Text -> Text|Nothing -> Column
    make_unary_op self op_kind new_name=Nothing =
        effective_new_name = new_name.if_nothing <|
            self.naming_helper.function_name op_kind [self]
        self.make_op op_kind [] effective_new_name

    ## GROUP Standard.Base.Metadata
       Returns the length of this column.
    length : Integer
    length self = self.to_table.row_count

    ## GROUP Standard.Base.Metadata
       Returns the number of missing items in this column.
    count_nothing : Integer
    count_nothing self =
        self.to_table.filter 0 Filter_Condition.Is_Nothing . row_count

    ## GROUP Standard.Base.Metadata
       Returns the number of non-null items in this column.
    count : Integer
    count self =
        self.to_table.filter 0 Filter_Condition.Not_Nothing . row_count

    ## ALIAS equals
       GROUP Standard.Base.Operators
       Element-wise equality comparison.

       Arguments:
       - other: The value to compare `self` against. If `other` is a column, the
         comparison is performed pairwise between corresponding elements of
         `self` and `other`.

       Returns a column with results of comparing this column's elements against
       `other`.

       ! Warnings

         - If this operation results in comparing floating-point values for
           equality which is not recommended, a `Floating_Point_Equality`
           warning is attached to the result.

       > Example
         Compare two columns for pairwise equality.

             import Standard.Examples

             example_eq = Examples.integer_column == Examples.decimal_column

       > Example
         Compare a column with a number.

             import Standard.Examples

             example_eq = Examples.integer_column == 1
    == : Column | Any -> Column
    == self other =
        make_equality_check_with_floating_point_handling self other "=="

    ## GROUP Standard.Base.Logical
       Element-wise case-insensitive text equality comparison.

       Arguments:
       - other: The value to compare `self` against. If `other` is a column, the
         comparison is performed pairwise between corresponding elements of
         `self` and `other`.
       - locale: The locale to use for the case-insensitive comparison.

       Returns a column with results of comparing this column's elements against
       `other`.
    @locale Locale.default_widget
    equals_ignore_case : Column | Any -> Locale -> Column
    equals_ignore_case self other locale=Locale.default =
        Value_Type.expect_text self <|
            Value_Type.expect_text other <|
                Helpers.assume_default_locale locale <|
                    new_name = self.naming_helper.function_name "equals_ignore_case" [self, other]
                    self.make_binary_op "equals_ignore_case" other new_name

    ## ALIAS not equals
       GROUP Standard.Base.Operators
       Element-wise non-equality comparison.

       Arguments:
       - other: The value to compare `self` against. If `other` is a column, the
         comparison is performed pairwise between corresponding elements of
         `self` and `other`.

       Returns a column with results of comparing this column's elements against
       `other`.

       ! Warnings

         - If this operation results in comparing floating-point values for
           equality which is not recommended, a `Floating_Point_Equality`
           warning is attached to the result.

       > Example
         Compare two columns for pairwise inequality.

             import Standard.Examples

             example_neq = Examples.integer_column != Examples.decimal_column

       > Example
         Compare a column with a number.

             import Standard.Examples

             example_neq = Examples.integer_column != 1
    != : Column | Any -> Column
    != self other =
        make_equality_check_with_floating_point_handling self other "!="

    ## ALIAS greater than or equal
       GROUP Standard.Base.Operators
       Element-wise order comparison.

       Arguments:
       - other: The other column to compare pairwise with.

       Returns a column with results of comparing this column's elements against
       `other`.  If `other` is a column, the comparison is performed pairwise
       between corresponding elements of `self` and `other`.
    >= : Column | Any -> Column
    >= self other = Value_Type.expect_comparable self other <|
        self.make_binary_op ">=" other

    ## ALIAS less than or equal
       GROUP Standard.Base.Operators
       Element-wise order comparison.

       Arguments:
       - other: The other column to compare pairwise with.

       Returns a column with results of comparing this column's elements against
       `other`.  If `other` is a column, the comparison is performed pairwise
       between corresponding elements of `self` and `other`.
    <= : Column | Any -> Column
    <= self other = Value_Type.expect_comparable self other <|
        self.make_binary_op "<=" other

    ## ALIAS greater than
       GROUP Standard.Base.Operators
       Element-wise order comparison.

       Arguments:
       - other: The other column to compare pairwise with.

       Returns a column with results of comparing this column's elements against
       `other`.  If `other` is a column, the comparison is performed pairwise
       between corresponding elements of `self` and `other`.
    > : Column | Any -> Column
    > self other = Value_Type.expect_comparable self other <|
        self.make_binary_op ">" other

    ## ALIAS less than
       GROUP Standard.Base.Operators
       Element-wise order comparison.

       Arguments:
       - other: The other column to compare pairwise with.

       Returns a column with results of comparing this column's elements against
       `other`.  If `other` is a column, the comparison is performed pairwise
       between corresponding elements of `self` and `other`.
    < : Column | Any -> Column
    < self other = Value_Type.expect_comparable self other <|
        self.make_binary_op "<" other

    ## GROUP Standard.Base.Logical
       Element-wise inclusive bounds check.

       Arguments:
       - lower: The lower bound to compare elements of `self` against. If
         `lower` is a column, the comparison is performed pairwise between
         corresponding elements of `self` and `lower`.
       - upper: The upper bound to compare elements of `self` against. If
         `upper` is a column, the comparison is performed pairwise between
         corresponding elements of `self` and `upper`.

       Returns a column with boolean values indicating whether values of this
       column fit between the lower and upper bounds (both ends inclusive).
    between : (Column | Any) -> (Column | Any) -> Column
    between self lower upper =
        Value_Type.expect_comparable self lower <|
            Value_Type.expect_comparable self upper <|
                new_name = self.naming_helper.concat <|
                    [self.naming_helper.to_expression_text self, "between", self.naming_helper.to_expression_text lower, "and", self.naming_helper.to_expression_text upper]
                self.make_op "BETWEEN" [lower, upper] new_name

    ## ALIAS add, concatenate, plus
       GROUP Standard.Base.Operators
       Element-wise addition. Works on numeric types or text.

       Arguments:
       - other: The other column to add to this column.

       Returns a column containing the result of adding `other` to each element
       of `self`.  If `other` is a column, the operation is performed pairwise
       between corresponding elements of `self` and `other`.

       ? Arithmetic Overflow

         For integer columns, the operation may yield results that will not fit
         into the range supported by the column. In such case, the in-memory
         backend will replace such results with `Nothing` and report a
         `Arithmetic_Overflow` warning. The behaviour in Database backends is
         not specified and will depend on the particular database - it may
         cause a hard error, the value may be truncated or wrap-around etc.
    + : Column | Any -> Column
    + self other =
        op = case Value_Type_Helpers.resolve_addition_kind self other of
            Value_Type_Helpers.Addition_Kind.Numeric_Add -> "ADD_NUMBER"
            Value_Type_Helpers.Addition_Kind.Text_Concat -> "ADD_TEXT"
        op.if_not_error <|
            new_name = self.naming_helper.binary_operation_name "+" self other
            self.make_binary_op op other new_name

    ## ALIAS minus, subtract, time difference
       GROUP Standard.Base.Operators
       Element-wise subtraction. Allows to subtract numeric types or compute a
       difference between two date/time values.

       Arguments:
       - other: The other column to subtract from this column.

       Returns a column containing the result of subtracting `other` from each
       element of `self`.  If `other` is a column, the operation is performed
       pairwise between corresponding elements of `self` and `other`.

       ? Arithmetic Overflow

         For integer columns, the operation may yield results that will not fit
         into the range supported by the column. In such case, the in-memory
         backend will replace such results with `Nothing` and report a
         `Arithmetic_Overflow` warning. The behaviour in Database backends is
         not specified and will depend on the particular database - it may
         cause a hard error, the value may be truncated or wrap-around etc.
    - : Column | Any -> Column
    - self other =
        case Value_Type_Helpers.resolve_subtraction_kind self other of
            Value_Type_Helpers.Subtraction_Kind.Numeric_Subtract ->
                self.make_binary_op "-" other
            Value_Type_Helpers.Subtraction_Kind.Date_Time_Difference ->
                Error.throw (Unsupported_Database_Operation.Error "Subtracting date/time values is not supported in this database.")

    ## ALIAS multiply, product, times
       GROUP Standard.Base.Operators
       Element-wise multiplication.

       Arguments:
       - other: The other column to multiply `self` by.

       Returns a column containing the result of multiplying `other` by each
       element of `self`.  If `other` is a column, the operation is performed
       pairwise between corresponding elements of `self` and `other`.

       ? Arithmetic Overflow

         For integer columns, the operation may yield results that will not fit
         into the range supported by the column. In such case, the in-memory
         backend will replace such results with `Nothing` and report a
         `Arithmetic_Overflow` warning. The behaviour in Database backends is
         not specified and will depend on the particular database - it may
         cause a hard error, the value may be truncated or wrap-around etc.
    * : Column | Any -> Column
    * self other =
        Value_Type_Helpers.check_binary_numeric_op self other <|
            self.make_binary_op "*" other

    ## ALIAS divide
       GROUP Standard.Base.Operators
       Element-wise division.

       Arguments:
       - other: The value to divide `self` by. If `other` is a column, the
         division is performed pairwise between corresponding elements of `self`
         and `other`.

       Returns a column containing the result of dividing each element of `self`
       by `other`.

       ! Warnings

         - If division by zero occurs, an `Arithmetic_Error` warning is attached
           to the result.

       ? Arithmetic Overflow

         For integer columns, the operation may yield results that will not fit
         into the range supported by the column. In such case, the in-memory
         backend will replace such results with `Nothing` and report a
         `Arithmetic_Overflow` warning. The behaviour in Database backends is
         not specified and will depend on the particular database - it may
         cause a hard error, the value may be truncated or wrap-around etc.

       > Example
         Divide the elements of one column by the elements of another.

             import Standard.Examples

             example_div = Examples.decimal_column / Examples.integer_column

       > Example
         Multiply each value in a column by a single value.

             import Standard.Examples

             example_div = Examples.integer_column / 10
    / : Column | Any -> Column
    / self other =
        Value_Type_Helpers.check_binary_numeric_op self other <|
            self.make_binary_op "/" other

    ## ALIAS modulo, modulus
       GROUP Standard.Base.Operators
       Element-wise modulus.

       Arguments:
       - other: The value to modulo `self` against. If `other` is a column, the
         modulus is performed pairwise between corresponding elements of `self`
         and `other`.

       Returns a column with results of modulus this column's elements against
       `other`.

       ! Warnings

         - If division by zero occurs, an `Arithmetic_Error` warning is attached
           to the result.

       > Example
         Modulus of two columns against each other.

             import Standard.Examples

             example_mod = Examples.integer_column % Examples.decimal_column

       > Example
         Modulus of a column with a number.

             import Standard.Examples

             example_mod = Examples.integer_column % 3
    % : Column | Any -> Column
    % self other =
        Value_Type_Helpers.check_binary_numeric_op self other <|
            other_type = Value_Type_Helpers.find_argument_type other
            # Different implementation may be used for integer types.
            op = if self.value_type.is_integer && (other_type.is_nothing || other_type.is_integer) then "%" else "mod"
            new_name = self.naming_helper.binary_operation_name "%" self other
            self.make_binary_op op other new_name

    ## ALIAS power
       GROUP Standard.Base.Operators
       Element-wise raising to the power.

       Arguments:
       - other: The exponent to raise `self` by. If `other` is a column, the
         power operation is performed pairwise between corresponding elements
         of `self` and `other`.

       Returns a column containing the result of raising each element of `self`
       by `other`.

       ? Arithmetic Overflow

         For integer columns, the operation may yield results that will not fit
         into the range supported by the column. In such case, the in-memory
         backend will replace such results with `Nothing` and report a
         `Arithmetic_Overflow` warning. The behaviour in Database backends is
         not specified and will depend on the particular database - it may
         cause a hard error, the value may be truncated or wrap-around etc.

       > Example
         Squares the elements of one column.

             import Standard.Examples

             example_div = Examples.decimal_column ^ 2

       > Example
         Raises each value in a column by the value in another column.

             import Standard.Examples

             example_div = Examples.decimal_column ^ Examples.integer_column
    ^ : Column | Any -> Column
    ^ self other =
        Value_Type_Helpers.check_binary_numeric_op self other <|
            self.make_binary_op '^' other

    ## ALIAS and
       GROUP Standard.Base.Operators
       Element-wise boolean conjunction.

       Arguments:
       - other: The other column to compute the conjunction with.

       Returns a column containing the result of performing the boolean `and` on
       `other` and each element of `self`.  If `other` is a column, the
       operation is performed pairwise between corresponding elements of `self`
       and `other`.
    && : Column | Any -> Column
    && self other =
        Value_Type_Helpers.check_binary_boolean_op self other <|
            new_name = self.naming_helper.binary_operation_name "&&" self other
            self.make_binary_op "AND" other new_name

    ## ALIAS or
       GROUP Standard.Base.Operators
       Element-wise boolean disjunction.

       Arguments:
       - other: The other column to compute the disjunction with.

       Returns a column containing the result of performing the boolean `or` on
       `other` and each element of `self`.  If `other` is a column, the
       operation is performed pairwise between corresponding elements of `self`
       and `other`.
    || : Column | Any -> Column
    || self other =
        Value_Type_Helpers.check_binary_boolean_op self other <|
            new_name = self.naming_helper.binary_operation_name "||" self other
            self.make_binary_op "OR" other new_name

    ## GROUP Standard.Base.Logical
       Boolean negation of each element in this column.
    not : Column
    not self =
        Value_Type.expect_boolean self <|
            new_name = self.naming_helper.concat ["not", self.naming_helper.to_expression_text self]
            self.make_unary_op "NOT" new_name

    ## ALIAS if
       GROUP Standard.Base.Logical

       Replaces `True` values with `when_true` and `False` with `when_false`.
       Only meant for use with boolean columns.

       Arguments:
       - when_true: value or column when `self` is `True`.
       - when_false: value or column when `self` is `False`.
    iif : Any -> Any -> Column
    iif self when_true when_false =
        Value_Type.expect_boolean self <|
            common_type = Value_Type_Helpers.find_common_type_for_arguments [when_true, when_false]
            common_type.if_not_error <|
                new_name = self.naming_helper.concat <|
                    ["if", self.naming_helper.to_expression_text self, "then", self.naming_helper.to_expression_text when_true, "else", self.naming_helper.to_expression_text when_false]
                op_result = self.make_op "IIF" [when_true, when_false] new_name
                adapt_unified_column op_result common_type

    ## PRIVATE

       Creates a column from a single constant value. The value must be of a
       type supported by the database back-end.

       This method is not static; it must be called on an existing column. That
       existing column is only used for its internal state; the contents of the
       column are not used.

       Arguments:
       - value: the constant value to use for the entire column. The value must
         be of a type supported by the database back-end.

       > Example
         Create a column of the value 42

         column.const 42
    const : Any -> Column
    const self value = self.to_table.make_constant_column value

    ## GROUP Standard.Base.Math
       Round to a specified number of decimal places.

       `round` is only valid for `Value_Type.Decimal`, `Value_Type.Float`, and
       `Value_Type.Integer` columns.

       By default, rounding uses "symmetric round-half-up", also known as
       "round towards 0." If use_bankers=True, then it uses "round-half-even",
       also known as "banker's rounding".

       The return type depends on the backend.

       Arguments:
       - decimal_places: The number of decimal places to round to. Can be
         negative, which results in rounding to positive integer powers of 10.
         Must be between -15 and 15 (inclusive).
       - use_bankers: Rounds mid-point to nearest even number.

       ! NaN/Inf
         If a `NaN` or `Inf` value is passed to `round`, it immediately returns
         the same value.

       ! Error Conditions

         If `decimal_places` is outside the range -15..15 (inclusive), an
         `Illegal_Argument` error is thrown.

       ? Negative decimal place counts
         Rounding to `n` digits can be thought of as "rounding to the nearest
         multiple of 10^(-n)". For negative decimal counts, this results in
         rounding to the nearest positive integer power of 10.

       > Example
         Round a column to two decimal places.

             import Standard.Examples

             example_round = Examples.decimal_column.round 2
    round : Integer -> Boolean -> Column | Illegal_Argument | Invalid_Value_Type
    round self (decimal_places:Integer = 0) (use_bankers:Boolean = False) =
        Rounding_Helpers.check_decimal_places decimal_places <| Value_Type.expect_numeric self <|
            if self.should_use_builtin_round decimal_places use_bankers then self.round_builtin decimal_places else
                self.short_circuit_special_floating_point <|
                    case self.value_type of
                        Value_Type.Integer _ -> self.round_integer decimal_places use_bankers
                        Value_Type.Float _ -> self.round_float decimal_places use_bankers
                        Value_Type.Decimal _ _ -> self.round_decimal decimal_places use_bankers
                        _ ->
                            expected = "Decimal, Float, or Integer"
                            Error.throw (Invalid_Value_Type.Column expected self.value_type self.name)

    ## PRIVATE
       Determine whether to use built-in rounding. We use built-in rounding if:
       - It's not banker's rounding, and
       - If decimal_places is negative, the builtin `ROUND` supports that, and
       - We are not passing a floating point value to round with a non-zero decimal_places param (prohibited by postgres)
         (Note that Postgres is fine with a `numeric` value here, just not `double precision`.)
    should_use_builtin_round : Integer -> Boolean -> Boolean
    should_use_builtin_round self decimal_places use_bankers =
        # Don't use for banker's rounding
        not_bankers = use_bankers.not
        # Don't use for negative decimal places, if the backend doesn't support it
        negative_dp_ok = decimal_places >= 0 || self.connection.dialect.supports_negative_round_decimal_places
        # Don't use for floating-point inputs if decimal_places != 0, for Postgres
        dp_param_ok = (self.connection.dialect.rounding_decimal_places_not_allowed_for_floats && self.value_type.is_floating_point && decimal_places != 0).not
        not_bankers && negative_dp_ok && dp_param_ok

    ## PRIVATE
       Round a float-like column using the backend's builtin ROUND function.
    round_builtin : Integer -> Column
    round_builtin self decimal_places =
        new_name = self.naming_helper.function_name "round" [self]
        case decimal_places == 0 of
            True ->
                self.make_unary_op "ROUND" new_name
            False ->
                self.make_binary_op "ROUND" (SQL_Expression.Literal decimal_places.to_text) new_name

    ## PRIVATE
       Round a float-like column.
    round_float : Integer -> Boolean -> Column
    round_float self decimal_places use_bankers =
        new_name = self.naming_helper.function_name "round" [self]
        scale = 10 ^ decimal_places
        scaled = self * scale
        round_base = scaled.floor . rename "rb"
        round_midpoint = (round_base + 0.5) / scale
        even_is_up = (self >= 0).iif ((scaled.truncate % 2) != 0) ((scaled.truncate % 2) == 0)
        half_goes_up = if use_bankers then even_is_up else self >= 0
        do_round_up = half_goes_up.iif (self >= round_midpoint) (self > round_midpoint)
        result = do_round_up.iif ((round_base + 1.0) / scale) (round_base / scale)
        result.rename new_name

    ## PRIVATE
       Round a float-like column.
    round_decimal : Integer -> Boolean -> Column
    round_decimal self decimal_places use_bankers =
        # Construct a constant Decimal column.
        k x = self.const x . cast Value_Type.Decimal
        new_name = self.naming_helper.function_name "round" [self]
        scale = k 10 ^ decimal_places
        scaled = self * scale
        round_base = scaled.floor . rename "rb"
        round_midpoint = (round_base + k 0.5).decimal_div scale
        even_is_up = (self >= k 0).iif ((scaled.truncate.decimal_mod (k 2)) != k 0) ((scaled.truncate.decimal_mod (k 2)) == k 0)
        half_goes_up = if use_bankers then even_is_up else self >= k 0
        do_round_up = half_goes_up.iif (self >= round_midpoint) (self > round_midpoint)
        result = do_round_up.iif ((round_base + k 1).decimal_div scale) (round_base.decimal_div scale)
        result.rename new_name

    ## PRIVATE
       Round an integer column.
    round_integer : Integer -> Boolean -> Column
    round_integer self decimal_places use_bankers =
        new_name = self.naming_helper.function_name "round" [self]
        scale = 10 ^ -decimal_places
        halfway = scale.div 2
        remainder = self % scale
        scaled_down = (self / scale).truncate . cast Value_Type.Integer
        result_unnudged = scaled_down * scale

        if_non_neg =
            half_goes_up = if use_bankers then (scaled_down % 2) != 0 else self >= 0
            round_up = half_goes_up.iif (remainder >= halfway) (remainder > halfway)
            round_up.iif (result_unnudged + scale) result_unnudged
        if_neg =
            half_goes_up = if use_bankers then (scaled_down % 2) == 0 else self >= 0
            round_up = half_goes_up.iif (remainder < -halfway) (remainder <= -halfway)
            round_up.iif (result_unnudged - scale) result_unnudged

        result = (self >= 0).iif if_non_neg if_neg
        result.cast Value_Type.Float . rename new_name

    ## ALIAS int
       GROUP Standard.Base.Rounding

       Truncate the floating-point values to an integer by dropping the
       fractional part. This is equivalent to "round-toward-zero".

       ! NaN/Inf
         If a `NaN` or `Inf` value is passed to `truncate`, it immediately returns
         the same value.

       > Example
         Truncate a column of floating-point values.

             import Standard.Examples

             example_truncate = Examples.decimal_column.truncate
    truncate : Column ! Invalid_Value_Type
    truncate self =
        new_name = self.naming_helper.function_name "truncate" [self]
        precise_value_type = self.inferred_precise_value_type
        case precise_value_type.is_numeric of
            True ->
                self.short_circuit_special_floating_point <|
                    self.make_unary_op "TRUNCATE" new_name
            False -> case precise_value_type == Value_Type.Date_Time of
                True ->
                    op = "date_trunc_to_day"
                    case self.connection.dialect.is_supported op of
                        True ->
                            self.make_unary_op op new_name
                        False ->
                            Error.throw (Unsupported_Database_Operation.Error ("`Column.truncate` for `Date_Time` is not supported by this connection."))
                False -> Error.throw <| Invalid_Value_Type.Column "Numeric or Date_Time" self.value_type self.name

    ## GROUP Standard.Base.Rounding
       Takes the ceiling of floating-point values, returning integer values.

       ! NaN/Inf
         If a `NaN` or `Inf` value is passed to `ceil`, it immediately returns
         the same value.

       > Example
         Take the ceiling of a column of floating-point values.

             import Standard.Examples

             example_ceil = Examples.decimal_column.ceil
    ceil : Column ! Invalid_Value_Type
    ceil self =
        Value_Type.expect_numeric self <| self.short_circuit_special_floating_point <|
            new_name = self.naming_helper.function_name "ceil" [self]
            self.make_unary_op "CEIL" new_name

    ## GROUP Standard.Base.Rounding
       Takes the floor of floating-point values, returning integer values.

       ! NaN/Inf
         If a `NaN` or `Inf` value is passed to `floor`, it immediately returns
         the same value.

       > Example
         Take the floor of a column of floating-point values.

             import Standard.Examples

             example_floor = Examples.decimal_column.floor
    floor : Column ! Invalid_Value_Type
    floor self =
        Value_Type.expect_numeric self <| self.short_circuit_special_floating_point <|
            new_name = self.naming_helper.function_name "floor" [self]
            self.make_unary_op "FLOOR" new_name

    ## PRIVATE
       `/` for decimals.
    decimal_div : Column -> Column ! Invalid_Value_Type
    decimal_div self other =
        Value_Type.expect_numeric self <| Value_Type.expect_numeric other <|
            new_name = self.naming_helper.function_name "decimal_div" [self, other]
            self.make_binary_op "DECIMAL_DIV" other new_name

    ## PRIVATE
       `mod` for decimals.
    decimal_mod : Column -> Column ! Invalid_Value_Type
    decimal_mod self other =
        Value_Type.expect_numeric self <| Value_Type.expect_numeric other <|
            new_name = self.naming_helper.function_name "decimal_mod" [self, other]
            self.make_binary_op "DECIMAL_MOD" other new_name

    ## GROUP Standard.Base.Logical
       ICON preparation
       Returns a column of first non-`Nothing` value on each row of `self` and
       `values` list.

       Arguments:
       - values: list of columns or values to coalesce with `self`.

       > Example
         Get the first non-`Nothing` value in two columns.

             import Standard.Examples

             example_coalesce = Examples.decimal_column.coalesce Examples.integer_column
    coalesce : (Any | Vector Any) -> Column
    coalesce self values =
        vec = Vector.unify_vector_or_element values
        args_with_self = [self]+vec
        common_type = Value_Type_Helpers.find_common_type_for_arguments args_with_self
        common_type.if_not_error <|
            new_name = self.naming_helper.function_name "coalesce" args_with_self
            op_result = self.make_op "COALESCE" vec new_name
            adapt_unified_column op_result common_type

    ## GROUP Standard.Base.Math
       Returns a column of minimum on each row of `self` and `values`.

       Arguments:
       - values: list of columns or values to minimum with `self`, or a single
         column or value.

       > Example
         Get the minimum value in two columns.

             import Standard.Examples

             example_min = Examples.decimal_column.min Examples.integer_column
    min : (Any | Vector Any) -> Column
    min self values =
        Value_Type_Helpers.check_multi_argument_comparable_op self values <|
            args = Vector.unify_vector_or_element values
            new_name = self.naming_helper.function_name "min" [self]+args
            self.make_op "ROW_MIN" args new_name

    ## GROUP Standard.Base.Math
       Returns a column of maximum on each row of `self` and `values`.

       Arguments:
       - values: list of columns or values to maximum with `self`, or a single
         column or value.

       > Example
         Get the maximum value in two columns.

             import Standard.Examples

             example_max = Examples.decimal_column.max Examples.integer_column
    max : (Any | Vector Any) -> Column
    max self values =
        Value_Type_Helpers.check_multi_argument_comparable_op self values <|
            args = Vector.unify_vector_or_element values
            new_name = self.naming_helper.function_name "max" [self]+args
            self.make_op "ROW_MAX" args new_name

    ## GROUP Standard.Base.Logical
       Returns a column of booleans, with `True` items at the positions where
       this column contains a `Nothing`.
    is_nothing : Column
    is_nothing self =
        new_name = self.naming_helper.concat [self.naming_helper.to_expression_text self, "is null"]
        self.make_unary_op "IS_NULL" new_name

    ## GROUP Standard.Base.Math
       Returns a column of booleans, with `True` items at the positions where
       this column contains a NaN. This is only applicable to double columns.
    is_nan : Column
    is_nan self = Value_Type.expect_numeric self <|
        new_name = self.naming_helper.function_name "is_nan" [self]
        self.make_unary_op "IS_NAN" new_name

    ## GROUP Standard.Base.Math
       Returns a column of booleans, with `True` items at the positions where
       this column contains a +Inf/-Inf. This is only applicable to double
       columns.
    is_infinite : Column
    is_infinite self = Value_Type.expect_numeric self <|
        new_name = self.naming_helper.function_name "is_infinite" [self]
        self.make_unary_op "IS_INF" new_name

    ## PRIVATE
       Returns a column of booleans, with `True` items at the positions where
       this column contains an empty string or `Nothing`.
    is_empty : Column
    is_empty self = Value_Type.expect_text self <|
        new_name = self.naming_helper.concat [self.naming_helper.to_expression_text self, "is empty"]
        self.make_unary_op "IS_EMPTY" new_name

    ## GROUP Standard.Base.Logical
       Returns a column of booleans, with `True` items at the positions where
       this column does not contain a `Nothing`.

       > Example
         Check a column for present values.

             import Standard.Examples

             example_is_present = Examples.decimal_column.is_present
    is_present : Column
    is_present self =
        new_name = self.naming_helper.function_name "is_present" [self]
        self.is_nothing.not . rename new_name

    ## PRIVATE
       Returns a column of booleans with `True` at the positions where this
       column contains a blank value.

       Arguments:
       - treat_nans_as_blank: If `True`, then `Number.nan` is considered as
         blank.

       ? Blank values
         Blank values are `Nothing`, `""` and depending on setting `Number.nan`.
    is_blank : Boolean -> Column
    is_blank self treat_nans_as_blank=False =
        new_name = self.naming_helper.function_name "is_blank" [self]
        self_type = self.value_type
        is_blank = case self_type.is_text of
            True -> self.is_empty
            False -> self.is_nothing
        result = case treat_nans_as_blank && self_type.is_floating_point && self.connection.dialect.supports_separate_nan of
            True -> is_blank || self.is_nan
            False -> is_blank
        result.rename new_name

    ## ALIAS fill missing, if_nothing
       GROUP Standard.Base.Values
       ICON dataframe_map_column

       Returns a new column where missing values have been replaced with the
       provided default.

       Arguments:
       - default: The value to replace missing values with. If this argument
         is a column, the value from `default` at the corresponding position
         will be used. If this argument is `Previous_Value`, the missing values
         will be replaced with the previous value in the column. Note that the
         first rows may stay `Nothing` if they do not have a previous value to
         use.

       > Example
         Fill missing values in a column with the value 20.5.

             import Standard.Examples

             example_fill_nothing = Examples.decimal_column.fill_nothing 20.5
    @default (Widget_Helpers.make_fill_default_value_selector include_custom_text=False)
    fill_nothing : Column | Previous_Value | Any -> Column
    fill_nothing self default =
        if Previous_Value == default then Error.throw (Unsupported_Database_Operation.Error "The Previous_Value argument is currently not supported in the database backend.") else
            common_type = Value_Type_Helpers.find_common_type_for_arguments [self, default]
            common_type.if_not_error <|
                op_result = self.make_binary_op "FILL_NULL" default self.name
                adapt_unified_column op_result common_type

    ## ALIAS fill empty, if_empty
       GROUP Standard.Base.Values
       ICON dataframe_map_column

       Returns a new column where empty Text values have been replaced with the
       provided default.

       Arguments:
       - default: The value to replace empty values with. If this argument
         is a column, the value from `default` at the corresponding position
         will be used. If this argument is `Previous_Value`, the empty values
         will be replaced with the previous value in the column. Note that the
         first rows may stay empty if they do not have a previous value to use.

       > Example
         Fill empty values in a column with the value "hello".

             import Standard.Examples

             example_fill_empty = Examples.text_column_1.fill_empty "hello"
    @default (Widget_Helpers.make_fill_default_value_selector include_custom_text=True)
    fill_empty : Column | Previous_Value | Any -> Column
    fill_empty self default =
        if Previous_Value == default then Error.throw (Unsupported_Database_Operation.Error "The Previous_Value argument is currently not supported in the database backend.") else
            Value_Type.expect_text self <| Value_Type.expect_text default <|
                result = self.is_empty.iif default self
                result.rename self.name

    ## GROUP Standard.Base.Metadata
       ICON text_input
       Returns a new column, containing the same elements as `self`, but with
       the given name.

       Arguments:
       - name: The new name for the column.

       > Example
         Rename a column.

             import Standard.Examples

             example_rename = Examples.integer_column.rename "My Numbers"
    rename : Text -> Column ! Illegal_Argument
    rename self name = self.naming_helper.ensure_name_is_valid name <|
        Column.Value name self.connection self.sql_type_reference self.expression self.context

    ## ALIAS order_by
       GROUP Standard.Base.Selections
       Sorts the column according to the specified rules.

       Arguments:
         - order: Specifies the default sort order for this operation.
         - missing_last: Specifies the default placement of missing values when
           compared to non-missing ones. Note that this argument is independent
           from `order`, i.e. missing values will always be sorted according to
           this rule, ignoring the ascending / descending setting.

       > Example
         Sorting `column` in ascending order.
             column.sort

       > Example
         Sorting `column` in descending order.
             column.sort Sort_Direction.Descending
    sort : Sort_Direction -> Column
    sort self order=Sort_Direction.Ascending =
        self.to_table.order_by [Sort_Column.Index 0 order] . at 0

    ## ALIAS first, last, sample, slice
       GROUP Standard.Base.Selections
       ICON select_row
       Creates a new Column with the specified range of rows from the input
       Column.

       Arguments:
       - range: The selection of rows from the table to return.
    @range Index_Sub_Range.default_widget
    take : (Index_Sub_Range | Range | Integer) -> Column
    take self range=(First 1) = self.to_table.take range . at 0

    ## GROUP Standard.Base.Selections
       ICON select_row
       Creates a new Column from the input with the specified range of rows
       removed.

       Arguments:
       - range: The selection of rows from the table to remove.
    @range Index_Sub_Range.default_widget
    drop : (Index_Sub_Range | Range | Integer) -> Column
    drop self range=(First 1) = self.to_table.drop range . at 0

    ## GROUP Standard.Base.Text
       ICON preparation
       Checks for each element of the column if it starts with `other`.

       Arguments:
       - other: A column or text to check for each item in `self`.
       - case_sensitivity: Specifies if the text values should be compared case
         sensitively.

       If `other` is a column, the operation is performed pairwise between
       corresponding elements of `self` and `other`.  If the argument is a
       missing value (a Nothing or a column with missing values), the behaviour
       on these missing values is vendor specific.
    starts_with : Column | Text -> Case_Sensitivity -> Column
    starts_with self other case_sensitivity=Case_Sensitivity.Default =
        new_name = self.naming_helper.function_name "starts_with" [self, other]
        make_text_case_op self "starts_with" other case_sensitivity new_name

    ## GROUP Standard.Base.Text
       ICON preparation
       Checks for each element of the column if it ends with `other`.

       Arguments:
       - other: A column ot text to check for each item in `self`.
       - case_sensitivity: Specifies if the text values should be compared case
         sensitively.

       If `other` is a column, the operation is performed pairwise between
       corresponding elements of `self` and `other`.  If the argument is a
       missing value (a Nothing or a column with missing values), the behaviour
       on these missing values is vendor specific.
    ends_with : Column | Text -> Case_Sensitivity -> Column
    ends_with self other case_sensitivity=Case_Sensitivity.Default =
        new_name = self.naming_helper.function_name "ends_with" [self, other]
        make_text_case_op self "ends_with" other case_sensitivity new_name

    ## GROUP Standard.Base.Text
       ICON preparation
       Calculates the text length for each element of the column.

       In the Database backends, the default text length method of the
       particular database is used.

       In the in-memory backend, this will give you the grapheme length of the string.

       > Example
             import Standard.Examples

             example_text_length =
                Examples.text_column_1.text_length
    text_length : Column
    text_length self =
        Value_Type.expect_text self <|
            new_name = self.naming_helper.function_name "text_length" [self]
            self.make_unary_op "LENGTH" new_name

    ## GROUP Standard.Base.Logical
       Checks for each element of the column if it contains `other`.

       Arguments:
       - other: A column ot text to check for each item in `self`.
       - case_sensitivity: Specifies if the text values should be compared case
         sensitively.

       If `other` is a column, the operation is performed pairwise between
       corresponding elements of `self` and `other`.  If the argument is a
       missing value (a Nothing or a column with missing values), the behaviour
       on these missing values is vendor specific.
    contains : Column | Text -> Case_Sensitivity -> Column
    contains self other case_sensitivity=Case_Sensitivity.Default =
        new_name = self.naming_helper.function_name "contains" [self, other]
        make_text_case_op self "contains" other case_sensitivity new_name

    ## GROUP Standard.Base.Logical
       Checks for each element of the column if it matches an SQL-like pattern.

       Arguments:
       - pattern: The pattern to match `self` against. If it is a column, the
         operation is performed pairwise between corresponding elements of
         `self` and that column. The pattern is an SQL-like pattern, where
         `%` matches any sequence of characters and `_` matches any single
         character.

       > Example
         Check if elements of a column start with 'F' and end with a dot.

             import Standard.Examples

             example_contains = Examples.text_column_1.like "F%."
    like : Column | Text -> Column
    like self pattern =
        Value_Type.expect_text self <|
            Value_Type.expect_text pattern <|
                new_name = self.naming_helper.binary_operation_name "like" self pattern
                self.make_binary_op "LIKE" pattern new_name

    ## GROUP Standard.Base.Text
       ICON dataframe_map_column
       This function removes the specified characters, by default any
       whitespace, from the start, the end, or both ends of the input.

       Arguments:
       - where: The location of where to trim the input. By default, this
         function trims both ends of the input.
       - what: A `Text` (or text `Column`) containing characters that should be
         removed. By default, spaces, tabs, returns and new lines are removed.
    trim : Location -> Column | Text -> Column
    trim self where=Location.Both what='' =
        Value_Type.expect_text self <|
            Value_Type.expect_text what <|
                new_name = self.naming_helper.function_name "trim" [self]
                operator = case where of
                    Location.Both -> "TRIM"
                    Location.Start -> "LTRIM"
                    Location.End -> "RTRIM"
                if self.connection.dialect.is_supported operator then self.make_binary_op operator what new_name else
                    Error.throw (Unsupported_Database_Operation.Error ("`Column.trim "+where.to_text+"` is not supported by this connection."))

    ## GROUP Standard.Base.Text
       ICON dataframe_map_column
       Replaces the first, or all occurrences of `term` with `new_text` in each
       row. If `term` is empty, the function returns the table unchanged.

       This method follows the exact replacement semantics of the
       `Text.replace` method.

       Arguments:
       - term: The term to find.
       - replacement: The text to replace matches with.
       - case_sensitivity: Specifies if the text values should be compared case
         sensitively.
       - only_first: If True, only replace the first match.

       ! Backend Support

         Each database backend supports different combinations of options:

         Text:
         +----------------+------------+----------+--------+
         | case_sensitive | only_first | postgres | sqlite |
         +----------------+------------+----------+--------+
         |       t        |      f     |     ✓    |    ✓   |
         |       t        |      t     |     ✓    |    ✓   |
         |       f        |      f     |     ✓    |    ✗   |
         |       f        |      t     |     ✓    |    ✓   |
         +----------------+------------+----------+--------+

         Regex:
         +----------------+------------+----------+--------+
         | case_sensitive | only_first | postgres | sqlite |
         +----------------+------------+----------+--------+
         |       t        |      f     |     ✓    |    ✗   |
         |       t        |      t     |     ✓    |    ✗   |
         |       f        |      f     |     ✓    |    ✗   |
         |       f        |      t     |     ✓    |    ✗   |
         +----------------+------------+----------+--------+

         Text Column:
         +----------------+------------+----------+--------+
         | case_sensitive | only_first | postgres | sqlite |
         +----------------+------------+----------+--------+
         |       t        |      f     |     ✓    |    ✓   |
         |       t        |      t     |     ✗    |    ✓   |
         |       f        |      f     |     ✗    |    ✗   |
         |       f        |      t     |     ✗    |    ✓   |
         +----------------+------------+----------+--------+

       > Example
         Replace dashes with underscores.

             column.replace "-" "_"

       > Example
         Remove leading and trailing spaces from cells.

             column.replace "^\s*(.*?)\s*$".to_regex "$1"

       > Example
         Replace texts in quotes with parentheses.

             column.replace '"(.*?)"'.to_regex '($1)'
    @term make_regex_text_widget
    replace : Text | Regex | Column -> Text | Column -> Case_Sensitivity -> Boolean -> Column ! Unsupported_Database_Operation
    replace self term="" new_text="" case_sensitivity=Case_Sensitivity.Default only_first=False =
        Value_Type.expect_text self <| case_sensitivity.disallow_non_default_locale <|
            input_type = Meta.type_of term
            params = Replace_Params.Value input_type case_sensitivity only_first
            self.connection.dialect.if_replace_params_supports params <|
                raw_term = case term of
                    _ : Regex -> term.pattern_string
                    _ -> term
                new_name = self.naming_helper.function_name "replace" [self, raw_term, new_text]
                self.make_op "REPLACE" [raw_term, new_text] new_name [term, params]

    ## GROUP Standard.Base.DateTime
       Gets the year as a number from the date stored in the column.

       Applies only to columns that hold the `Date` or `Date_Time` types.
       Returns a column of `Integer` type.
    year : Column ! Invalid_Value_Type
    year self = Value_Type.expect_has_date self <|
        simple_unary_op self "year"

    ## GROUP Standard.Base.DateTime
       Gets the month as a number (1-12) from the date stored in the column.

       Applies only to columns that hold the `Date` or `Date_Time` types.
       Returns a column of `Integer` type.
    month : Column ! Invalid_Value_Type
    month self = Value_Type.expect_has_date self <|
        simple_unary_op self "month"

    ## GROUP Standard.Base.DateTime
       Gets the day of the month as a number (1-31) from the date stored in the
       column.

       Applies only to columns that hold the `Date` or `Date_Time` types.
       Returns a column of `Integer` type.
    day : Column ! Invalid_Value_Type
    day self = Value_Type.expect_has_date self <|
        simple_unary_op self "day"

    ## GROUP Standard.Base.DateTime
       Gets the hour as a number (0-23) from the time stored in the column.

       Applies only to columns that hold the `Time_Of_Day` or `Date_Time` types.
       Returns a column of `Integer` type.
    hour : Column ! Invalid_Value_Type
    hour self = Value_Type.expect_has_time self <|
        simple_unary_op self "hour"

    ## GROUP Standard.Base.DateTime
       Gets the minute as a number (0-59) from the time stored in the column.

       Applies only to columns that hold the `Time_Of_Day` or `Date_Time` types.
       Returns a column of `Integer` type.
    minute : Column ! Invalid_Value_Type
    minute self = Value_Type.expect_has_time self <|
        simple_unary_op self "minute"

    ## GROUP Standard.Base.Selections
       ICON select_row
       Gets the second as an integer (0-60) from the time stored in the column.

       Applies only to columns that hold the `Time_Of_Day` or `Date_Time` types.
       Returns a column of `Integer` type.
    second : Column ! Invalid_Value_Type
    second self = Value_Type.expect_has_time self <|
        simple_unary_op self "second"

    ## GROUP Standard.Base.DateTime
       Gets the date part of the date/time value.

       Returns a column of `Integer` type.
    @period Date_Time_Helpers.make_period_selector_for_column
    date_part : Date_Period | Time_Period -> Column ! Invalid_Value_Type | Illegal_Argument
    date_part self period =
        Date_Time_Helpers.make_date_part_function self period simple_unary_op self.naming_helper

    ## GROUP Standard.Base.DateTime
       Computes a time difference between the two dates.

       It returns a column of integers expressing how many periods fit between
       the two dates/times.

       The difference will be positive if `end` is greater than `self`.

       Arguments:
       - end: A date/time column or a date/time value to compute the difference
         from. It should have the same type as the current column, i.e. a
         `Date_Time` column cannot be compared to a `Date` - to do so you first
         need to `cast`.
       - period: The period to compute the difference in. For `Date` columns it
         should be a `Date_Period` and for `Time` columns it should be a
         `Time_Period`. For `Date_Time` columns it can be either.

       ? Time Zone handling

         Some backends may not preserve the timezone data in a `Date_Time`
         (preserving the represented time instant). This may lead to slight
         differences in time calculations between backends, especially around
         unusual events like DST.
    @period Date_Time_Helpers.make_period_selector_for_column
    date_diff : (Column | Date | Date_Time | Time_Of_Day) -> Date_Period | Time_Period -> Column ! Invalid_Value_Type | Illegal_Argument
    date_diff self end (period : Date_Period | Time_Period) =
        Value_Type.expect_type self .is_date_or_time "date/time" <|
            my_type = self.inferred_precise_value_type
            Value_Type.expect_type end (== my_type) my_type.to_display_text <|
                Date_Time_Helpers.check_period_aligned_with_value_type my_type period <|
                    new_name = self.naming_helper.function_name "date_diff" [self, end, period.to_display_text]
                    metadata = self.connection.dialect.prepare_metadata_for_period period my_type
                    self.make_op "date_diff" [end] new_name metadata

    ## GROUP Standard.Base.DateTime
       Shifts the date/time by a specified period, returning a new date/time
       column of the same type.

       Arguments:
       - amount: An integer or integer column specifying by how many periods to
         shift each date.
       - period: The period by which to shift. For `Date` columns it should be a
         `Date_Period` and for `Time` columns it should be a `Time_Period`. For
         `Date_Time` columns it can be either. It defaults to `Day` where
         possible and `Hour` for `Time` columns.

       ? Time Zone handling

         Some backends may not preserve the timezone data in a `Date_Time`
         (preserving the represented time instant). This may lead to slight
         differences in time calculations between backends, especially around
         unusual events like DST.
    @period Date_Time_Helpers.make_period_selector_for_column
    date_add : (Column | Integer) -> Date_Period | Time_Period -> Column ! Invalid_Value_Type | Illegal_Argument
    date_add self amount (period : Date_Period | Time_Period = default_date_period self) =
        Value_Type.expect_type self .is_date_or_time "date/time" <|
            my_type = self.inferred_precise_value_type
            Value_Type.expect_integer amount <|
                Date_Time_Helpers.check_period_aligned_with_value_type my_type period <|
                    new_name = self.naming_helper.function_name "date_add" [self, amount, period.to_display_text]
                    metadata = self.connection.dialect.prepare_metadata_for_period period my_type
                    self.make_op "date_add" [amount] new_name metadata

    ## GROUP Standard.Base.Logical
       Checks for each element of the column if it is contained within the
       provided vector or column.

       Arguments:
       - vector: A vector of elements or another column. The resulting column
         will contain true at the positions where the corresponding element of
         `self` is contained in `vector`.

       > Example
         Check if elements of a column are contained in a provided vector.

             import Standard.Examples

             example_contains = Examples.text_column_1.is_in [1, 2, 5]
    is_in : Column | Vector -> Column
    is_in self vector =
        new_name = self.naming_helper.binary_operation_name "in" self vector
        case vector of
            _ : Vector ->
                ## This is slightly hacky - we don't provide operand types as we want to
                   allow any type to get through and currently we do not have a mapping
                   from Enso types to SQL types (it may be available in the future). So
                   we just rely on Nothing resolving to the current column type. That
                   type may not always match the operands, but the current
                   implementation uses this type only for two purposes: generated SQL
                   visualization (so the color will be consistent with the column type
                   and not the value type - that can be confusing, we probably want to
                   fix it later) and setting up the query - but at the set up this only
                   applies to adding nulls - setting any other object does not check the
                   type at this level anyway.
                partitioned = vector.partition .is_nothing
                nulls = partitioned.first
                non_nulls = partitioned.second
                ## Since SQL `NULL IN (NULL)` yields `NULL`, we need to handle this case
                   separately. So we handle all non-null values using `IS_IN` and then
                   `OR` that with a null check (if the vector contained any nulls to
                   begin with). The implementation also ensures that even
                   `NULL IN (...)` is coalesced to False, so that negation works as
                   expected.
                is_in_not_null = self.make_op "IS_IN" operands=non_nulls new_name=new_name
                result = case nulls.not_empty of
                    True -> is_in_not_null || self.is_nothing
                    False -> is_in_not_null
                result.rename new_name
            _ : Array -> self.is_in (Vector.from_polyglot_array vector)
            column : Column -> if Helpers.check_connection self column . not then (Error.throw (Integrity_Error.Error "Column "+column.name)) else
                ## We slightly abuse the expression syntax putting a Query as one of
                   the sub-expressions. Once type-checking is added, we may need to
                   amend the signature of `SQL_Expression.Operation` to account for
                   this. Also, unfortunately as `NULL IN (...)` is `NULL` in SQL, we
                   need to do separate handling of nulls - we check if the target
                   column has any nulls and if so, we will do `IS NULL` checks for
                   our columns too. That is because, we want the containment check
                   for `NULL` to work the same way as for any other value.
                in_subquery = Query.Select [Pair.new column.name column.expression] column.context
                has_nulls_expression = SQL_Expression.Operation "BOOL_OR" [column.is_nothing.expression]
                has_nulls_subquery = Query.Select [Pair.new "has_nulls" has_nulls_expression] column.context
                new_expr = SQL_Expression.Operation "IS_IN_COLUMN" [self.expression, in_subquery, has_nulls_subquery]
                # This mapping should never be imprecise, if there are errors we need to amend the implementation.
                sql_type = self.connection.dialect.get_type_mapping.value_type_to_sql Value_Type.Boolean Problem_Behavior.Report_Error
                new_type_ref = SQL_Type_Reference.from_constant sql_type . catch Inexact_Type_Coercion _->
                    Error.throw (Illegal_State.Error "The dialect "+self.connection.dialect.name+" does not support a boolean type. The implementation of `is_in` should be revised to account for this. This is an internal issue with the Database library.")
                Column.Value new_name self.connection new_type_ref new_expr self.context

    ## GROUP Standard.Base.Conversions
       ICON convert
       Parses a text column into values.

       In the Database backends, the default formatting settings of the
       particular database are used.

       In the in-memory backend, the default parser options only parse values
       where the process is reversible (e.g., 0123 would not be converted to an
       integer as there is a leading 0). However, settings in the
       `Data_Formatter` can control this.

       Arguments:
       - type: The type to parse the column to. Defaults to `Auto` meaning that
         the type will be inferred from the data. In the Database backends,
         `Auto` is not supported, so a specific type must be selected.
       - format: The formatting settings to use when parsing the column.
         For `Date`, `Time_Of_Day` and `Date_Time`, a Java date time style
         can be used. For `Boolean`, it should be two values that represent true
         and false, separated by a `|`. Alternatively, a `Data_Formatter` can be
         passed to provide complete customisation of the formatting. If
         `Nothing` is provided, the default formatting settings of the backend
         will be used. `Nothing` is currently the only setting accepted by the
         Database backends.
       - on_problems: Specifies how to handle if a problem occurs, raising as a
         warning by default.

       ! Error Conditions

         - If the column is not a text column, an `Invalid_Value_Type` error is
           raised.
         - If some values in the column did not match the expected datatype
           format, an `Invalid_Format` problem is reported. The problematic
           cells are replaced with `Nothing`.
         - If custom formatting settings were provided, but the database backend
           does not support customization, an `Unsupported_Database_Operation`
           error is reported.
    @type (Widget_Helpers.parse_type_selector include_auto=False)
    parse : Value_Type | Auto -> Text | Data_Formatter | Nothing -> Problem_Behavior -> Column
    parse self type format=Nothing on_problems=Report_Warning =
        check_parameters =
            if type == Auto then Error.throw (Unsupported_Database_Operation.Error "The `Auto` parse type is not supported by the Database backend. Either pick a specific type or materialize the table to memory using `.read`.") else
                case format of
                    Nothing -> Nothing
                    _ -> Error.throw (Unsupported_Database_Operation.Error "Custom formatting is not supported by the Database backend. Please set the format to `Nothing` to indicate that the default Database settings can be used, or if custom formatting is needed, materialize the table to memory using `.read` first.")
        check_parameters.if_not_error <|
            Value_Type.expect_text self <|
                ## In the future we may have some specific logic, for example
                   allowing to support formatting settings. For now, the
                   Database parse just boils down to a simple CAST.
                self.internal_do_cast type on_problems

    ## GROUP Standard.Base.Conversions
       ICON convert
       Formatting values is not supported in database columns.
    @locale Locale.default_widget
    format : Text | Date_Time_Formatter | Column | Nothing -> Locale -> Column ! Illegal_Argument
    format self format:(Text | Date_Time_Formatter | Column | Nothing)=Nothing locale=Locale.default =
        _ = [format, locale]
        Error.throw <| Unsupported_Database_Operation.Error "`Column.format` is not implemented yet for the Database backends."

    ## GROUP Standard.Base.Conversions
       ICON convert
       Cast the column to a specific type.

       Arguments:
       - value_type: The `Value_Type` to cast the column to.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

       In the Database backend, this will boil down to a CAST operation.
       In the in-memory backend, a conversion will be performed according to
       the following rules:
       - Anything can be cast into the `Mixed` type.
       - Converting to a `Char` type, the elements of the column will be
         converted to text. If it is fixed length, the texts will be trimmed or
         padded on the right with the space character to match the desired
         length.
       - Conversion between numeric types will replace values exceeding the
         range of the target type with `Nothing`.
       - Converting decimal numbers into integers will truncate or round them,
         depending on the backend. If more control is needed, use the various
         rounding functions (such as `round` or `floor`).
       - Booleans may also be converted to numbers, with `True` being converted
         to `1` and `False` to `0`. The reverse is not supported - use `iif`
         instead.
       - A `Date_Time` may be converted into a `Date` or `Time` type - the
         resulting value will be truncated to the desired type.
       - If a `Date` is to be converted to `Date_Time`, it will be set at
         midnight of the default system timezone.
       - For a `Mixed` column being converted into a specific type, each row is
         converted individually.

        If the target type cannot fit some of the values (for example due to too
        small range), a `Conversion_Failure` may be reported according to the
        `on_problems` rules. The Database backends may fail with `SQL_Error`
        instead.

       ? Inexact Target Type

         If the backend does not support the requested target type, the closest
         supported type is chosen and a `Inexact_Type_Coercion` problem is
         reported.

       ! Casting Text values

         The `parse` method should be used to convert text values into other
         types. Due to this, a Mixed column containing values `[2, "3"]` will
         actually be converted into `[2, Nothing]` when casting to Integer type.
    cast : Value_Type -> Problem_Behavior -> Column ! Illegal_Argument | Inexact_Type_Coercion | Conversion_Failure
    cast self value_type on_problems=Problem_Behavior.Report_Warning =
        check_cast_compatibility self.value_type value_type <|
            self.internal_do_cast value_type on_problems

    ## GROUP Standard.Base.Conversions
       Change the value type of the column to a more specific one, based on its
       contents.

       This operation is currently not available in the Database backend.
    auto_value_type : Boolean -> Column
    auto_value_type self shrink_types=False =
        _ = shrink_types
        Error.throw <| Unsupported_Database_Operation.Error "`Column.auto_value_type` is not supported in the Database backends."

    ## PRIVATE
       Shares the core CAST logic between `cast` and `parse`.
    internal_do_cast : Value_Type -> Problem_Behavior -> Column
    internal_do_cast self value_type on_problems =
        dialect = self.connection.dialect
        type_mapping = dialect.get_type_mapping
        target_sql_type = type_mapping.value_type_to_sql value_type on_problems
        target_sql_type.if_not_error <|
            infer_from_database new_expression =
                SQL_Type_Reference.new self.connection self.context new_expression
            new_column = dialect.make_cast self.as_internal target_sql_type infer_from_database
            Column.Value new_column.name self.connection new_column.sql_type_reference new_column.expression self.context

    ## ALIAS transform column
       ICON dataframe_map_column

       Applies `function` to each item in this column and returns the column
       of results.

       Arguments:
       - function: The function to apply to each element of `self` column.
       - skip_nothing: If `True`, `Nothing` values will be skipped. Otherwise,
         `Nothing` values will be passed to the `function`.
       - expected_value_type: The expected value type of the resulting column.
         If `Auto`, the value type will be inferred from the values returned by
         `function`.

       ! Error Conditions

         - If any of the values returned by `function` do not fit the expected
           value type, an `Invalid_Value_Type` error is raised.
         - If the `function` raises a dataflow error on any row, the first such
           error is propagated.
         - If an invocation of the `function` returns a value with warnings,
           these warnings are attached to the overall result.

       > Example
         Multiply each element of the column by itself.

             import Standard.Examples

             example_map = Examples.integer_column.map (x -> x * x)
    map : (Any -> Any) -> Boolean -> Value_Type | Auto -> Column ! Invalid_Value_Type
    map self function skip_nothing=True expected_value_type=Auto =
        _ = [function, skip_nothing, expected_value_type]
        Error.throw <| Unsupported_Database_Operation.Error "`Column.map` is not supported in the Database backends."

    ## ALIAS combine, join by row position, merge
       ICON dataframes_join

       Applies `function` to consecutive pairs of elements of `self` and `that`
       and returns a column of results.

       Arguments:
       - that: The column to zip with `self`.
       - function: A binary function that is applied to corresponding pairs of
         elements of `self` and `that` to produce a value.
       - skip_nothing: controls whether missing values should be passed to the
         `function`. The default value of `True` will skip the rows for which
         the value in either column is missing and automatically append
         `Nothing` to the result table. If set to `False`, every pair of values
         is passed to `function`.
       - expected_value_type: The expected value type of the resulting column.
         If `Auto`, the value type will be inferred from the values returned by
         `function`.

       ! Error Conditions

         - If any of the values returned by `function` do not fit the expected
           value type, an `Invalid_Value_Type` error is raised.
         - If the `function` raises a dataflow error on any row, the first such
           error is propagated.
         - If an invocation of the `function` returns a value with warnings,
           these warnings are attached to the overall result.

       > Example
         Zip two columns together as pairs.

             import Standard.Examples

             example_zip =
                Examples.integer_column.zip Examples.text_column_1 [_, _]
    zip : Column -> (Any -> Any -> Any) -> Boolean -> Value_Type | Auto -> Column ! Invalid_Value_Type
    zip self that:Column function skip_nothing=True expected_value_type=Auto =
        _ = [that, function, skip_nothing, expected_value_type]
        Error.throw <| Unsupported_Database_Operation.Error "`Column.zip` is not supported in the Database backends."

    ## PRIVATE
    as_internal : Internal_Column
    as_internal self = Internal_Column.Value self.name self.sql_type_reference self.expression

    ## PRIVATE
       Provides a simplified text representation for display in the REPL and errors.
    to_text : Text
    to_text self = "(Database Column "+self.name.to_text+")"

    ## PRIVATE
    sql_type : SQL_Type
    sql_type self = self.sql_type_reference.get

    ## PRIVATE
    naming_helper : Column_Naming_Helper
    naming_helper self = self.connection.base_connection.column_naming_helper

    ## PRIVATE
       Helper for the expression to tell it which functions needs a Vector.
    var_args_functions : Array
    var_args_functions = ['is_in', 'coalesce', 'min', 'max']

    ## PRIVATE
       If the column is NaN/Inf, return it immediately as the value; otherwise
       return the expression. If returning immediately, rename to the expression's
       name. If the column is not floating point, just return the expression.
    short_circuit_special_floating_point : Column -> Column
    short_circuit_special_floating_point self exp =
        self_is_nan = if self.connection.dialect.supports_separate_nan then self.is_nan else self.is_nothing
        if self.value_type.is_floating_point.not then exp else
            ((self_is_nan || self.is_infinite).iif self exp).rename exp.name
## PRIVATE
   Helper for case case_sensitivity based text operations
make_text_case_op left op other case_sensitivity new_name =
    result = Value_Type.expect_text left <| Value_Type.expect_text other <| case case_sensitivity of
        Case_Sensitivity.Default -> left.make_binary_op op other
        Case_Sensitivity.Sensitive ->
            make_sensitive column =
                column.make_unary_op "MAKE_CASE_SENSITIVE" "MAKE_CASE_SENSITIVE"
            cs_other = if other.is_a Column then make_sensitive other else other
            (make_sensitive left) . make_binary_op op cs_other
        Case_Sensitivity.Insensitive locale -> Helpers.assume_default_locale locale <|
            fold_case column =
                column.make_unary_op "FOLD_CASE" "FOLD_CASE"
            ci_other = if other.is_a Column then fold_case other else other.to_case Case.Lower
            (fold_case left) . make_binary_op op ci_other
    result.rename new_name

## PRIVATE
make_equality_check_with_floating_point_handling column other op =
    other_name = case other of
        other_column : Column -> "["+other_column.name+"]"
        _ -> other.to_text
    location = "["+column.name+"] "+op+" "+other_name
    Java_Problems.with_map_operation_problem_aggregator location Problem_Behavior.Report_Warning problem_builder->
        if column.value_type.is_floating_point then
            problem_builder.reportFloatingPointEquality -1
        case other of
            other_column : Column ->
                if other_column.value_type.is_floating_point then
                    problem_builder.reportFloatingPointEquality -1
            _ : Float ->
                problem_builder.reportFloatingPointEquality -1
            _ -> Nothing
        column.make_binary_op op other

## PRIVATE
adapt_unified_column : Column -> Value_Type -> Column
adapt_unified_column column expected_type =
    dialect = column.connection.dialect
    infer_return_type expression =
        SQL_Type_Reference.new column.connection column.context expression
    adapted = dialect.adapt_unified_column column.as_internal expected_type infer_return_type
    Column.Value name=column.name connection=column.connection sql_type_reference=adapted.sql_type_reference expression=adapted.expression context=column.context

## PRIVATE
   A shorthand to be able to share the implementations between in-memory and
   database.
simple_unary_op column op_kind = column.make_unary_op op_kind

## PRIVATE
Materialized_Column.from (that:Column) =
    _ = [that]
    Error.throw (Illegal_Argument.Error "Currently cross-backend operations are not supported. Materialize the column using `.read` before mixing it with an in-memory Table.")

## PRIVATE
   Conversion method to a Column to a Vector.
Vector.from (that:Column) =
    _ = [that]
    Error.throw (Illegal_Argument.Error "To convert from a Database column to a vector you must first call `read` on the column.")
