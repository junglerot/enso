from Standard.Base import all

from project import Test
from project.Extensions import all

## Returns values of warnings attached to the value.
get_attached_warnings v =
    Warning.get_all v . map .value

## UNSTABLE
   Tests how a specific operation behaves depending on the requested
   `Problem_Behavior`.

   Arguments:
   - action: The action to execute. It takes a `Problem_Behavior` which
     specifies whether it should ignore problems, report them as warnings or
     raise a dataflow error on the first encountered problem.
   - expected_problems: a list of expected problems, in the order that they are
     expected to be reported. It should not be empty. The problems are assumed
     to be Atoms.
   - result_checker: A function which should verify that the result generated by
     the action is correct. It does not return anything, instead it should use
     the standard testing approach, like `x.should_equal y`.
   - unwrap_errors: If true, remove any wrapping errors from errors and warnings
     before checking them.
test_problem_handling : (Problem_Behavior -> Any) -> Vector Any -> (Any -> Nothing) -> Boolean -> Nothing
test_problem_handling action expected_problems result_checker unwrap_errors=True =
    unwrap_maybe error = if unwrap_errors then Error.unwrap error else error

    error_checker error_result =
        first_problem = expected_problems.first
        first_problem_type = Meta.type_of first_problem
        error_result . should_fail_with first_problem_type unwrap_errors=unwrap_errors frames_to_skip=3
        (unwrap_maybe error_result.catch) . should_equal first_problem frames_to_skip=3
    warnings_checker warnings =
        ## TODO [RW] we are not checking if there are no duplicate warnings, because the warnings are in fact duplicated - we should figure out how to handle that and then possibly modify the test
        Test.with_clue "The warnings were "+warnings.to_text+'.\n' <|
            warnings . map unwrap_maybe . should_contain_the_same_elements_as expected_problems frames_to_skip=5
    test_advanced_problem_handling action error_checker warnings_checker result_checker frames_to_skip=1

## UNSTABLE
   Tests how a specific operation behaves depending on the requested
   `Problem_Behavior`. A variant that allows more customization over how
   expected problems are checked.

   Arguments:
   - action: The action to execute. It takes a `Problem_Behavior` which
     specifies whether it should ignore problems, report them as warnings or
     raise a dataflow error on the first encountered problem.
   - error_checker: A function which should verify that the returned error is as
     expected.
   - warnings_checker: A function which should verify that the returned warnings
     are as expected.
   - result_checker: A function which should verify that the result generated by
     the action is correct. It does not return anything, instead it should use
     the standard testing approach, like `x.should_equal y`.
test_advanced_problem_handling : (Problem_Behavior -> Any) -> (Any -> Nothing) -> (Vector Any -> Nothing) -> (Any -> Nothing) -> Integer -> Nothing
test_advanced_problem_handling action error_checker warnings_checker result_checker frames_to_skip=0 =
    # First, we check the action ignoring any warnings.
    result_ignoring = action Problem_Behavior.Ignore
    result_checker result_ignoring
    get_attached_warnings result_ignoring . should_equal [] frames_to_skip=frames_to_skip+1

    # Then, we check the fail-on-first-error mode.
    error_result = action Problem_Behavior.Report_Error
    error_checker error_result

    # Lastly, we check the report warnings mode and ensure that both the result is correct and the warnings are as expected.
    result_warning = action Problem_Behavior.Report_Warning
    result_checker result_warning
    warnings_checker (get_attached_warnings result_warning)

## UNSTABLE
   Checks if the provided value does not have any attached problems.
assume_no_problems result =
    loc = Meta.get_source_location 1
    if result.is_error then
        Test.fail "Expected the result to not be an error, but a dataflow error has been matched: "+result.catch.to_display_text+" (at "+loc+")."
    warnings = get_attached_warnings result
    if warnings.not_empty then
        Test.fail "Expected the result to not contain any warnings, but it did: "+warnings.to_text+" (at "+loc+")."

## UNSTABLE
   Checks if the provided value has a specific warning attached.
   It allows other warnings to be present also.

   Arguments:
   - expected_warning: The expected warning. It can either by a warning type or
     a concrete value.
   - result: The value to check.
   - unwrap_errors: If true, remove any wrapping errors from the result before
     checking against the expected warning.
expect_warning : Any -> Any -> Boolean -> Nothing
expect_warning expected_warning result unwrap_errors=True =
    unwrap_maybe error = if unwrap_errors then Error.unwrap error else error
    loc = Meta.get_source_location 1
    if result.is_error then
        Test.fail "Expected a warning "+expected_warning.to_text+", but a dataflow error has been matched: "+result.catch.to_display_text+" (at "+loc+")."
    warnings = get_attached_warnings result . map unwrap_maybe
    found = warnings.find if_missing=Nothing x->
        (x == expected_warning) || (x.is_a expected_warning)
    found.if_nothing <|
        Test.fail "Expected the result to contain a warning: "+expected_warning.to_text+", but it did not. The warnings were "+warnings.short_display_text+' (at '+loc+').'

## UNSTABLE
   Checks if the provided value has a specific warning attached and if there are
   no other warnings.

   As a utility, it also returns the found warning.

   Arguments:
   - expected_warning: The expected warning. It can either by a warning type or
     a concrete value.
   - result: The value to check.
   - unwrap_errors: If true, remove any wrapping errors from the result before
     checking against the expected warning.
expect_only_warning : Any -> Any -> Boolean -> Any
expect_only_warning expected_warning result unwrap_errors=True =
    unwrap_maybe error = if unwrap_errors then Error.unwrap error else error
    loc = Meta.get_source_location 1
    if result.is_error then
        Test.fail "Expected only warning "+expected_warning.to_text+", but a dataflow error has been matched: "+result.catch.to_display_text+" (at "+loc+")."
    warnings = get_attached_warnings result . map unwrap_maybe
    is_expected x =
        (x == expected_warning) || (x.is_a expected_warning)
    found = warnings.find if_missing=Nothing is_expected
    if found.is_nothing then
        Test.fail "Expected the result to contain a warning: "+expected_warning.to_text+", but it did not. The warnings were "+warnings.short_display_text+' (at '+loc+').'
    invalid = warnings.filter x-> is_expected x . not
    if invalid.not_empty then
        Test.fail "Expected the result to contain only the warning: "+found.to_text+", but it also contained: "+invalid.to_text+' (at '+loc+').'
    found

## UNSTABLE
   Checks if the provided value does _not_ have a warning of the specified type.

   It allows other warnings to be present also.
not_expect_warning : Any -> Any -> Nothing
not_expect_warning expected_warning_type result =
    warnings = get_attached_warnings result
    found = warnings.find if_missing=Nothing x-> x.is_a expected_warning_type
    if found.is_nothing.not then
        loc = Meta.get_source_location 3
        Test.fail 'The result contained a warning it was not supposed to: '+found.to_text+' (at '+loc+').'
