## TODO This is a prototype based on the current pending design, used to proceed
   with handling of types in the `filter` component and others. It will be
   revisited when proper type support is implemented.

from Standard.Base import all
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument

from project.Errors import Invalid_Value_Type

## Type to represent the different sizes of integer or float possible within a database.
type Bits
    ## 16-bit (2 byte) value
    Bits_16
    ## 32-bit (4 byte) value
    Bits_32
    ## 64-bit (8 byte) value
    Bits_64

    ## PRIVATE
    to_bits : Integer
    to_bits self = case self of
        Bits.Bits_16 -> 16
        Bits.Bits_32 -> 32
        Bits.Bits_64 -> 64

type Bits_Comparator
    compare x y = Comparable.from x.to_bits . compare x.to_bits y.to_bits
    hash x = Comparable.from x.to_bits . hash x.to_bits

Comparable.from (_:Bits) = Bits_Comparator

## Represents the different possible types of values within RDBMS columns.
type Value_Type
    ## Boolean or Bit value: 0 or 1.

       ANSI SQL: BIT / BOOLEAN
    Boolean

    ## Integer value: 0 to 255

       ANSI SQL: TINYINT
    Byte

    ## Integer value:

       16-bit: -32,768 to 32,767
       32-bit: -2,147,483,648 to -2,147,483,648
       64-bit: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
       ANSI SQL: SMALLINT (16-bit), INT (32-bit), BIGINT (64-bit)
    Integer size:Bits=Bits.Bits_64

    ## Floating point value.

       ANSI SQL: REAL, FLOAT, DOUBLE
    Float size:Bits=Bits.Bits_64

    ## Arbitrary precision numerical value with a scale and precision.

       ANSI SQL: NUMERIC, DECIMAL
    Decimal precision:(Integer|Nothing)=Nothing scale:(Integer|Nothing)=Nothing

    ## Character string.

       ANSI SQL: CHAR, VARCHAR, TEXT, LONGVARCHAR, NCHAR, NVARCHAR, TEXT, CLOB, NCLOB
    Char size:(Integer|Nothing)=Nothing variable:Boolean=True

    ## Date

       ANSI SQL: DATE
    Date

    ## Date and Time

       ANSI SQL: TIMESTAMP / DateTime
    Date_Time with_timezone:Boolean=True

    ## Time of day

       ANSI SQL: TIME, TIME WITHOUT TIME ZONE
    Time

    ## Binary stream.

       ANSI SQL: BINARY, VARBINARY, LONGVARBINARY, BLOB, BIT(n)
    Binary size:(Integer|Nothing)=Nothing variable:Boolean=False

    ## Unsupported SQL type.

       Fallback provided to allow describing types that are not supported by Enso at this time.
    Unsupported_Data_Type type_name:Text=""

    ## A mix of values can be stored in the Column.

       In-Memory and SQLite tables support this.
    Mixed

    ## ADVANCED
       UNSTABLE
       Checks if the provided value type is a textual type (with any settings)
       and runs the following action or reports a type error.
    expect_text : Value_Type -> Any -> Text -> Any ! Invalid_Value_Type
    expect_text value_type ~action related_column=Nothing = case value_type of
        Value_Type.Char _ _ -> action
        _ -> Error.throw (Invalid_Value_Type.Error Value_Type.Char value_type related_column)

    ## ADVANCED
       UNSTABLE
       Checks if the provided value type is a boolean type and runs the
       following action or reports a type error.
    expect_boolean : Value_Type -> Any -> Any ! Invalid_Value_Type
    expect_boolean value_type ~action = case value_type of
        Value_Type.Boolean -> action
        _ -> Error.throw (Invalid_Value_Type.Error Value_Type.Boolean value_type)

    ## UNSTABLE
       Checks if the `Value_Type` represents a floating-point number type.
    is_floating_point : Boolean
    is_floating_point self = case self of
        Value_Type.Float _ -> True
        _ -> False

    ## UNSTABLE
       Checks if the `Value_Type` represents a text type.
    is_text : Boolean
    is_text self = case self of
        Value_Type.Char _ _ -> True
        _ -> False

    ## PRIVATE
       Finds a type that can fit both a current type and a new type.
    reconcile_types current new = case current of
        Value_Type.Mixed -> Value_Type.Mixed
        Value_Type.Integer size -> case new of
            Value_Type.Integer new_size ->
                Value_Type.Integer (Math.max size new_size)
            Value_Type.Byte    -> Value_Type.Integer size
            Value_Type.Boolean -> Value_Type.Integer size
            # If we unify integers with floats, we select the default Float 64 regardless of the input sizes.
            Value_Type.Float _ -> Value_Type.Float
            _                  -> Value_Type.Mixed
        Value_Type.Float size -> case new of
            Value_Type.Float new_size ->
                Value_Type.Float (Math.max size new_size)
            # If we unify integers with floats, we select the default Float 64 regardless of the input sizes.
            Value_Type.Integer _ -> Value_Type.Float
            Value_Type.Byte      -> Value_Type.Float
            Value_Type.Boolean   -> Value_Type.Float
            _                    -> Value_Type.Mixed
        Value_Type.Byte -> case new of
            Value_Type.Byte    -> Value_Type.Byte
            Value_Type.Integer size ->
                Value_Type.Integer size
            Value_Type.Boolean -> Value_Type.Byte
            Value_Type.Float _ -> Value_Type.Float
            _                  -> Value_Type.Mixed
        Value_Type.Boolean -> case new of
            Value_Type.Boolean -> Value_Type.Boolean
            Value_Type.Integer size ->
                Value_Type.Integer size
            Value_Type.Byte    -> Value_Type.Byte
            Value_Type.Float _ -> Value_Type.Float
            _                  -> Value_Type.Mixed
        Value_Type.Char current_size current_variable -> case new of
            Value_Type.Char new_size new_variable ->
                result_variable = current_variable || new_variable || current_size != new_size
                case result_variable of
                    True -> Value_Type.Char Nothing True
                    False -> Value_Type.Char current_size False
            _ -> Value_Type.Mixed
        Value_Type.Binary current_size current_variable -> case new of
            Value_Type.Binary new_size new_variable ->
                result_variable = current_variable || new_variable || current_size != new_size
                case result_variable of
                    True -> Value_Type.Binary Nothing True
                    False -> Value_Type.Binary current_size False
            _ -> Value_Type.Mixed
        _ ->
            if current == new then current else Value_Type.Mixed

    ## PRIVATE
       Finds the most specific value type that will fit all the provided types.

       If `strict` is `True`, it is implemented as specified in the note
       "Unifying Column Types" in `Table.union`. In that case, if no common type
       is found, `Nothing` is returned.

       It assumes that the `types` vector is not empty.
    find_common_type : Vector Value_Type -> Boolean -> Value_Type | Nothing
    find_common_type types strict =
        most_generic_type = (types.drop 1).fold types.first Value_Type.reconcile_types
        if strict.not || most_generic_type != Value_Type.Mixed then most_generic_type else
            # Double check if Mixed was really allowed to come out.
            if types.contains Value_Type.Mixed then Value_Type.Mixed else
                Nothing

## The type representing inferring the column type automatically based on values
   present in the column.

   The most specific type which is valid for all values in a column is chosen:
   - if all values are integers, `Integer` is chosen,
   - if all values are decimals or integers, `Decimal` is chosen,
   - if the values are all the same time type (a date, a time or a date-time),
     the corresponding type is chosen, `Date`, `Time_Of_Day` or `Date_Time`,
     respectively,
   - if all values are booleans, `Boolean` is chosen,
   - otherwise, `Text` is chosen as a fallback and the column is kept as-is
     without parsing.
type Auto

## PRIVATE
   Checks if the given type is a valid target type for parsing.

   This will be replaced once we change parse to rely on `Value_Type` instead.
ensure_valid_parse_target type ~action =
    expected_types = [Auto, Integer, Decimal, Date, Date_Time, Time_Of_Day, Boolean]
    if expected_types.contains type . not then Error.throw (Illegal_Argument.Error "Unsupported target type "+type.to_text+".") else action
