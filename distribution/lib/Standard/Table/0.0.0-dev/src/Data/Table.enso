from Standard.Base import all

import Standard.Base.System.Platform
import Standard.Table.Data.Column
import Standard.Visualization
from Standard.Base.Data.Time.Date as Date_Module import Date
import Standard.Table.Io.Spreadsheet_Write_Mode
import Standard.Table.Io.File_Format
import Standard.Base.System.File
import Standard.Base.System.File.Existing_File_Behavior
import Standard.Base.Error.Common as Errors
import Standard.Table.Internal.Table_Helpers
import Standard.Table.Internal.Aggregate_Column_Helper
import Standard.Table.Internal.Parse_Values_Helper
import Standard.Table.Internal.Delimited_Reader
import Standard.Table.Internal.Delimited_Writer
import Standard.Table.Internal.Problem_Builder

from Standard.Table.Data.Column_Selector as Column_Selector_Module import Column_Selector, By_Index
from Standard.Table.Data.Column_Type_Selection as Column_Type_Selection_Module import Column_Type_Selection, Auto
from Standard.Table.Data.Data_Formatter as Data_Formatter_Module import Data_Formatter
from Standard.Base.Data.Text.Text_Ordering as Text_Ordering_Module import Text_Ordering
from Standard.Base.Error.Problem_Behavior as Problem_Behavior_Module import Problem_Behavior, Report_Warning
from Standard.Table.Error as Error_Module import Missing_Input_Columns, Column_Indexes_Out_Of_Range, Duplicate_Type_Selector

import Standard.Table.Data.Column_Mapping
import Standard.Table.Data.Position
import Standard.Table.Data.Sort_Column_Selector
import Standard.Table.Data.Sort_Column

import Standard.Table.Data.Aggregate_Column
import Standard.Base.Data.Ordering.Comparator

polyglot java import org.enso.table.data.table.Table as Java_Table
polyglot java import org.enso.table.data.table.Column as Java_Column
polyglot java import org.enso.table.format.xlsx.Writer as Spreadsheet_Writer
polyglot java import org.enso.table.operations.OrderBuilder

## Creates a new table from a vector of `[name, items]` pairs.

   Arguments:
   - columns: The `[name, items]` pairs to construct a new table from.

   > Example
     Create a new table with the given columns.

         import Standard.Table

         example_new =
             first_column = ["count", [1, 2, 3]]
             second_column = ["is_valid", [True, False, True]]
             Table.new [first_column, second_column]
new : Vector (Vector | Column) -> Table
new columns =
    cols = columns.map c->
        case c of
            Vector.Vector _ -> Column.from_vector (c.at 0) (c.at 1) . java_column
            Column.Column java_col -> java_col
    here.from_columns cols

## Creates a new table from a vector of column names and a vector of vectors
   specifying row contents.

   Arguments:
   - header: A list of texts specifying the column names
   - rows: A vector of vectors, specifying the contents of each table row. The
     length of each element of `rows` must be equal in length to `header`.

   > Example
     Create a table with 3 columns, named `foo`, `bar`, and `baz`, containing
     `[1, 2, 3]`, `[True, False, True]`, and `['a', 'b', 'c']`, respectively.

         import Standard.Table

         example_from_rows =
             header = [ 'foo' , 'bar' , 'baz' ]
             row_1 =  [ 1     , True  , 'a'   ]
             row_2 =  [ 2     , False , 'b'   ]
             row_3 =  [ 3     , True  , 'c'   ]
             Table.from_rows header [row_1, row_2, row_3]
from_rows : Vector.Vector -> Vector.Vector -> Table
from_rows header rows =
    columns = header.map_with_index i-> name-> [name, rows.map (_.at i)]
    here.new columns

## ALIAS Join Tables

   Joins a vector of tables (or columns) into a single table, using each table's
   index as the join key.

   Arguments:
   - tables: A vector of tables to join into a single table.

   Particularly useful for joining multiple columns derived from one original
   table into a new table.

   > Example
     Join multiple tables together. It joins tables on their indices, so we need
     to make sure the indices are correct.

         import Standard.Examples
         import Standard.Table

         example_join =
             table_1 = Examples.inventory_table
             table_2 = Examples.popularity_table
             Table.join [table_1, table_2]
join : Vector -> Table
join tables =
    tables.reduce .join

## UNSTABLE

   Concatenates multiple tables, resulting in a table with the number of rows
   being the sum of numbers of rows of `tables`. Any column that is present in
   some tables, but missing in others, will be `Nothing`-padded in the positions
   corresponding to the missing values.

   Arguments:
   - tables: the tables to concatenate.

   > Example
     Concatenate multiple tables together.

         import Standard.Examples
         import Standard.Table

         example_concat =
             table_1 = Examples.inventory_table
             table_2 = Examples.popularity_table
             Table.concat [table_1, table_2]
concat : Vector -> Table
concat tables =
    Table (Java_Table.concat (tables.map .java_table).to_array)

## Represents a column-oriented table data structure.
type Table

    ## PRIVATE

       A table.

       Arguments:
       - java_table: The internal java representation of the table.
    type Table java_table

    ## Returns a text containing an ASCII-art table displaying this data.

       Arguments:
       - show_rows: the number of initial rows that should be displayed.
       - format_terminal: whether ANSI-terminal formatting should be used

       > Example
         Convert the table to a pretty-printed representation.

             import Standard.Examples

             example_display = Examples.inventory_table.display
    display : Integer -> Boolean -> Text
    display show_rows=10 format_terminal=False =
        cols = Vector.Vector self.java_table.getColumns
        index =  self.java_table.getIndex
        col_names = [index.getName] + cols.map .getName
        col_vals = cols.map .getStorage
        num_rows = self.row_count
        display_rows = Math.min num_rows show_rows
        rows = Vector.new display_rows row_num->
            cols = col_vals.map col->
                if col.isNa row_num then "Nothing" else Column.get_item_string col row_num
            [index.ilocString row_num] + cols
        table = here.print_table col_names rows 1 format_terminal
        if num_rows - display_rows <= 0 then table else
            missing = '\n\u2026 and ' + (num_rows - display_rows).to_text + ' hidden rows.'
            table + missing

    ## Prints an ASCII-art table with this data to the standard output.

       Arguments:
       - show_rows: the number of initial rows that should be displayed.

       > Example
         Convert the table to a pretty-printed representation and print it to
         the console.

             import Standard.Examples

             example_print = Examples.inventory_table.print
    print show_rows=10 =
        IO.println (self.display show_rows format_terminal=True)
        IO.println ''

    ## Converts this table to a JSON structure.

       > Example
         Convert a table to a corresponding JSON representation.

             import Standard.Examples

             example_to_json = Examples.inventory_table.to_json
    to_json : Json
    to_json =
        index_prep = case self.index.catch (_->Nothing) of
            Nothing -> []
            index -> [index]
        cols = index_prep + self.columns
        rows = 0.up_to self.row_count . map row->
            vals_kv = cols.map col-> [col.name, col.at row]
            Json.from_pairs vals_kv
        rows.to_json

    ## UNSTABLE
       ADVANCED

       Returns a Text used to display this table in the IDE by default.

       Returns a JSON object containing useful metadata and previews of column
       values.
    to_default_visualization_data : Text
    to_default_visualization_data =
        max_size = 10
        row_count = ['number_of_rows', self.row_count]
        cols = self.columns.map c->
            name = c.name
            items = c.to_vector.take_start max_size
            Json.from_pairs [['name', name], ['data', items]]
        Json.from_pairs [row_count, ['columns', cols]] . to_text

    ## UNSTABLE
       ADVANCED

       Guides the visualization system to display the most suitable graphical
       representation for this table.
    default_visualization : Visualization.Id.Id
    default_visualization =
        cols = self.columns.map .name . map name-> name.to_case Case.Lower
        if cols.contains "latitude" && cols.contains "longitude" then Visualization.Id.geo_map else
            if cols.contains "x" && cols.contains "y" then Visualization.Id.scatter_plot else
                Visualization.Id.table

    ## Returns the column with the given name.

       Arguments:
       - name: The name of the column being looked up.

       > Example
         Get the names of all of the items from the shop inventory.

             import Standard.Examples

             example_at = Examples.inventory_table.at "item_name"
    at : Text -> Column ! No_Such_Column_Error
    at name = case self.java_table.getColumnOrIndexByName name of
        Nothing -> Error.throw (No_Such_Column_Error name)
        c -> Column.Column c

    ## Returns a new table with a chosen subset of columns, as specified by the
       `columns`, from the input table. Any unmatched input columns will be
       dropped from the output.

       Arguments:
       - columns: Column selection criteria.
       - reorder: By default, or if set to `False`, columns in the output will
         be in the same order as in the input table. If `True`, the order in the
         output table will match the order in the columns list.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`, with the column included the first
           time it is matched.
         - If there are no columns in the output table, a `No_Output_Columns`.

       > Example
         Select columns by name.

             table.select_columns (By_Name ["bar", "foo"])

       ## TODO [RW] default arguments do not work on atoms, once this is fixed,
          the above should be replaced with just `By_Name`.
          See: https://github.com/enso-org/enso/issues/1600

       > Example
         Select columns matching a regular expression.

             table.select_columns (By_Name ["foo.+", "b.*"] (Regex_Matcher case_sensitive=Case_Insensitive))

       > Example
         Select the first two columns and the last column, moving the last one to front.

             table.select_columns (By_Index [-1, 0, 1]) reorder=True

       > Example
         Select columns with the same names as the ones provided.

             table.select_columns (By_Column [column1, column2])
    select_columns : Column_Selector -> Boolean -> Problem_Behavior -> Table
    select_columns (columns = By_Index [0]) (reorder = False) (on_problems = Report_Warning) =
        new_columns = Table_Helpers.select_columns internal_columns=self.columns selector=columns reorder=reorder on_problems=on_problems
        here.new new_columns

    ## Returns a new table with the chosen set of columns, as specified by the
       `columns`, removed from the input table. Any unmatched input columns will
       be kept in the output. Columns are returned in the same order as in the
       input.

       Arguments:
       - columns: Criteria specifying which columns should be removed.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`, with the column included the first
           time it is matched.
         - If there are no columns in the output table, a `No_Output_Columns`.

       > Example
         Remove columns with given names.

             table.remove_columns (By_Name ["bar", "foo"])

       ## TODO [RW] default arguments do not work on atoms, once this is fixed,
          the above should be replaced with just `By_Name`.
          See: https://github.com/enso-org/enso/issues/1600

       > Example
         Remove columns matching a regular expression.

             table.remove_columns (By_Name ["foo.+", "b.*"] (Regex_Matcher case_sensitive=Case_Insensitive))

       > Example
         Remove the first two columns and the last column.

             table.remove_columns (By_Index [-1, 0, 1])

       > Example
         Remove columns with the same names as the ones provided.

             table.remove_columns (By_Column [column1, column2])
    remove_columns : Column_Selector -> Problem_Behavior -> Table
    remove_columns (columns = By_Index [0]) (on_problems = Report_Warning) =
        new_columns = Table_Helpers.remove_columns internal_columns=self.columns selector=columns on_problems=on_problems
        here.new new_columns

    ## Returns a new table with the specified selection of columns moved to
       either the start or the end in the specified order.

       Arguments:
       - columns: Criteria specifying which columns should be reordered and
         specifying their order.
       - position: Specifies how to place the selected columns in relation to
         the remaining columns which were not matched by `columns` (if any).
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`, with the column included the first
           time it is matched.

       > Example
         Move a column with a specified name to back.

             table.reorder_columns (By_Name ["foo"]) position=After_Other_Columns

       ## TODO [RW] default arguments do not work on atoms, once this is fixed,
          the above should be replaced with just `By_Name`.
          See: https://github.com/enso-org/enso/issues/1600

       > Example
         Move columns matching a regular expression to front, keeping columns matching "foo.+" before columns matching "b.*".

             table.reorder_columns (By_Name ["foo.+", "b.*"] (Regex_Matcher case_sensitive=Case_Insensitive))

       > Example
         Swap the first two columns.

             table.reorder_columns (By_Index [1, 0]) position=Before_Other_Columns

       > Example
         Move the first column to back.

             table.reorder_columns (By_Index [0]) position=After_Other_Columns

       > Example
         Move the columns with names matching the provided columns to the front.

             table.reorder_columns (By_Column [column1, column2])
    reorder_columns : Column_Selector -> Position.Position -> Problem_Behavior -> Table
    reorder_columns (columns = By_Index [0]) (position = Position.Before_Other_Columns) (on_problems = Report_Warning) =
        new_columns = Table_Helpers.reorder_columns internal_columns=self.columns selector=columns position=position on_problems=on_problems
        here.new new_columns

    ## Returns a new table with the columns sorted by name according to the
       specified sort method. By default, sorting will be according to
       case-sensitive ascending order based on the `compare_to` operator for
       `Text`.

       Arguments:
       - direction: Whether sorting should be in ascending or descending order.
       - text_ordering: The sort methodology to use.

       > Example
         Sort columns according to the default ordering.

             table.sort_columns

       > Example
         Sort columns according to the natural case-insensitive ordering.

             table.sort_columns text_ordering=(Text_Ordering sort_digits_as_numbers=True case_sensitive=Case_Insensitive)

       > Example
         Sort columns in descending order.

             table.reorder_columns Sort_Direction.Descending
    sort_columns : Sort_Direction -> Text_Ordering -> Table
    sort_columns direction=Sort_Direction.Ascending text_ordering=Text_Ordering =
        new_columns = Table_Helpers.sort_columns internal_columns=self.columns direction text_ordering
        here.new new_columns

    ## Returns a new table with the columns renamed based on either a mapping
       from the old name to the new or a positional list of new names.

       Arguments:
       - column_map: Mapping from old column names to new.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`.
         - If in `By_Position` mode and more names than columns are provided,
           a `Too_Many_Column_Names_Provided`.
         - If any of the new names are invalid, an
           `Invalid_Output_Column_Names`.
         - If any of the new names clash either with existing names or each
           other, a Duplicate_Output_Column_Names.

       > Example
         Rename the first column to "FirstColumn"

              table.rename_columns (Column_Mapping.By_Position ["FirstColumn"])
    rename_columns : Column_Mapping -> Problem_Behavior -> Table
    rename_columns (column_map=(Column_Mapping.By_Position ["Column"])) (on_problems=Report_Warning) =
        new_names = Table_Helpers.rename_columns internal_columns=self.columns mapping=column_map on_problems=on_problems
        if new_names.is_error then new_names else
            new_columns = self.columns.map_with_index i->c->(c.rename (new_names.at i))
            here.new new_columns

    ## Returns a new table with the columns renamed based on entries in the
       first row.

       Arguments:
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If any of the new names are invalid, an
           `Invalid_Output_Column_Names`.
         - If any of the new names clash either with existing names or each
           other, a Duplicate_Output_Column_Names.

       > Example
         Rename the column based on the first row

              table.use_first_row_as_names
    use_first_row_as_names : Problem_Behavior -> Table
    use_first_row_as_names (on_problems=Report_Warning) =
        mapper = col->
            val = col.at 0
            case val of
                Text -> val
                Nothing -> Nothing
                _ -> val.to_text
        new_names = self.columns.map mapper
        self.take_end (self.length - 1) . rename_columns (Column_Mapping.By_Position new_names) on_problems=on_problems

    ## ALIAS group, summarize

       Aggregates the rows in a table using any `Group_By` entries in columns.
       The columns argument specifies which additional aggregations to perform and to return.

       Arguments:
       - columns: Vector of `Aggregate_Column` specifying the aggregated table.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column name is not in the input table, a `Missing_Input_Columns`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If there are no valid columns in the output table, a `No_Output_Columns`.
         - If there are invalid column names in the output table, a `Invalid_Output_Column_Names`.
         - If there are duplicate column names in the output table, a `Duplicate_Output_Column_Names`.
         - If grouping on or computing the `Mode` on a floating point number, a `Floating_Point_Grouping`.
         - If an aggregation fails, an `Invalid_Aggregation_Method`.
         - If when concatenating values there is an quoted delimited, an `Unquoted_Delimiter`
         - If there are more than 10 issues with a single column, an `Additional_Warnings`.

       > Example
         Group by the Key column, count the rows

              table.aggregate [Group_By "Key", Count Nothing]
    aggregate : [Aggregate_Column] -> Problem_Behavior -> Table
    aggregate columns (on_problems=Report_Warning) =
        validated = Aggregate_Column_Helper.prepare_aggregate_columns columns self

        on_problems.attach_problems_before validated.problems <|
            java_key_columns = validated.key_columns.map .java_column
            index = self.java_table.indexFromColumns java_key_columns.to_array Comparator.new

            new_columns = validated.valid_columns.map c->(Aggregate_Column_Helper.java_aggregator c.first c.second)

            java_table = index.makeTable new_columns.to_array
            new_table = Table java_table

            on_problems.attach_problems_after new_table <|
                problems = java_table.getProblems
                Aggregate_Column_Helper.parse_aggregated_problems problems

    ## Sorts the rows of the table according to the specified columns and order.

       Arguments:
       - columns: The columns and order to sort the table.
       - text_ordering: The ordering method to use on text values.
       - on_problems: Specifies how to handle if a problem occurs, raising as a
         warning by default. The following problems can occur:
         - If a column in `columns` is not present in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`.
         - If two name matchers match the same column, a
           `Column_Matched_By_Multiple_Selectors`.
         - If no valid columns are selected, a `No_Input_Columns_Selected`.
         - If values do not implement an ordering, an
           `Incomparable_Values_Error`.

       > Example
         Order the table by the column "alpha" in ascending order.

             table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "alpha"])

       > Example
         Order the table by the second column in ascending order. In case of any
         ties, break them based on the 7th column from the end of the table in
         descending order.

             table.order_by (Sort_Column_Selector.By_Index [Sort_Column.Index 1, Sort_Column.Index -7 Sort_Direction.Descending])
       > Example
         Sorting the shop inventory based on the per-item price in ascending
         order.

             import Standard.Examples

             example_sort = Examples.inventory_table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "price"])

       > Example
         Sort the shop inventory based on the per-item price in descending order

             import Standard.Examples

             example_sort =
                table = Examples.inventory_table
                table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "price" Sort_Direction.Descending])

       > Example
         Sort the shop inventory based on the total stock, using the number sold
         to break ties in descending order.

             import Standard.Examples

             example_sort =
                 table = Examples.inventory_table
                 table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "total_stock" Sort_Direction.Descending, Sort_Column.Name "sold_stock" Sort_Direction.Descending])

       > Example
         Sort the shop inventory in ascending order by the total stock, using
         the number of items sold in descending order to break ties.

             import Standard.Examples
             import Standard.Table

             example_sort =
                 table = Examples.inventory_table
                 table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "total_stock", Sort_Column.Name "sold_stock" Sort_Direction.Descending])

    order_by : Sort_Column_Selector -> Text_Ordering -> Problem_Behavior -> Table
    order_by (columns = (Sort_Column_Selector.By_Name [(Sort_Column.Name (self.columns.at 0 . name))])) text_ordering=Text_Ordering on_problems=Report_Warning =
        problem_builder = Problem_Builder.new
        columns_for_ordering = Table_Helpers.prepare_order_by self.columns columns problem_builder
        problem_builder.attach_problems_before on_problems <|
            selected_columns = columns_for_ordering.map c->c.column.java_column
            ordering = columns_for_ordering.map c->c.associated_selector.direction.to_sign
            comparator = Comparator.for_text_ordering text_ordering
            java_table = self.java_table.orderBy selected_columns.to_array ordering.to_array comparator
            Table java_table

    ## Parses columns within a Table to a specific value type.
       By default, it looks at all `Text` columns and attempts to deduce the
       type (columns with other types are not affected). If `column_types` are
       provided, only selected columns are parsed, according to the specified
       type.

       The default parser options only parse values where the process is
       reversible (e.g., 0123 would not be converted to an integer as there is
       a leading 0). However, settings in the `Data_Formatter` can
       control this.
    parse_values : Data_Formatter -> (Nothing | [Column_Type_Selection]) -> Problem_Behavior -> Table
    parse_values value_formatter=Data_Formatter column_types=Nothing on_problems=Report_Warning =
        columns = self.columns
        problem_builder = Vector.new_builder

        find_datatype index column =
            matching_input = column_types.filter selection->
                selector = selection.column
                case selector of
                    Text -> column.name == selector
                    Integer -> if selector >= 0 then index == selector else
                        index == columns.length + selector
            if matching_input.length == 0 then Nothing else
                if matching_input.length == 1 then matching_input.first.datatype else
                    first_type = matching_input.first.datatype
                    ambiguous = matching_input.exists s-> s.datatype != first_type
                    problem_builder.append (Duplicate_Type_Selector column.name ambiguous)
                    if ambiguous then Nothing else first_type

        expected_types = case column_types of
            Nothing -> columns.map _->Auto
            _ ->
                missing_columns = Vector.new_builder
                invalid_indices = Vector.new_builder
                column_types.each selection->
                    selector = selection.column
                    case selector of
                        Integer ->
                            valid = Table_Helpers.is_index_valid columns.length selector
                            if valid.not then
                                invalid_indices.append selector
                        Text ->
                            found = columns.exists col-> col.name == selector
                            if found.not then
                                missing_columns.append selector
                if missing_columns.is_empty.not then
                    problem_builder.append (Missing_Input_Columns missing_columns.to_vector)
                if invalid_indices.is_empty.not then
                    problem_builder.append (Column_Indexes_Out_Of_Range invalid_indices.to_vector)
                columns.map_with_index find_datatype

        new_columns = columns.zip expected_types column-> expected_type-> case expected_type of
            Nothing -> column
            _ ->
                parser = if expected_type == Auto then value_formatter.make_auto_parser else
                    value_formatter.make_datatype_parser expected_type
                storage = column.java_column.getStorage
                new_storage_and_problems = parser.parseColumn column.name storage
                new_storage = new_storage_and_problems.value
                problems = Vector.Vector new_storage_and_problems.problems . map (Parse_Values_Helper.translate_parsing_problem expected_type)
                problems.each problem_builder.append
                Column.Column (Java_Column.new column.name column.java_column.getIndex new_storage)

        ## TODO [RW] this case of is a workaround for wrong dataflow handling on arrays, it can be removed once the PR fixing it is merged, the relevant PR is:
           https://github.com/enso-org/enso/pull/3400
        result = here.new new_columns
        on_problems.attach_problems_after result problem_builder.to_vector

    ## ALIAS Filter Rows
       ALIAS Mask Columns

       Selects only the rows of this table that correspond to `True` values in
       `indexes`.

       Arguments:
       - indexes: The column to mask the table by. This column should contain
         boolean values (`True` or `False`) that determine whether or not the
         corresponding row is kept.

       This is useful for filtering the rows by given predicate.

       > Example
         Select only the items where more than half the stock has been sold.

             import Standard.Examples

             example_where =
                 table = Examples.inventory_table
                 mask = (table.at "sold_stock" > (table.at "total_stock" / 2))
                 table.where mask
    where : Column -> Table
    where indexes =
        Table (self.java_table.mask indexes.java_column)

    ## ALIAS Add Column

       Sets the column value at the given name.

       Arguments:
       - name: The name of the column to set the value of.
       - column: The new value for the column called `name`.

       If a column with the given name already exists, it will be replaced.
       Otherwise a new column is added.

       > Example
         Create a table where the values of the total stock in the inventory is
         doubled.

             import Standard.Examples

             example_set =
                 table = Examples.inventory_table
                 double_inventory = table.at "total_stock" * 2
                 table.set "total_stock" double_inventory
    set : Text -> Column.Column | Vector.Vector -> Table
    set name column = case column of
        Vector.Vector _ ->
            self.set name (Column.from_vector name column)
        Column.Column _ ->
            Table (self.java_table.addOrReplaceColumn (column.rename name . java_column))

    ## Returns the vector of columns contained in this table.

       > Examples
         Get a vector containing the columns in the table.

             import Standard.Examples

             example_columns = Examples.inventory_table.columns
    columns : Vector
    columns = Vector.Vector self.java_table.getColumns . map Column.Column

    ## Sets the index of this table, using the column with the provided name.

       Arguments:
       - index: The name of the column to use as the index in this table, or the
         column itself to use.

       > Example
         Set the index of the inventory table to be the item name.

             import Standard.Examples

             example_set_index = Examples.inventory_table.set_index "item_name"
    set_index : Text | Column -> Table
    set_index index = case index of
        Text -> Table (self.java_table.indexFromColumn index)
        Column.Column c -> Table (self.java_table.indexFromColumn c)

    ## Returns the index of this table, as a column that is indexed by itself.

       Throws `No_Index_Set_Error` if there is no index set in the table it is
       being called on.

       > Example
         Get the column that is used as the index for a table.

             import Standard.Examples

             example_index = Examples.inventory_table.index
    index : Column.Column ! No_Index_Set_Error
    index = case self.java_table.getIndex.toColumn of
        Nothing -> Error.throw No_Index_Set_Error
        i -> Column.Column i

    ## ALIAS Join Table

       Efficiently joins two tables based on either the index or the specified
       key column.

       Arguments:
       - other: The table being the right operand of this join operation.
       - on: The column of `self` that should be used as the join key. If this
         argument is not provided, the index of `self` will be used.
       - drop_unmatched: Whether the rows of `self` without corresponding
         matches in `other` should be dropped from the result.
       - left_suffix: A suffix that should be added to the columns of `self`
         when there's a name conflict with a column of `other`.
       - right_suffix: A suffix that should be added to the columns of `other`
         when there's a name conflict with a column of `self`.

       The resulting table contains rows of `self` extended with rows of
       `other` with matching indexes. If the index values in `other` are not
       unique, the corresponding rows of `self` will be duplicated in the
       result.

       > Example
         Join the popularity table and the inventory table to see the relative
         popularities of the items in the shop inventory.

             import Standard.Examples

             example_join =
                 Examples.inventory_table.join Examples.popularity_table
    join : Table | Column.Column -> Text | Nothing -> Boolean -> Text -> Text -> Table
    join other on=Nothing drop_unmatched=False left_suffix='_left' right_suffix='_right' =
        case other of
            Column.Column _ -> self.join other.to_table on drop_unmatched left_suffix right_suffix
            Table t ->
                Table (self.java_table.join t drop_unmatched on left_suffix right_suffix)

    ## ALIAS Clean Rows

       Returns a new Table without rows that contained missing values in any of
       the columns.

       > Example
         Remove any rows that contain missing values from the table.

             import Standard.Examples

             example_drop_missing_rows =
                 Examples.inventory_table.drop_missing_rows
    drop_missing_rows : Table
    drop_missing_rows =
        cols = self.columns
        case cols.not_empty of
            True ->
                any_missing_mask = cols.map .is_missing . reduce (||)
                non_missing_mask = any_missing_mask.not
                self.where non_missing_mask
            False -> self

    ## ALIAS Clean Columns

       Returns a new Table without columns that contained any missing values.

       > Example
         Remove any columns that contain missing values from the table.

             import Standard.Examples

             example_drop_missing_cols =
                 Examples.inventory_table.drop_missing_columns
    drop_missing_columns : Table
    drop_missing_columns =
        non_missing = self.columns . filter (col -> col.count_missing == 0)
        index = self.java_table.getIndex
        Table (Java_Table.new (non_missing.map .java_column . to_array) index)

    ## Returns the number of rows in this table.

       > Example
         Count the number of rows in the table.

             import Standard.Examples

             example_row_count = Examples.inventory_table.row_count
    row_count : Integer
    row_count = self.java_table.rowCount

    ## Returns the number of rows in this table.

       > Example
         Count the number of rows in the table.

             import Standard.Examples

             example_length = Examples.inventory_table.length
    length : Integer
    length = self.row_count

    ## Returns a Table describing this table's contents.

       The table lists all columns, counts of non-null items and storage types
       of each column.

       > Example
         Get information about a table.

             import Standard.Examples

             example_info = Examples.inventory_table.info
    info : Table
    info =
        cols = self.columns
        here.new [["Column", cols.map .name], ["Items Count", cols.map .count], ["Storage Type", cols.map .storage_type]] . set_index "Column"

    ## UNSTABLE

       Concatenates `other` to `self`.

       Arguments:
       - other: The table to concatenate to `self`.

       Any column that is present in one table, but missing in another, will be
       `Nothing`-padded in the positions corresponding to the missing column.

       > Example
         Concatenate two tables together.

             import Standard.Examples

             example_concat =
                 Examples.inventory_table.concat Examples.popularity_table
    concat : Table -> Table
    concat other = Table (Java_Table.concat [self.java_table, other.java_table].to_array)

    ## ALIAS First N Rows
       UNSTABLE

       Returns a table containing the first `count` elements in this table.

       Arguments:
       - count: The number of elements to take from the start of this table.

       If `self` has a number of rows in it less than `count`, the entire table
       will be returned.

       > Example
         Get the first four rows from the table.

             import Standard.Examples

             example_take_start = Examples.inventory_table.take_start 4
    take_start : Integer -> Table
    take_start count = Table (self.java_table.slice 0 count)

    ## ALIAS Last N Rows
       UNSTABLE

       Returns a table containing the last `count` elements in this table.

       Arguments:
       - count: The number of elements to take from the end of this table.

       If `self` has a number of rows in it less than `count`, the entire table
       will be returned.

       > Example
         Get the last four rows from the table.

             import Standard.Examples

             example_take_end = Examples.inventory_table.take_end 4
    take_end : Integer -> Table
    take_end count =
        start_point = Math.max (self.row_count - count) 0
        Table (self.java_table.slice start_point count)

    ## ALIAS First Row
       UNSTABLE

       Returns the first row in the table, if it exists.

       If the table is empty, this method will return a dataflow error
       containing an `Empty_Error`.

       > Example
         Get the first row from the table.

             import Standard.Examples

             example_first = Examples.inventory_table.first
    first : Table ! Empty_Error
    first =
        table = self.take_start 1
        if table.row_count != 1 then Error.throw Empty_Error else table

    ## UNSTABLE

       Returns the first row in the table, if it exists.

       If the table is empty, this method will return a dataflow error
       containing an `Empty_Error`.

       > Example
         Get the first row from the table.

             import Standard.Examples

             example_head = Examples.inventory_table.head
    head : Table ! Empty_Error
    head = self.first

    ## ALIAS Last Row
       UNSTABLE

       Returns the last row in the table, if it exists.

       If the table is empty, this method will return a dataflow error
       containing an `Empty_Error`.

       > Example
         Get the last row from the table.

             import Standard.Examples

             example_last = Examples.inventory_table.last
    last : Table ! Empty_Error
    last =
        table = self.take_end 1
        if table.row_count != 1 then Error.throw Empty_Error else table

    ## UNSTABLE

       Returns a table containing the rows of `self` table with their order
       reversed.

       > Example
         Reverse the rows in a table.

             import Standard.Examples

             example_reverse = Examples.inventory_table.reverse
    reverse : Table
    reverse =
        mask = OrderBuilder.buildReversedMask self.row_count
        Table <| self.java_table.applyMask mask

    ## ALIAS Write Excel File
       UNSTABLE

       Writes this table into an XLSX spreadsheet.

       Arguments:
       - file: the XLSX file to write data to. If it exists, the behavior is
         specified by the `write_mode` argument. Note that other files may be
         created or written to if `max_rows_per_file` is used.
       - sheet: the name of the sheet to use for writing the data.
       - write_mode: specifies this method's behavior if the specified file and
         sheet already exist. Can be one of:
         - Spreadsheet_Write_Mode.Create: this is the default value. This
           setting will create a new sheet in the file, with a name chosen such
           that the clash is avoided.
         - Spreadsheet_Write_Mode.Overwrite: will result in removing all
           contents of the existing sheet and replacing it with the new data.
         - Spreadsheet_Write_Mode.Append: will append this data to the existing
           sheet, such that the new data starts after the last row containing
           any data.
       - include_header: Specifies whether the first line of generated CSV
         should contain the column names.
       - max_rows_per_file: specifies the maximum number of rows that can be
         written to a single file. If this option is set and its value is less
         than the number of rows in this table, the behavior of the `file`
         argument changes. Instead of writing the contents directly to `file`,
         its name is parsed and a numbered series of files with names based
         on `file` is written to instead. For example, if `file` points to
         `~/my_data/output.xlsx`, `self` contains 250 rows, and
         `max_rows_per_file` is set to `100`, 3 different files will be written:
         - `~/my_data/output_1.xlsx`, containing rows 0 through 99;
         - `~/my_data/output_2.xlsx`, containing rows 100 through 199;
         - `~/my_data/output_3.xlsx`, containing rows 200 through 249.

       > Example
         Write a table to an XLSX file.

             import Standard.Examples

             example_to_xlsx = Examples.inventory_table.write_xlsx (Enso_Project.data / example_xlsx_output.xlsx)
    write_xlsx : File.File -> String -> Spreadsheet_Write_Mode.Speadsheet_Write_Mode -> Boolean -> Nothing | Integer -> Nothing
    write_xlsx file sheet='Data' write_mode=Spreadsheet_Write_Mode.Create include_header=True max_rows_per_file=Nothing =
        Spreadsheet_Writer.writeXlsx self.java_table file.absolute.path sheet write_mode.to_java include_header max_rows_per_file .write_to_spreadsheet

    ## ALIAS Write JSON
       UNSTABLE

       Writes this table to a specified file, serialized into JSON. The JSON
       serialization is such that the result is an array, in which every entry
       is an object representing a single row, with column names as keys.

       Arguments:
       - file: the file to write data to. If the file exists, it will be
         overwritten.

       > Example
         Write a table to a JSON file.

             import Standard.Examples

             example_to_json = Examples.inventory_table.write_json (Enso_Project.data / 'example.json')
    write_json : File.File -> Nothing
    write_json file = self.to_json.to_text.write file

    ## This function writes a table from memory into a file.

       The specific behavior of the various `File_Format`s is specified below.

       Arguments:
       - path: The path to the output file.
       - format: The format of the file.
         If `File_Format.Auto` is specified; the file extension determines the
         specific type and uses the default settings for that type to be used.
         Details of this type are below.
       - on_existing_file: Specified how to handle if the file already exists.
       - column_matching: Specifies how to map columns against an existing file.
         If `Column_Matching.By_Name` - the columns are mapped by name against
         an existing file.
         If `Column_Matching.By_Position` - the columns are mapped by position
         against an existing file.
         If there is a mismatch, then a `Column_Mismatch` error is raised.
       - on_problems: Specifies how to handle if a problem occurs, raising as a
         warning by default. The specific issues depend on the `File_Format`
         argument.

       Returns:
       - If an unsupported `File_Format` is specified, an
         `Illegal_Argument_Error` is raised.
       - If the path to the parent location cannot be found or the filename is
         invalid, a `File_Not_Found` is raised.
       - If another IO error occurs, such as access denied, an `Io_Error` is
         raised.
       - If appending and the columns do not match, a `Column_Mismatch` is
         raised.
       - Other specific errors or warnings that can be raised depend on the
         format argument.
       - Otherwise, the file is loaded following the rules of the format
         parameter.

       ? `File_Format` write behaviors

         - `File_Format.Auto`: The file format is determined by the file
           extension of the path argument.
         - `File_Format.Bytes` and `File_Format.Text`: The Table does not
           support these types in the `write` function. If passed as format, an
           `Illegal_Argument_Error` is raised. To write out the table as plain
           text, the user needs to call the `Text.from Table` method and then
           use the `Text.write` function.

       > Example
         Write a table to a CSV file, without writing the header.

             import Standard.Examples
             import Standard.Table

             example_to_csv = Examples.inventory_table.write (Enso_Project.data / "example_csv_output.csv") (File_Format.Delimited delimiter="," headers=False)

       > Example
         Write a table to an XLSX file.

             import Standard.Examples
             import Standard.Table

             example_to_xlsx = Examples.inventory_table.write (Enso_Project.data / "example_xlsx_output.xlsx") File_Format.Excel
    write : File|Text -> File_Format -> Existing_File_Behavior -> Column_Mapping -> Problem_Behavior -> Nothing ! Column_Mismatch | Illegal_Argument_Error | File_Not_Found | Io_Error
    write path format=File_Format.Auto on_existing_file=Existing_File_Behavior.Backup column_mapping=Column_Mapping.By_Name on_problems=Report_Warning =
        format.write_table (File.new path) self on_existing_file column_mapping on_problems

    ## Creates a text representation of the table using the CSV format.
    to_csv : Text
    to_csv = Text.from self (File_Format.Delimited delimiter=",")

## UNSTABLE
   ADVANCED

   Used to write a value into a spreadsheet cell.

   Arguments:
   - cell: an instance of `org.apache.poi.ss.usermodel.Cell`, the value of
     which should be set by this method.
Any.write_to_spreadsheet cell = cell.setCellValue self.to_text

## UNSTABLE
   ADVANCED

   Used to write a value into a spreadsheet cell.

   Arguments:
   - cell: an instance of `org.apache.poi.ss.usermodel.Cell`, the value of
     which should be set by this method.
Text.write_to_spreadsheet cell = cell.setCellValue self

## UNSTABLE
   ADVANCED

   Used to write a value into a spreadsheet cell.

   Arguments:
   - cell: an instance of `org.apache.poi.ss.usermodel.Cell`, the value of
     which should be set by this method.
Date.write_to_spreadsheet cell = cell.setCellValue self.internal_local_date

## UNSTABLE

   An error returned when a non-existent column is being looked up.

   Arguments:
   - column_name: The name of the column that doesn't exist.
type No_Such_Column_Error column_name

## UNSTABLE

   Create a human-readable version of the no such column error.
No_Such_Column_Error.to_display_text : Text
No_Such_Column_Error.to_display_text =
    "The column " + self.column_name + " does not exist."

## UNSTABLE

   An error returned when getting an index but no index is set for that table.
type No_Index_Set_Error

## UNSTABLE

   Create a human-readable version of the no such column error.
No_Index_Set_Error.to_display_text : Text
No_Index_Set_Error.to_display_text = "The table does not have an index set."

## UNSTABLE

   An error returned when the table contains no rows.
type Empty_Error

## UNSTABLE

   Pretty prints the error.
Empty_Error.to_display_text : Text
Empty_Error.to_display_text = "The table is empty."

## PRIVATE
from_columns cols = Table (Java_Table.new cols.to_array)

## PRIVATE

   Ensures that the `txt` has at least `len` characters by appending spaces at
   the end.

   Arguments:
   - txt: The text to pad.
   - len: The minimum length of the text.
pad : Text -> Integer -> Text
pad txt len =
    true_len = txt.characters.length
    txt + (" ".repeat (len - true_len))

## PRIVATE

   Adds ANSI bold escape sequences to text if the feature is enabled.

   Arguments:
   - enabled: will insert ANSI sequences only if this flag is true and we are not on Windows.
   - txt: The text to possibly bold.
ansi_bold : Boolean -> Text -> Text
ansi_bold enabled txt =
    case Platform.os of
        ## Output formatting for Windows is not currently supported.
        Platform.Windows -> txt
        _ -> if enabled then '\e[1m' + txt + '\e[m' else txt

## PRIVATE

   A helper function for creating an ASCII-art representation of tabular data.

   Arguments:
   - header: vector of names of columns in the table.
   - rows: a vector of rows, where each row is a vector that contains a text
     representation of each cell
   - indices_count: the number specifying how many columns should be treated as
     indices; this will make them in bold font if `format_term` is enabled.
   - format_term: a boolean flag, specifying whether to use ANSI escape codes
     for rich formatting in the terminal.
print_table : Vector Text -> (Vector (Vector Text)) -> Integer -> Boolean -> Text
print_table header rows indices_count format_term =
    content_lengths = Vector.new header.length i->
        max_row = 0.up_to rows.length . fold 0 a-> j-> Math.max a (rows.at j . at i . characters . length)
        Math.max max_row (header.at i . characters . length)
    header_line = header.zip content_lengths here.pad . map (here.ansi_bold format_term) . join ' | '
    divider = content_lengths . map (l -> "-".repeat l+2) . join '+'
    row_lines = rows.map r->
        x = r.zip content_lengths here.pad
        ixes = x.take_start indices_count . map (here.ansi_bold format_term)
        with_bold_ix = ixes + x.drop_start indices_count
        y = with_bold_ix . join ' | '
        " " + y
    ([" " + header_line, divider] + row_lines).join '\n'

Table.from (that : Text) (format:File_Format.Delimited|File_Format.Fixed_Width = File_Format.Delimited '\t') (on_problems:Problem_Behavior=Report_Warning) =
    if format.is_a File_Format.Delimited then Delimited_Reader.read_text that format on_problems else
        Errors.unimplemented "Table.from for fixed-width files is not yet implemented."

Text.from (that : Table) (format:File_Format.Delimited|File_Format.Fixed_Width = File_Format.Delimited '\t') =
    if format.is_a File_Format.Delimited then Delimited_Writer.write_text that format else
        Errors.unimplemented "Text.from for fixed-width files is not yet implemented."
