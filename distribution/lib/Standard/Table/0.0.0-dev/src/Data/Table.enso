from Standard.Base import all
import Standard.Base.Error.Common as Errors
from Standard.Base.Error.Problem_Behavior import Report_Warning
import Standard.Base.Data.Index_Sub_Range
import Standard.Base.Data.Ordering.Comparator
import Standard.Base.Data.Text.Case
import Standard.Base.System.Platform

import project.Data.Column.Column
from project.Data.Column import get_item_string
import project.Data.Column_Name_Mapping.Column_Name_Mapping
import project.Data.Column_Selector.Column_Selector
import project.Data.Data_Formatter.Data_Formatter
import project.Data.Match_Columns.Match_Columns
import project.Data.Position.Position
import project.Data.Storage.Storage
import project.Data.Value_Type.Value_Type
import project.Data.Sort_Column_Selector.Sort_Column_Selector
import project.Data.Sort_Column.Sort_Column
import project.Data.Aggregate_Column.Aggregate_Column
import project.Data.Storage.Storage
import project.Internal.Table_Helpers
import project.Internal.Aggregate_Column_Helper
import project.Internal.Parse_Values_Helper
import project.Internal.Problem_Builder.Problem_Builder
import project.IO.Auto_Detect.Auto_Detect

from project.Data.Column import get_item_string
from project.Data.Column_Type_Selection import Column_Type_Selection, Auto
from project.Delimited.Delimited_Format import Delimited
from project.Internal.Filter_Condition_Helpers import make_filter_column
from project.Errors import Missing_Input_Columns, Column_Indexes_Out_Of_Range, Duplicate_Type_Selector, No_Index_Set_Error, No_Such_Column_Error, No_Such_Column_Error_Data, No_Input_Columns_Selected, No_Output_Columns, Invalid_Value_Type

import Standard.Visualization

polyglot java import org.enso.table.data.table.Table as Java_Table
polyglot java import org.enso.table.data.table.Column as Java_Column
polyglot java import org.enso.table.operations.OrderBuilder
polyglot java import org.enso.table.data.mask.OrderMask

## Represents a column-oriented table data structure.
type Table
    ## Creates a new table from a vector of `[name, items]` pairs.

       Arguments:
       - columns: The `[name, items]` pairs to construct a new table from.

       > Example
         Create a new table with the given columns.

             from Standard.Table import Table

             example_new =
                 first_column = ["count", [1, 2, 3]]
                 second_column = ["is_valid", [True, False, True]]
                 Table.new [first_column, second_column]
    new : Vector (Vector | Column) -> Table
    new columns =
        cols = columns.map c->
            case c of
                _ : Vector.Vector -> Column.from_vector (c.at 0) (c.at 1) . java_column
                Column.Column_Data java_col -> java_col
        Table.Table_Data (Java_Table.new cols.to_array)

    ## Creates a new table from a vector of column names and a vector of vectors
       specifying row contents.

       Arguments:
       - header: A list of texts specifying the column names
       - rows: A vector of vectors, specifying the contents of each table row. The
         length of each element of `rows` must be equal in length to `header`.

       > Example
         Create a table with 3 columns, named `foo`, `bar`, and `baz`, containing
         `[1, 2, 3]`, `[True, False, True]`, and `['a', 'b', 'c']`, respectively.

             from Standard.Table import Table

             example_from_rows =
                 header = [ 'foo' , 'bar' , 'baz' ]
                 row_1 =  [ 1     , True  , 'a'   ]
                 row_2 =  [ 2     , False , 'b'   ]
                 row_3 =  [ 3     , True  , 'c'   ]
                 Table.from_rows header [row_1, row_2, row_3]
    from_rows : Vector.Vector -> Vector.Vector -> Table
    from_rows header rows =
        columns = header.map_with_index i-> name-> [name, rows.map (_.at i)]
        Table.new columns

    ## PRIVATE

       A table.

       Arguments:
       - java_table: The internal java representation of the table.
    Table_Data java_table

    ## Returns a text containing an ASCII-art table displaying this data.

       Arguments:
       - show_rows: the number of initial rows that should be displayed.
       - format_terminal: whether ANSI-terminal formatting should be used

       > Example
         Convert the table to a pretty-printed representation.

             import Standard.Examples

             example_display = Examples.inventory_table.display
    display : Integer -> Boolean -> Text
    display self show_rows=10 format_terminal=False =
        cols = Vector.from_polyglot_array self.java_table.getColumns
        index =  self.java_table.getIndex
        col_names = [index.getName] + cols.map .getName
        col_vals = cols.map .getStorage
        num_rows = self.row_count
        display_rows = Math.min num_rows show_rows
        rows = Vector.new display_rows row_num->
            cols = col_vals.map col->
                if col.isNa row_num then "Nothing" else get_item_string col row_num
            [index.ilocString row_num] + cols
        table = print_table col_names rows 1 format_terminal
        if num_rows - display_rows <= 0 then table else
            missing = '\n\u2026 and ' + (num_rows - display_rows).to_text + ' hidden rows.'
            table + missing

    ## Prints an ASCII-art table with this data to the standard output.

       Arguments:
       - show_rows: the number of initial rows that should be displayed.

       > Example
         Convert the table to a pretty-printed representation and print it to
         the console.

             import Standard.Examples

             example_print = Examples.inventory_table.print
    print self show_rows=10 =
        IO.println (self.display show_rows format_terminal=True)
        IO.println ''

    ## Converts this table to a JSON structure.

       > Example
         Convert a table to a corresponding JSON representation.

             import Standard.Examples

             example_to_json = Examples.inventory_table.to_json
    to_json : Json
    to_json self =
        index_prep = case self.index.catch No_Index_Set_Error (_->Nothing) of
            Nothing -> []
            index -> [index]
        cols = index_prep + self.columns
        rows = 0.up_to self.row_count . map row->
            vals_kv = cols.map col-> [col.name, col.at row]
            Json.from_pairs vals_kv
        rows.to_json

    ## UNSTABLE
       ADVANCED

       Returns a Text used to display this table in the IDE by default.

       Returns a JSON object containing useful metadata and previews of column
       values.
    to_default_visualization_data : Text
    to_default_visualization_data self =
        max_size = 10
        row_count = ['number_of_rows', self.row_count]
        cols = self.columns.map c->
            name = c.name
            items = c.to_vector.take (First max_size)
            Json.from_pairs [['name', name], ['data', items]]
        Json.from_pairs [row_count, ['columns', cols]] . to_text

    ## UNSTABLE
       ADVANCED

       Guides the visualization system to display the most suitable graphical
       representation for this table.
    default_visualization : Visualization.Id.Id
    default_visualization self =
        cols = self.columns.map .name . map name-> name.to_case Case.Lower
        if cols.contains "latitude" && cols.contains "longitude" then Visualization.Id.geo_map else
            if cols.contains "x" && cols.contains "y" then Visualization.Id.scatter_plot else
                Visualization.Id.table

    ## Returns the column with the given name.

       Arguments:
       - selector: The name or index of the column being looked up.

       > Example
         Get the names of all of the items from the shop inventory.

             import Standard.Examples

             example_at = Examples.inventory_table.at "item_name"

       > Example
         Get the last column.

             import Standard.Examples

             example_at = Examples.inventory_table.at -1
    at : Text | Integer -> Column ! No_Such_Column_Error | Index_Out_Of_Bounds_Error
    at self selector=0 = case selector of
        _ : Integer ->
            java_columns = Vector.from_polyglot_array self.java_table.getColumns
            Column.Column_Data (java_columns.at selector)
        _ : Text ->
            case self.java_table.getColumnOrIndexByName selector of
                Nothing -> Error.throw (No_Such_Column_Error_Data selector)
                c -> Column.Column_Data c

    ## Returns the number of columns in the table.
    column_count : Integer
    column_count self = self.java_table.getColumns.length

    ## Returns a new table with a chosen subset of columns, as specified by the
       `columns`, from the input table. Any unmatched input columns will be
       dropped from the output.

       Arguments:
       - columns: Column selection criteria or vector of column names.
       - reorder: By default, or if set to `False`, columns in the output will
         be in the same order as in the input table. If `True`, the order in the
         output table will match the order in the columns list.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`, with the column included the first
           time it is matched.
         - If there are no columns in the output table, a `No_Output_Columns`.

       > Example
         Select columns by name.

             table.select_columns (Column_Selector.By_Name ["bar", "foo"])

       > Example
         Select columns using names passed as a Vector.

             table.select_columns ["bar", "foo"]

       > Example
         Select columns matching a regular expression.

             table.select_columns (Column_Selector.By_Name ["foo.+", "b.*"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Insensitive))

       > Example
         Select the first two columns and the last column, moving the last one to front.

             table.select_columns (Column_Selector.By_Index [-1, 0, 1]) reorder=True

       > Example
         Select columns with the same names as the ones provided.

             table.select_columns (Column_Selector.By_Column [column1, column2])

       Icon: select_column
    select_columns : Vector Text | Column_Selector -> Boolean -> Problem_Behavior -> Table
    select_columns self (columns = Column_Selector.By_Index [0]) (reorder = False) (on_problems = Report_Warning) =
        new_columns = Table_Helpers.select_columns internal_columns=self.columns selector=columns reorder=reorder on_problems=on_problems
        Table.new new_columns

    ## Returns a new table with the chosen set of columns, as specified by the
       `columns`, removed from the input table. Any unmatched input columns will
       be kept in the output. Columns are returned in the same order as in the
       input.

       Arguments:
       - columns: Column selection criteria or vector of column names to remove.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`, with the column included the first
           time it is matched.
         - If there are no columns in the output table, a `No_Output_Columns`.

       > Example
         Remove columns with given names.

             table.remove_columns (Column_Selector.By_Name ["bar", "foo"])

       > Example
         Remove columns using names passed as a Vector.

             table.remove_columns ["bar", "foo"]

       > Example
         Remove columns matching a regular expression.

             table.remove_columns (Column_Selector.By_Name ["foo.+", "b.*"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Insensitive))

       > Example
         Remove the first two columns and the last column.

             table.remove_columns (Column_Selector.By_Index [-1, 0, 1])

       > Example
         Remove columns with the same names as the ones provided.

             table.remove_columns (Column_Selector.By_Column [column1, column2])
    remove_columns : Vector Text | Column_Selector -> Problem_Behavior -> Table
    remove_columns self (columns = Column_Selector.By_Index [0]) (on_problems = Report_Warning) =
        new_columns = Table_Helpers.remove_columns internal_columns=self.columns selector=columns on_problems=on_problems
        Table.new new_columns

    ## Returns a new table with the specified selection of columns moved to
       either the start or the end in the specified order.

       Arguments:
       - columns: Column selection criteria or vector of column names which
         should be reordered and specifying their order.
       - position: Specifies how to place the selected columns in relation to
         the remaining columns which were not matched by `columns` (if any).
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`, with the column included the first
           time it is matched.

       > Example
         Move a column with a specified name to back.

             table.reorder_columns (Column_Selector.By_Name ["foo"]) position=After_Other_Columns

       > Example
         Move columns using names passed as a Vector.

             table.reorder_columns ["bar", "foo"] position=After_Other_Columns

       > Example
         Move columns matching a regular expression to front, keeping columns matching "foo.+" before columns matching "b.*".

             table.reorder_columns (Column_Selector.By_Name ["foo.+", "b.*"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Insensitive))

       > Example
         Swap the first two columns.

             table.reorder_columns (Column_Selector.By_Index [1, 0]) position=Before_Other_Columns

       > Example
         Move the first column to back.

             table.reorder_columns (Column_Selector.By_Index [0]) position=After_Other_Columns

       > Example
         Move the columns with names matching the provided columns to the front.

             table.reorder_columns (Column_Selector.By_Column [column1, column2])
    reorder_columns : Vector Text | Column_Selector -> Position.Position -> Problem_Behavior -> Table
    reorder_columns self (columns = Column_Selector.By_Index [0]) (position = Position.Before_Other_Columns) (on_problems = Report_Warning) =
        new_columns = Table_Helpers.reorder_columns internal_columns=self.columns selector=columns position=position on_problems=on_problems
        Table.new new_columns

    ## Returns a new table with the columns sorted by name according to the
       specified sort method. By default, sorting will be according to
       case-sensitive ascending order based on the `compare_to` operator for
       `Text`.

       Arguments:
       - direction: Whether sorting should be in ascending or descending order.
       - text_ordering: The sort methodology to use.

       > Example
         Sort columns according to the default ordering.

             table.sort_columns

       > Example
         Sort columns according to the natural case-insensitive ordering.

             table.sort_columns text_ordering=(Text_Ordering.Case_Insensitive sort_digits_as_numbers=True)

       > Example
         Sort columns in descending order.

             table.reorder_columns Sort_Direction.Descending
    sort_columns : Sort_Direction -> Text_Ordering -> Table
    sort_columns self direction=Sort_Direction.Ascending text_ordering=Text_Ordering.Default =
        new_columns = Table_Helpers.sort_columns internal_columns=self.columns direction text_ordering
        Table.new new_columns

    ## Returns a new table with the columns renamed based on either a mapping
       from the old name to the new or a positional list of new names.

       Arguments:
       - column_map: Mapping from old column names to new or a vector of new
         column names to apply by position.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`.
         - If in `By_Position` mode and more names than columns are provided,
           a `Too_Many_Column_Names_Provided`.
         - If any of the new names are invalid, an
           `Invalid_Output_Column_Names`.
         - If any of the new names clash either with existing names or each
           other, a Duplicate_Output_Column_Names.

       > Example
         Rename the first column to "FirstColumn"

              table.rename_columns (Column_Name_Mapping.By_Position ["FirstColumn"])

       > Example
         Rename the first column to "FirstColumn" passed as a Vector

              table.rename_columns ["FirstColumn"]
    rename_columns : Vector Text | Column_Name_Mapping -> Problem_Behavior -> Table
    rename_columns self (column_map=(Column_Name_Mapping.By_Position ["Column"])) (on_problems=Report_Warning) = case column_map of
        _ : Vector.Vector ->
            self.rename_columns (Column_Name_Mapping.By_Position column_map) on_problems
        _ ->
            new_names = Table_Helpers.rename_columns internal_columns=self.columns mapping=column_map on_problems=on_problems
            if new_names.is_error then new_names else
                new_columns = self.columns.map_with_index i->c->(c.rename (new_names.at i))
                Table.new new_columns

    ## Returns a new table with the columns renamed based on entries in the
       first row.

       Arguments:
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If any of the new names are invalid, an
           `Invalid_Output_Column_Names`.
         - If any of the new names clash either with existing names or each
           other, a Duplicate_Output_Column_Names.

       > Example
         Rename the column based on the first row

              table.use_first_row_as_names
    use_first_row_as_names : Problem_Behavior -> Table
    use_first_row_as_names self (on_problems=Report_Warning) =
        mapper = col->
            val = col.at 0
            case val of
                _ : Text -> val
                Nothing -> Nothing
                _ -> val.to_text
        new_names = self.columns.map mapper
        self.drop (First 1) . rename_columns (Column_Name_Mapping.By_Position new_names) on_problems=on_problems

    ## ALIAS group, summarize

       Aggregates the rows in a table using any `Group_By` entries in columns.
       The columns argument specifies which additional aggregations to perform and to return.

       Arguments:
       - columns: Vector of `Aggregate_Column` specifying the aggregated table.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column name is not in the input table, a `Missing_Input_Columns`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If there are no valid columns in the output table, a `No_Output_Columns`.
         - If there are invalid column names in the output table, a `Invalid_Output_Column_Names`.
         - If there are duplicate column names in the output table, a `Duplicate_Output_Column_Names`.
         - If grouping on or computing the `Mode` on a floating point number, a `Floating_Point_Grouping`.
         - If an aggregation fails, an `Invalid_Aggregation_Method`.
         - If when concatenating values there is an quoted delimited, an `Unquoted_Delimiter`
         - If there are more than 10 issues with a single column, an `Additional_Warnings`.

       > Example
         Group by the Key column, count the rows

              table.aggregate [Group_By "Key", Count Nothing]
    aggregate : [Aggregate_Column] -> Problem_Behavior -> Table
    aggregate self columns (on_problems=Report_Warning) =
        validated = Aggregate_Column_Helper.prepare_aggregate_columns columns self

        on_problems.attach_problems_before validated.problems <| Illegal_Argument_Error.handle_java_exception <|
            java_key_columns = validated.key_columns.map .java_column
            index = self.java_table.indexFromColumns java_key_columns.to_array Comparator.new

            new_columns = validated.valid_columns.map c->(Aggregate_Column_Helper.java_aggregator c.first c.second)

            java_table = index.makeTable new_columns.to_array
            new_table = Table.Table_Data java_table

            on_problems.attach_problems_after new_table <|
                problems = java_table.getProblems
                Aggregate_Column_Helper.parse_aggregated_problems problems

    ## Sorts the rows of the table according to the specified columns and order.

       Arguments:
       - columns: The columns and order to sort the table.
       - text_ordering: The ordering method to use on text values.
       - on_problems: Specifies how to handle if a problem occurs, raising as a
         warning by default. The following problems can occur:
         - If a column in `columns` is not present in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`.
         - If two name matchers match the same column, a
           `Column_Matched_By_Multiple_Selectors`.
         - If no valid columns are selected, a `No_Input_Columns_Selected`.
         - If values do not implement an ordering, an
           `Incomparable_Values_Error`.

       > Example
         Sorting `table` in ascending order by the value in column `'Quantity'`.

             table.order_by (Sort_Column_Selector.By_Name ['Quantity'])

       > Example
         Sorting `table` in descending order by the value in column `'Quantity'`.

             table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name 'Quantity' Sort_Direction.Descending])

       > Example
         Sorting `table` in ascending order by the value in column `'Quantity'`,
         using the value in column `'Rating'` for breaking ties.

             table.order_by ['Quantity', 'Rating']

       > Example
         Sorting `table` in ascending order by the value in column `'Quantity'`,
         using the value in column `'Rating'` in descending order for breaking
         ties.

             table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name 'Quantity', Sort_Column.Name 'Rating' Sort_Direction.Descending])

       > Example
         Order the table by the second column in ascending order. In case of any
         ties, break them based on the 7th column from the end of the table in
         descending order.

             table.order_by (Sort_Column_Selector.By_Index [1, Sort_Column.Index -7 Sort_Direction.Descending])

       > Example
         Sorting the shop inventory based on the per-item price in ascending
         order.

             import Standard.Examples

             example_sort = Examples.inventory_table.order_by (Sort_Column_Selector.By_Name ["price"])

       > Example
         Sort the shop inventory based on the per-item price in descending order

             import Standard.Examples

             example_sort =
                table = Examples.inventory_table
                table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "price" Sort_Direction.Descending])

       > Example
         Sort the shop inventory based on the total stock, using the number sold
         to break ties in descending order.

             import Standard.Examples

             example_sort =
                 table = Examples.inventory_table
                 table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "total_stock" Sort_Direction.Descending, Sort_Column.Name "sold_stock" Sort_Direction.Descending])

       > Example
         Sort the shop inventory in ascending order by the total stock, using
         the number of items sold in descending order to break ties.

             import Standard.Examples
             from Standard.Table import Table

             example_sort =
                 table = Examples.inventory_table
                 table.order_by (Sort_Column_Selector.By_Name ["total_stock", Sort_Column.Name "sold_stock" Sort_Direction.Descending])

    order_by : Vector Text | Sort_Column_Selector -> Text_Ordering -> Problem_Behavior -> Table ! Incomparable_Values_Error
    order_by self (columns = (Sort_Column_Selector.By_Name [(Sort_Column.Name (self.columns.at 0 . name))])) text_ordering=Text_Ordering.Default on_problems=Report_Warning =
        problem_builder = Problem_Builder.new
        columns_for_ordering = Table_Helpers.prepare_order_by self.columns columns problem_builder
        problem_builder.attach_problems_before on_problems <|
            selected_columns = columns_for_ordering.map c->c.column.java_column
            ordering = columns_for_ordering.map c->c.associated_selector.direction.to_sign
            comparator = Comparator.for_text_ordering text_ordering
            java_table = Illegal_Argument_Error.handle_java_exception <| Vector.handle_incomparable_value <|
                self.java_table.orderBy selected_columns.to_array ordering.to_array comparator
            Table.Table_Data java_table

    ## Returns the distinct set of rows within the specified columns from the
       input table.

       When multiple rows have the same values within the specified columns, the
       first row of each such set is returned.

       For the in-memory table, the unique rows will be in the order they
       occurred in the input (this is not guaranteed for database operations).

       Arguments:
       - columns: The columns of the table to use for distinguishing the rows.
       - case_sensitivity: Specifies if the text values should be compared case
         sensitively.
       - on_problems: Specifies how to handle if a problem occurs, raising as a
         warning by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`.
         - If no valid columns are selected, a `No_Input_Columns_Selected`.
         - If floating points values are present in the distinct columns, a
           `Floating_Point_Grouping` warning.
    distinct : Vector Text | Column_Selector -> Case_Sensitivity -> Problem_Behavior -> Table
    distinct self (columns = Column_Selector.By_Name (self.columns.map .name)) case_sensitivity=Case_Sensitivity.Sensitive on_problems=Report_Warning =
        warning_mapper error = case error of
            No_Output_Columns -> Maybe.Some No_Input_Columns_Selected
            _ -> Nothing
        key_columns = Warning.map_warnings_and_errors warning_mapper <|
            Table_Helpers.select_columns internal_columns=self.columns selector=columns reorder=True on_problems=on_problems
        java_columns = key_columns.map .java_column
        text_folding_strategy = Case.folding_strategy case_sensitivity
        java_table = Illegal_Argument_Error.handle_java_exception <|
            self.java_table.distinct java_columns.to_array text_folding_strategy
        on_problems.attach_problems_after (Table.Table_Data java_table) <|
            problems = java_table.getProblems
            Aggregate_Column_Helper.parse_aggregated_problems problems


    ## Parses columns within a Table to a specific value type.
       By default, it looks at all `Text` columns and attempts to deduce the
       type (columns with other types are not affected). If `column_types` are
       provided, only selected columns are parsed, according to the specified
       type.

       The default parser options only parse values where the process is
       reversible (e.g., 0123 would not be converted to an integer as there is
       a leading 0). However, settings in the `Data_Formatter` can
       control this.
    parse_values : Data_Formatter -> (Nothing | [Column_Type_Selection]) -> Problem_Behavior -> Table
    parse_values self value_formatter=Data_Formatter.Value column_types=Nothing on_problems=Report_Warning =
        columns = self.columns
        problem_builder = Vector.new_builder

        find_datatype index column =
            matching_input = column_types.filter selection->
                selector = selection.column
                case selector of
                    _ : Text -> column.name == selector
                    _ : Integer -> if selector >= 0 then index == selector else
                        index == columns.length + selector
            if matching_input.length == 0 then Nothing else
                if matching_input.length == 1 then matching_input.first.datatype else
                    first_type = matching_input.first.datatype
                    ambiguous = matching_input.exists s-> s.datatype != first_type
                    problem_builder.append (Duplicate_Type_Selector column.name ambiguous)
                    if ambiguous then Nothing else first_type

        expected_types = case column_types of
            Nothing -> columns.map _->Auto
            _ ->
                missing_columns = Vector.new_builder
                invalid_indices = Vector.new_builder
                column_types.each selection->
                    selector = selection.column
                    case selector of
                        _ : Integer ->
                            valid = Table_Helpers.is_index_valid columns.length selector
                            if valid.not then
                                invalid_indices.append selector
                        _ : Text ->
                            found = columns.exists col-> col.name == selector
                            if found.not then
                                missing_columns.append selector
                if missing_columns.is_empty.not then
                    problem_builder.append (Missing_Input_Columns missing_columns.to_vector)
                if invalid_indices.is_empty.not then
                    problem_builder.append (Column_Indexes_Out_Of_Range invalid_indices.to_vector)
                columns.map_with_index find_datatype

        new_columns = columns.zip expected_types column-> expected_type-> case expected_type of
            Nothing -> column
            _ ->
                parser = if expected_type == Auto then value_formatter.make_auto_parser else
                    value_formatter.make_datatype_parser expected_type
                storage = column.java_column.getStorage
                new_storage_and_problems = parser.parseColumn column.name storage
                new_storage = new_storage_and_problems.value
                problems = Vector.from_polyglot_array new_storage_and_problems.problems . map (Parse_Values_Helper.translate_parsing_problem expected_type)
                problems.each problem_builder.append
                Column.Column_Data (Java_Column.new column.name column.java_column.getIndex new_storage)

        ## TODO [RW] this case of is a workaround for wrong dataflow handling on arrays, it can be removed once the PR fixing it is merged, the relevant PR is:
           https://github.com/enso-org/enso/pull/3400
        result = Table.new new_columns
        on_problems.attach_problems_after result problem_builder.to_vector

    ## Replaces the first, last, or all occurrences of `term` with
       `new_text` in each text row of selected columns.
       If `term` is empty, the function returns the table unchanged.

       This method follows the exact replacement semantics of the
       `Text.replace` method.

       Arguments:
       - columns: Column selection criteria or a column name or index.
       - term: The term to find.
       - new_text: The new text to replace occurrences of `term` with.
         If `matcher` is a `Regex_Matcher`, `new_text` can include replacement
         patterns (such as `$<n>`) for a marked group.
       - mode: Specifies which occurences of term the engine tries to find. When the
         mode is `First` or `Last`, this method replaces the first or last occurence
         of term in each individual table cell. If set to `All`, it replaces all
         occurences of term.
       - matcher: If a `Text_Matcher`, the text is compared using case-sensitivity
         rules specified in the matcher. If a `Regex_Matcher`, the term is used as a
         regular expression and matched using the associated options.
       - on_problems: Specifies how to handle if a problem occurs, raising as a
         warning by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`, with the column included the first
           time it is matched.
         - If a column in columns does not have a storage type of `Text`, or `Any`,
           thus it is guaranteed that it can't contain any text values, a
           `Invalid_Value_Type`.

       > Example
         Replace dashes with underscores in a column named "variable_names".

             table.replace_text "variable_names" "-" "_"

       > Example
         Remove leading and trailing spaces from cells in multiple columns.

             table.replace_text (Column_Selector.By_Name ["foo", "bar"]) "^\s*(.*?)\s*$" "$1" matcher=Regex_Matcher.Regex_Matcher_Data

       > Example
         Replace texts in quotes with parentheses in column at index 1.

             table.replace_text 1 '"(.*?)"' '($1)' matcher=Regex_Matcher.Regex_Matcher_Data
    replace_text : (Text | Integer | Column_Selector) -> Text -> Text -> Matching_Mode | Regex_Mode -> (Text_Matcher | Regex_Matcher) -> Problem_Behavior -> Table
    replace_text self columns=(Column_Selector.By_Index [0]) term="" new_text="" mode=Regex_Mode.All matcher=Text_Matcher.Case_Sensitive on_problems=Problem_Behavior.Report_Warning = if term.is_empty then self else
        problem_builder = Problem_Builder.new

        selector = case columns of
            _ : Column_Selector -> columns
            name : Text -> Column_Selector.By_Name [name]
            index : Integer -> Column_Selector.By_Index [index]
        selection = Table_Helpers.select_columns_helper self.columns selector reorder=False problem_builder
        selected_names = Map.from_vector (selection.map column-> [column.name, True])

        map_preserve_name column f = column.map f . rename column.name
        do_replace = _.replace term new_text mode matcher
        do_replace_only_text = case _ of
                item : Text -> do_replace item
                item -> item

        transform column = case column.storage_type of
            Storage.Text -> map_preserve_name column do_replace
            Storage.Any -> map_preserve_name column do_replace_only_text
            _ ->
                problem = Invalid_Value_Type.Invalid_Value_Type_Data Value_Type.Char column.value_type
                problem_builder.report_other_warning problem
                column

        new_columns = self.columns.map column->
            is_selected = selected_names.get_or_else column.name False
            if is_selected then transform column else column

        result = Table.new new_columns
        problem_builder.attach_problems_after on_problems result

    ## ALIAS Filter Rows

       Selects only the rows of this table that correspond to `True` values of
       `filter`.

       Arguments:
       - column: The column to use for filtering. Can be a column name, index or
         the `Column` object itself.
       - filter: The filter to apply to the column. It can either be an instance
         of `Filter_Condition` or a predicate taking a cell value and returning
         a boolean value indicating whether the corresponding row should be kept
         or not.
       - on_problems: is the behavior to take when the filter cannot be applied.
         The following happens in warning mode:
         If a column name cannot be found, a `No_Such_Column_Error` warning is
         raised and the original table is returned.
         If a column index is invalid, an `Index_Out_Of_Bounds_Error` warning is
         raised and the original table is returned.
         If the column is an invalid type for the filter, an
         `Invalid_Value_Type` warning is raised and an empty table is returned.
         In error mode, the first warning is returned as a dataflow error. In
         ignore mode the same values are returned but without the warnings
         attached.

       > Example
         Get people older than 30.

             people.filter "Age" (Greater 30)

       > Example
         Filter people between 30 and 40.

             people.filter "Age" (Between 30 40)

       > Example
         Select rows where more than 50% of the stock is sold.

             table.filter "sold_stock" (Greater (table.at "total_stock" / 2))

       > Example
         Select people celebrating a jubilee.

             people.filter "age" (age -> (age%10 == 0))
    filter : (Column | Text | Integer) -> (Filter_Condition|(Any->Boolean)) -> Problem_Behavior -> Table
    filter self column filter=(Filter_Condition.Is_True) on_problems=Report_Warning = case column of
        _ : Column ->
            mask filter_column = Table.Table_Data (self.java_table.mask filter_column.java_column)
            case filter of
                _ : Filter_Condition ->
                    on_problems.handle_errors fallback=self.with_no_rows <|
                        mask (make_filter_column column filter)
                _ : Function -> mask (column.map filter)
        _ -> case on_problems.handle_errors (self.at column) fallback=Nothing of
            Nothing -> self
            resolved_column -> self.filter resolved_column filter on_problems

    ## PRIVATE
    with_no_rows self = self.take (First 0)

    ## Creates a new Table with the specified range of rows from the input
       Table.

       Arguments:
       - range: The selection of rows from the table to return.
    take : (Index_Sub_Range | Range) -> Table
    take self range=(First 1) =
        at _ = unimplemented "Table.take While cannot be implemented before the Row type is."
        Index_Sub_Range.take_helper self.row_count at self.slice (slice_ranges self) range

    ## Creates a new Table from the input with the specified range of rows
       removed.

       Arguments:
       - range: The selection of rows from the table to remove.
    drop : (Index_Sub_Range | Range) -> Table
    drop self range=(First 1) =
        at _ = unimplemented "Table.take While cannot be implemented before the Row type is."
        Index_Sub_Range.drop_helper self.row_count at self.slice (slice_ranges self) range

    ## ALIAS Add Column

       Sets the column value at the given name.

       Arguments:
       - name: The name of the column to set the value of.
       - column: The new value for the column called `name`.

       If a column with the given name already exists, it will be replaced.
       Otherwise a new column is added.

       > Example
         Create a table where the values of the total stock in the inventory is
         doubled.

             import Standard.Examples

             example_set =
                 table = Examples.inventory_table
                 double_inventory = table.at "total_stock" * 2
                 table.set "total_stock" double_inventory
    set : Text -> Column | Vector.Vector -> Table
    set self name column = case column of
        _ : Vector.Vector ->
            self.set name (Column.from_vector name column)
        Column.Column_Data _ ->
            Table.Table_Data (self.java_table.addOrReplaceColumn (column.rename name . java_column))

    ## Returns the vector of columns contained in this table.

       > Examples
         Get a vector containing the columns in the table.

             import Standard.Examples

             example_columns = Examples.inventory_table.columns
    columns : Vector
    columns self = Vector.from_polyglot_array self.java_table.getColumns . map Column.Column_Data

    ## Sets the index of this table, using the column with the provided name.

       Arguments:
       - index: The name of the column to use as the index in this table, or the
         column itself to use.

       > Example
         Set the index of the inventory table to be the item name.

             import Standard.Examples

             example_set_index = Examples.inventory_table.set_index "item_name"
    set_index : Text | Column -> Table
    set_index self index = case index of
        _ : Text -> Table.Table_Data (self.java_table.indexFromColumn index)
        Column.Column_Data c -> Table.Table_Data (self.java_table.indexFromColumn c)

    ## Returns the index of this table, as a column that is indexed by itself.

       Throws `No_Index_Set_Error` if there is no index set in the table it is
       being called on.

       > Example
         Get the column that is used as the index for a table.

             import Standard.Examples

             example_index = Examples.inventory_table.index
    index : Column ! No_Index_Set_Error
    index self = case self.java_table.getIndex.toColumn of
        Nothing -> Error.throw No_Index_Set_Error
        i -> Column.Column_Data i

    ## ALIAS Join Table

       Efficiently joins two or more tables based on either the index or the
       specified key column.

       Arguments:
       - other: The table (or vector of tables) being the right operand of this
         join operation.
       - on: The column of `self` that should be used as the join key. If this
         argument is not provided, the index of `self` will be used.
       - drop_unmatched: Whether the rows of `self` without corresponding
         matches in `other` should be dropped from the result.
       - left_suffix: A suffix that should be added to the columns of `self`
         when there's a name conflict with a column of `other`.
       - right_suffix: A suffix that should be added to the columns of `other`
         when there's a name conflict with a column of `self`.

       The resulting table contains rows of `self` extended with rows of
       `other` with matching indexes. If the index values in `other` are not
       unique, the corresponding rows of `self` will be duplicated in the
       result.

       > Example
         Join the popularity table and the inventory table to see the relative
         popularity of the items in the shop inventory.

             import Standard.Examples

             example_join =
                 Examples.inventory_table.join Examples.popularity_table

       Icon: join
    join : Vector Table | Table | Column.Column -> Text | Nothing -> Boolean -> Text -> Text -> Table
    join self other on=Nothing drop_unmatched=False left_suffix='_left' right_suffix='_right' =
        case other of
            _ : Vector.Vector -> other.fold self current->item->(current.join item on drop_unmatched left_suffix right_suffix)
            Column.Column_Data _ -> self.join other.to_table on drop_unmatched left_suffix right_suffix
            Table.Table_Data t ->
                Table.Table_Data (self.java_table.join t drop_unmatched on left_suffix right_suffix)

    ## ALIAS dropna
       ALIAS drop_missing_rows
       Remove rows which are all blank or containing blank values.

       Arguments:
       - when_any: If `True`, then remove any row containing any blank values.
         If `False`, then only remove rows with all blank values.
       - treat_nans_as_blank: If `True`, then `Number.nan` is considered as blank.

       ? Blank values
         Blank values are `Nothing`, `""` and depending on setting `Number.nan`.
    filter_blank_rows : Boolean -> Boolean -> Table
    filter_blank_rows self when_any=False treat_nans_as_blank=False =
        can_contain_text col = case col.storage_type of
            Storage.Text -> True
            Storage.Any -> True
            _ -> False
        can_contain_double col = case col.storage_type of
            Storage.Decimal -> True
            Storage.Any -> True
            _ -> False
        Table_Helpers.filter_blank_rows self can_contain_text can_contain_double when_any treat_nans_as_blank

    ## DEPRECATED Will be replaced with `Incomplete_Columns` selector (to be used with `remove_columns`).
    drop_missing_columns : Table
    drop_missing_columns self =
        non_missing = self.columns . filter (col -> col.count_missing == 0)
        index = self.java_table.getIndex
        Table.Table_Data (Java_Table.new (non_missing.map .java_column . to_array) index)

    ## Returns the number of rows in this table.

       > Example
         Count the number of rows in the table.

             import Standard.Examples

             example_row_count = Examples.inventory_table.row_count
    row_count : Integer
    row_count self = self.java_table.rowCount

    ## Returns a Table describing this table's contents.

       The table lists all columns, counts of non-null items and storage types
       of each column.

       > Example
         Get information about a table.

             import Standard.Examples

             example_info = Examples.inventory_table.info
    info : Table
    info self =
        cols = self.columns
        Table.new [["Column", cols.map .name], ["Items Count", cols.map .count], ["Storage Type", cols.map .storage_type]] . set_index "Column"

    ## UNSTABLE

       Concatenates `other` to `self`, resulting in a table with the number of rows
       being the sum of numbers of rows of `tables`. Any column that is present in
       some tables, but missing in others, will be `Nothing`-padded in the positions
       corresponding to the missing values.

       Arguments:
       - other: The table or vector of tables to concatenate to `self`.

       Any column that is present in one table, but missing in another, will be
       `Nothing`-padded in the positions corresponding to the missing column.

       > Example
         Concatenate two tables together.

             import Standard.Examples

             example_concat =
                 Examples.inventory_table.concat Examples.popularity_table
    concat : Table | Vector Table -> Table
    concat self other = case other of
        _ : Vector.Vector ->
            java_tables = Vector.new (other.length + 1) i->(if i==0 then self else other.at i).java_table
            Table.Table_Data (Java_Table.concat java_tables.to_array)
        Table.Table_Data other_java_table -> Table.Table_Data (Java_Table.concat [self.java_table, other_java_table].to_array)

    ## PRIVATE
       Returns a table with a continuous sub-range of rows taken.
    slice : Integer -> Integer -> Table
    slice self start end =
        length = self.row_count
        offset = Math.max (Math.min start length) 0
        limit = Math.max (Math.min (end - offset) (length - offset)) 0
        Table.Table_Data (self.java_table.slice offset limit)

    ## UNSTABLE

       Returns a table containing the rows of `self` table with their order
       reversed.

       > Example
         Reverse the rows in a table.

             import Standard.Examples

             example_reverse = Examples.inventory_table.reverse
    reverse : Table
    reverse self =
        mask = OrderBuilder.buildReversedMask self.row_count
        Table.Table_Data <| self.java_table.applyMask mask

    ## ALIAS Write JSON
       UNSTABLE

       Writes this table to a specified file, serialized into JSON. The JSON
       serialization is such that the result is an array, in which every entry
       is an object representing a single row, with column names as keys.

       Arguments:
       - file: the file to write data to. If the file exists, it will be
         overwritten.

       > Example
         Write a table to a JSON file.

             import Standard.Examples

             example_to_json = Examples.inventory_table.write_json (enso_project.data / 'example.json')
    write_json : File.File -> Nothing
    write_json self file = self.to_json.to_text.write file

    ## This function writes a table from memory into a file.

       The specific behavior of the various `File_Format`s is specified below.

       Arguments:
       - path: The path to the output file.
       - format: The format of the file.
         If `Auto_Detect` is specified; the provided file determines the
         specific type and configures it appropriately. Details of this type are
         below.
       - on_existing_file: Specified how to handle if the file already exists.
       - match_columns: Specifies how to match columns against an existing file.
         If `Match_Columns.By_Name` - the columns are mapped by name against an
         existing file. If there is a mismatch, then a `Column_Name_Mismatch`
         error is raised.
         If `Match_Columns.By_Position` - the columns are mapped by position
         against an existing file. If there is a mismatch, then a
         `Column_Count_Mismatch` error is raised.
       - on_problems: Specifies how to handle if a problem occurs, raising as a
         warning by default. The specific issues depend on the `File_Format`
         argument.

       Returns:
       - If an unsupported `File_Format` is specified, an
         `Illegal_Argument_Error` is raised.
       - If the path to the parent location cannot be found or the filename is
         invalid, a `File_Not_Found` is raised.
       - If another IO error occurs, such as access denied, an `IO_Error` is
         raised.
       - If appending and the columns do not match, a `Column_Mismatch` is
         raised.
       - Other specific errors or warnings that can be raised depend on the
         format argument.
       - Otherwise, the file is loaded following the rules of the format
         parameter.

       ? `File_Format` write behaviors

         - `Auto_Detect`: The file format is determined by the provided file.
         - `Bytes` and `Plain_Text`: The Table does not support these types in
           the `write` function. If passed as format, an
           `Illegal_Argument_Error` is raised. To write out the table as plain
           text, the user needs to call the `Text.from Table` method and then
           use the `Text.write` function.

       > Example
         Write a table to a CSV file, without writing the header.

             import Standard.Examples
             from Standard.Table import Delimited

             example_to_csv = Examples.inventory_table.write (Enso_Project.data / "example_csv_output.csv") (Delimited delimiter="," headers=False)

       > Example
         Write a table to an XLSX file.

             import Standard.Examples
             from Standard.Table import Excel

             example_to_xlsx = Examples.inventory_table.write (enso_project.data / "example_xlsx_output.xlsx") Excel
    write : File|Text -> File_Format -> Existing_File_Behavior -> Match_Columns -> Problem_Behavior -> Nothing ! Column_Mismatch | Illegal_Argument_Error | File_Not_Found | IO_Error
    write self path format=Auto_Detect on_existing_file=Existing_File_Behavior.Backup match_columns=Match_Columns.By_Name on_problems=Report_Warning =
        format.write_table (File.new path) self on_existing_file match_columns on_problems

    ## Creates a text representation of the table using the CSV format.
    to_csv : Text
    to_csv self = Text.from self (Delimited delimiter=",")

## UNSTABLE

   An error returned when the table contains no rows.
type Empty_Error
    ## PRIVATE

       Pretty prints the empty table error.
    to_display_text : Text
    to_display_text self = "The table is empty."

## PRIVATE

   Ensures that the `txt` has at least `len` characters by appending spaces at
   the end.

   Arguments:
   - txt: The text to pad.
   - len: The minimum length of the text.
pad : Text -> Integer -> Text
pad txt len =
    true_len = txt.characters.length
    txt + (" ".repeat (len - true_len))

## PRIVATE

   Adds ANSI bold escape sequences to text if the feature is enabled.

   Arguments:
   - enabled: will insert ANSI sequences only if this flag is true and we are not on Windows.
   - txt: The text to possibly bold.
ansi_bold : Boolean -> Text -> Text
ansi_bold enabled txt =
    case Platform.os of
        ## Output formatting for Windows is not currently supported.
        Platform.Windows -> txt
        _ -> if enabled then '\e[1m' + txt + '\e[m' else txt

## PRIVATE

   A helper function for creating an ASCII-art representation of tabular data.

   Arguments:
   - header: vector of names of columns in the table.
   - rows: a vector of rows, where each row is a vector that contains a text
     representation of each cell
   - indices_count: the number specifying how many columns should be treated as
     indices; this will make them in bold font if `format_term` is enabled.
   - format_term: a boolean flag, specifying whether to use ANSI escape codes
     for rich formatting in the terminal.
print_table : Vector Text -> (Vector (Vector Text)) -> Integer -> Boolean -> Text
print_table header rows indices_count format_term =
    content_lengths = Vector.new header.length i->
        max_row = 0.up_to rows.length . fold 0 a-> j-> Math.max a (rows.at j . at i . characters . length)
        Math.max max_row (header.at i . characters . length)
    header_line = header.zip content_lengths pad . map (ansi_bold format_term) . join ' | '
    divider = content_lengths . map (l -> "-".repeat l+2) . join '+'
    row_lines = rows.map r->
        x = r.zip content_lengths pad
        ixes = x.take (First indices_count) . map (ansi_bold format_term)
        with_bold_ix = ixes + x.drop (First indices_count)
        y = with_bold_ix . join ' | '
        " " + y
    ([" " + header_line, divider] + row_lines).join '\n'

## PRIVATE
   A helper to create a new table consisting of slices of the original table.
slice_ranges table ranges =
    normalized = Index_Sub_Range.normalize_ranges ranges
    Table.Table_Data (table.java_table.slice normalized.to_array)
