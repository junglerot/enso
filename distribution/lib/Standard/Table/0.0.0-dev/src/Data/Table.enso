from Standard.Base import all
import Standard.Base.Data.Index_Sub_Range as Index_Sub_Range_Module
import Standard.Base.Data.Array_Proxy.Array_Proxy
import Standard.Base.Data.Ordering.Comparator
import Standard.Base.Error.Common.Index_Out_Of_Bounds
import Standard.Base.Error.Common.No_Such_Method
import Standard.Base.Error.Common.Type_Error
import Standard.Base.Error.File_Error.File_Error
import Standard.Base.Error.Illegal_Argument.Illegal_Argument
import Standard.Base.Error.Incomparable_Values.Incomparable_Values
import Standard.Base.Error.Unimplemented.Unimplemented

import project.Data.Column.Column
import project.Data.Column_Name_Mapping.Column_Name_Mapping
import project.Data.Column_Selector.Column_Selector
import project.Data.Data_Formatter.Data_Formatter
import project.Data.Join_Condition.Join_Condition
import project.Data.Join_Kind.Join_Kind
import project.Data.Match_Columns.Match_Columns
import project.Data.Position.Position
import project.Data.Storage.Storage
import project.Data.Value_Type.Value_Type
import project.Data.Sort_Column_Selector.Sort_Column_Selector
import project.Data.Sort_Column.Sort_Column
import project.Data.Aggregate_Column.Aggregate_Column
import project.Data.Storage.Storage
import project.Internal.Aggregate_Column_Helper
import project.Internal.Join_Helpers
import project.Internal.Table_Helpers
import project.Internal.Table_Helpers.Table_Column_Helper
import project.Internal.Parse_Values_Helper
import project.Internal.Problem_Builder.Problem_Builder
import project.Internal.Unique_Name_Strategy.Unique_Name_Strategy
import project.Data.Expression.Expression
import project.Data.Expression.Expression_Error
import project.Delimited.Delimited_Format.Delimited_Format

from project.Data.Column_Type_Selection import Column_Type_Selection, Auto
from project.Internal.Rows_View import Rows_View
from project.Errors import Missing_Input_Columns, Column_Indexes_Out_Of_Range, Duplicate_Type_Selector, No_Index_Set_Error, No_Such_Column, No_Input_Columns_Selected, No_Output_Columns, Invalid_Value_Type

from project.Data.Column import get_item_string
from project.Internal.Filter_Condition_Helpers import make_filter_column

polyglot java import org.enso.table.data.table.Table as Java_Table
polyglot java import org.enso.table.data.table.Column as Java_Column
polyglot java import org.enso.table.data.table.join.Equals as Java_Join_Equals
polyglot java import org.enso.table.data.table.join.EqualsIgnoreCase as Java_Join_Equals_Ignore_Case
polyglot java import org.enso.table.data.table.join.Between as Java_Join_Between
polyglot java import org.enso.table.operations.OrderBuilder
polyglot java import org.enso.table.data.mask.OrderMask
polyglot java import java.util.UUID

## Represents a column-oriented table data structure.
type Table
    ## Creates a new table from a vector of `[name, items]` pairs.

       Arguments:
       - columns: The `[name, items]` pairs to construct a new table from.

       > Example
         Create a new table with the given columns.

             from Standard.Table import Table

             example_new =
                 first_column = ["count", [1, 2, 3]]
                 second_column = ["is_valid", [True, False, True]]
                 Table.new [first_column, second_column]
    new : Vector (Vector | Column) -> Table
    new columns =
        cols = columns.map c->
            case c of
                _ : Vector -> Column.from_vector (c.at 0) (c.at 1) . java_column
                Column.Value java_col -> java_col
        # TODO enable this once we stop returning tables without columns
        # if cols.is_empty then Error.throw (Illegal_Argument.Error "Cannot create a table with no columns.") else
        if (cols.all c-> c.getSize == cols.first.getSize).not then Error.throw (Illegal_Argument.Error "All columns must have the same row count.") else
            if cols.distinct .getName . length != cols.length then Error.throw (Illegal_Argument.Error "Column names must be distinct.") else
                Table.Value (Java_Table.new cols.to_array)

    ## Creates a new table from a vector of column names and a vector of vectors
       specifying row contents.

       Arguments:
       - header: A list of texts specifying the column names
       - rows: A vector of vectors, specifying the contents of each table row. The
         length of each element of `rows` must be equal in length to `header`.

       > Example
         Create a table with 3 columns, named `foo`, `bar`, and `baz`, containing
         `[1, 2, 3]`, `[True, False, True]`, and `['a', 'b', 'c']`, respectively.

             from Standard.Table import Table

             example_from_rows =
                 header = [ 'foo' , 'bar' , 'baz' ]
                 row_1 =  [ 1     , True  , 'a'   ]
                 row_2 =  [ 2     , False , 'b'   ]
                 row_3 =  [ 3     , True  , 'c'   ]
                 Table.from_rows header [row_1, row_2, row_3]
    from_rows : Vector -> Vector -> Table
    from_rows header rows =
        columns = header.map_with_index i-> name-> [name, rows.map (_.at i)]
        Table.new columns

    ## PRIVATE

       A table.

       Arguments:
       - java_table: The internal java representation of the table.
    Value java_table

    ## Returns a text containing an ASCII-art table displaying this data.

       Arguments:
       - show_rows: the number of initial rows that should be displayed.
       - format_terminal: whether ANSI-terminal formatting should be used

       > Example
         Convert the table to a pretty-printed representation.

             import Standard.Examples

             example_display = Examples.inventory_table.display
    display : Integer -> Boolean -> Text
    display self show_rows=10 format_terminal=False =
        cols = Vector.from_polyglot_array self.java_table.getColumns
        index =  self.java_table.getIndex
        col_names = [index.getName] + cols.map .getName
        col_vals = cols.map .getStorage
        num_rows = self.row_count
        display_rows = Math.min num_rows show_rows
        rows = Vector.new display_rows row_num->
            cols = col_vals.map col->
                if col.isNa row_num then "Nothing" else get_item_string col row_num
            [index.ilocString row_num] + cols
        table = print_table col_names rows 1 format_terminal
        if num_rows - display_rows <= 0 then table else
            missing = '\n\u2026 and ' + (num_rows - display_rows).to_text + ' hidden rows.'
            table + missing

    ## Prints an ASCII-art table with this data to the standard output.

       Arguments:
       - show_rows: the number of initial rows that should be displayed.

       > Example
         Convert the table to a pretty-printed representation and print it to
         the console.

             import Standard.Examples

             example_print = Examples.inventory_table.print
    print self show_rows=10 =
        IO.println (self.display show_rows format_terminal=True)
        IO.println ''

    ## Converts this table into a JS_Object.

       > Example
         Convert a table to a corresponding JavaScript JS_Object representation.

             import Standard.Examples

             example_to_json = Examples.inventory_table.to_js_object
    to_js_object : JS_Object
    to_js_object self =
        index_prep = case self.index.catch No_Index_Set_Error (_->Nothing) of
            Nothing -> []
            index -> [index]
        cols = index_prep + self.columns
        rows = 0.up_to self.row_count . map row->
            vals_kv = cols.map col-> [col.name, col.at row]
            JS_Object.from_pairs vals_kv
        rows

    ## Returns the column with the given name.

       Arguments:
       - selector: The name or index of the column being looked up.

       > Example
         Get the names of all of the items from the shop inventory.

             import Standard.Examples

             example_at = Examples.inventory_table.at "item_name"

       > Example
         Get the last column.

             import Standard.Examples

             example_at = Examples.inventory_table.at -1
    at : Text | Integer -> Column ! No_Such_Column | Index_Out_Of_Bounds
    at self selector=0 = case selector of
        _ : Integer ->
            java_columns = Vector.from_polyglot_array self.java_table.getColumns
            Column.Value (java_columns.at selector)
        _ : Text ->
            case self.java_table.getColumnOrIndexByName selector of
                Nothing -> Error.throw (No_Such_Column.Error selector)
                c -> Column.Value c

    ## Returns the number of columns in the table.
    column_count : Integer
    column_count self = self.java_table.getColumns.length

    ## Returns a new table with a chosen subset of columns, as specified by the
       `columns`, from the input table. Any unmatched input columns will be
       dropped from the output.

       Arguments:
       - columns: Column selection criteria or vector of column names.
       - reorder: By default, or if set to `False`, columns in the output will
         be in the same order as in the input table. If `True`, the order in the
         output table will match the order in the columns list.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`, with the column included the first
           time it is matched.
         - If there are no columns in the output table, a `No_Output_Columns`.

       > Example
         Select columns by name.

             table.select_columns (Column_Selector.By_Name ["bar", "foo"])

       > Example
         Select columns using names passed as a Vector.

             table.select_columns ["bar", "foo"]

       > Example
         Select columns matching a regular expression.

             table.select_columns (Column_Selector.By_Name ["foo.+", "b.*"] (Regex_Matcher.Value case_sensitivity=Case_Sensitivity.Insensitive))

       > Example
         Select the first two columns and the last column, moving the last one to front.

             table.select_columns (Column_Selector.By_Index [-1, 0, 1]) reorder=True

       > Example
         Select columns with the same names as the ones provided.

             table.select_columns (Column_Selector.By_Column [column1, column2])

       Icon: select_column
    select_columns : Vector Text | Column_Selector -> Boolean -> Problem_Behavior -> Table
    select_columns self (columns = Column_Selector.By_Index [0]) (reorder = False) (on_problems = Report_Warning) =
        new_columns = self.columns_helper.select_columns selector=columns reorder=reorder on_problems=on_problems
        Table.new new_columns

    ## Returns a new table with the chosen set of columns, as specified by the
       `columns`, removed from the input table. Any unmatched input columns will
       be kept in the output. Columns are returned in the same order as in the
       input.

       Arguments:
       - columns: Column selection criteria or vector of column names to remove.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`, with the column included the first
           time it is matched.
         - If there are no columns in the output table, a `No_Output_Columns`.

       > Example
         Remove columns with given names.

             table.remove_columns (Column_Selector.By_Name ["bar", "foo"])

       > Example
         Remove columns using names passed as a Vector.

             table.remove_columns ["bar", "foo"]

       > Example
         Remove columns matching a regular expression.

             table.remove_columns (Column_Selector.By_Name ["foo.+", "b.*"] (Regex_Matcher.Value case_sensitivity=Case_Sensitivity.Insensitive))

       > Example
         Remove the first two columns and the last column.

             table.remove_columns (Column_Selector.By_Index [-1, 0, 1])

       > Example
         Remove columns with the same names as the ones provided.

             table.remove_columns (Column_Selector.By_Column [column1, column2])
    remove_columns : Vector Text | Column_Selector -> Problem_Behavior -> Table
    remove_columns self (columns = Column_Selector.By_Index [0]) (on_problems = Report_Warning) =
        new_columns = self.columns_helper.remove_columns selector=columns on_problems=on_problems
        Table.new new_columns

    ## Returns a new table with the specified selection of columns moved to
       either the start or the end in the specified order.

       Arguments:
       - columns: Column selection criteria or vector of column names which
         should be reordered and specifying their order.
       - position: Specifies how to place the selected columns in relation to
         the remaining columns which were not matched by `columns` (if any).
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`, with the column included the first
           time it is matched.

       > Example
         Move a column with a specified name to back.

             table.reorder_columns (Column_Selector.By_Name ["foo"]) position=After_Other_Columns

       > Example
         Move columns using names passed as a Vector.

             table.reorder_columns ["bar", "foo"] position=After_Other_Columns

       > Example
         Move columns matching a regular expression to front, keeping columns matching "foo.+" before columns matching "b.*".

             table.reorder_columns (Column_Selector.By_Name ["foo.+", "b.*"] (Regex_Matcher.Value case_sensitivity=Case_Sensitivity.Insensitive))

       > Example
         Swap the first two columns.

             table.reorder_columns (Column_Selector.By_Index [1, 0]) position=Before_Other_Columns

       > Example
         Move the first column to back.

             table.reorder_columns (Column_Selector.By_Index [0]) position=After_Other_Columns

       > Example
         Move the columns with names matching the provided columns to the front.

             table.reorder_columns (Column_Selector.By_Column [column1, column2])
    reorder_columns : Vector Text | Column_Selector -> Position -> Problem_Behavior -> Table
    reorder_columns self (columns = Column_Selector.By_Index [0]) (position = Position.Before_Other_Columns) (on_problems = Report_Warning) =
        new_columns = self.columns_helper.reorder_columns selector=columns position=position on_problems=on_problems
        Table.new new_columns

    ## Returns a new table with the columns sorted by name according to the
       specified sort method. By default, sorting will be according to
       case-sensitive ascending order based on the `compare_to` operator for
       `Text`.

       Arguments:
       - direction: Whether sorting should be in ascending or descending order.
       - text_ordering: The sort methodology to use.

       > Example
         Sort columns according to the default ordering.

             table.sort_columns

       > Example
         Sort columns according to the natural case-insensitive ordering.

             table.sort_columns text_ordering=(Text_Ordering.Case_Insensitive sort_digits_as_numbers=True)

       > Example
         Sort columns in descending order.

             table.reorder_columns Sort_Direction.Descending
    sort_columns : Sort_Direction -> Text_Ordering -> Table
    sort_columns self direction=Sort_Direction.Ascending text_ordering=Text_Ordering.Default =
        new_columns = Table_Helpers.sort_columns internal_columns=self.columns direction text_ordering
        Table.new new_columns

    ## Returns a new table with the columns renamed based on either a mapping
       from the old name to the new or a positional list of new names.

       Arguments:
       - column_map: Mapping from old column names to new or a vector of new
         column names to apply by position.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`.
         - If in `By_Position` mode and more names than columns are provided,
           a `Too_Many_Column_Names_Provided`.
         - If any of the new names are invalid, an
           `Invalid_Output_Column_Names`.
         - If any of the new names clash either with existing names or each
           other, a Duplicate_Output_Column_Names.

       > Example
         Rename the first column to "FirstColumn"

              table.rename_columns (Column_Name_Mapping.By_Position ["FirstColumn"])

       > Example
         Rename the first column to "FirstColumn" passed as a Vector

              table.rename_columns ["FirstColumn"]
    rename_columns : Map | Vector Text | Column_Name_Mapping -> Problem_Behavior -> Table
    rename_columns self (column_map=(Column_Name_Mapping.By_Position ["Column"])) (on_problems=Report_Warning) = case column_map of
        _ : Vector ->
            self.rename_columns (Column_Name_Mapping.By_Position column_map) on_problems
        _ : Map ->
            self.rename_columns (Column_Name_Mapping.By_Name column_map) on_problems
        _ ->
            new_names = Table_Helpers.rename_columns internal_columns=self.columns mapping=column_map on_problems=on_problems
            if new_names.is_error then new_names else
                new_columns = self.columns.map_with_index i->c->(c.rename (new_names.at i))
                Table.new new_columns

    ## Returns a new table with the columns renamed based on entries in the
       first row.

       Arguments:
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If any of the new names are invalid, an
           `Invalid_Output_Column_Names`.
         - If any of the new names clash either with existing names or each
           other, a Duplicate_Output_Column_Names.

       > Example
         Rename the column based on the first row

              table.use_first_row_as_names
    use_first_row_as_names : Problem_Behavior -> Table
    use_first_row_as_names self (on_problems=Report_Warning) =
        mapper = col->
            val = col.at 0
            case val of
                _ : Text -> val
                Nothing -> Nothing
                _ -> val.to_text
        new_names = self.columns.map mapper
        self.drop (First 1) . rename_columns (Column_Name_Mapping.By_Position new_names) on_problems=on_problems

    ## ALIAS group, summarize

       Aggregates the rows in a table using any `Group_By` entries in columns.
       The columns argument specifies which additional aggregations to perform and to return.

       Arguments:
       - columns: Vector of `Aggregate_Column` specifying the aggregated table.
         Expressions can be used within the aggregate column to perform more
         complicated calculations.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column name is not in the input table, a `Missing_Input_Columns`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If there are no valid columns in the output table, a `No_Output_Columns`.
         - If there are invalid column names in the output table, a `Invalid_Output_Column_Names`.
         - If there are duplicate column names in the output table, a `Duplicate_Output_Column_Names`.
         - If grouping on or computing the `Mode` on a floating point number, a `Floating_Point_Grouping`.
         - If an aggregation fails, an `Invalid_Aggregation`.
         - If when concatenating values there is an quoted delimited, an `Unquoted_Delimiter`
         - If there are more than 10 issues with a single column, an `Additional_Warnings`.

       > Example
         Group by the Key column, count the rows

              table.aggregate [Group_By "Key", Count Nothing]
    aggregate : Vector Aggregate_Column -> Problem_Behavior -> Table
    aggregate self columns (on_problems=Report_Warning) =
        validated = Aggregate_Column_Helper.prepare_aggregate_columns columns self

        on_problems.attach_problems_before validated.problems <| Illegal_Argument.handle_java_exception <|
            java_key_columns = validated.key_columns.map .java_column
            index = self.java_table.indexFromColumns java_key_columns.to_array

            new_columns = validated.valid_columns.map c->(Aggregate_Column_Helper.java_aggregator c.first c.second)

            java_table = index.makeTable new_columns.to_array
            new_table = Table.Value java_table

            on_problems.attach_problems_after new_table <|
                problems = java_table.getProblems
                Aggregate_Column_Helper.parse_aggregated_problems problems

    ## Sorts the rows of the table according to the specified columns and order.

       Arguments:
       - columns: The columns and order to sort the table.
       - text_ordering: The ordering method to use on text values.
       - on_problems: Specifies how to handle if a problem occurs, raising as a
         warning by default. The following problems can occur:
         - If a column in `columns` is not present in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`.
         - If two name matchers match the same column, a
           `Column_Matched_By_Multiple_Selectors`.
         - If no valid columns are selected, a `No_Input_Columns_Selected`.
         - If values do not implement an ordering, an
           `Incomparable_Values`.

       > Example
         Sorting `table` in ascending order by the value in column `'Quantity'`.

             table.order_by (Sort_Column_Selector.By_Name ['Quantity'])

       > Example
         Sorting `table` in descending order by the value in column `'Quantity'`.

             table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name 'Quantity' Sort_Direction.Descending])

       > Example
         Sorting `table` in ascending order by the value in column `'Quantity'`,
         using the value in column `'Rating'` for breaking ties.

             table.order_by ['Quantity', 'Rating']

       > Example
         Sorting `table` in ascending order by the value in column `'Quantity'`,
         using the value in column `'Rating'` in descending order for breaking
         ties.

             table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name 'Quantity', Sort_Column.Name 'Rating' Sort_Direction.Descending])

       > Example
         Order the table by the second column in ascending order. In case of any
         ties, break them based on the 7th column from the end of the table in
         descending order.

             table.order_by (Sort_Column_Selector.By_Index [1, Sort_Column.Index -7 Sort_Direction.Descending])

       > Example
         Sorting the shop inventory based on the per-item price in ascending
         order.

             import Standard.Examples

             example_sort = Examples.inventory_table.order_by (Sort_Column_Selector.By_Name ["price"])

       > Example
         Sort the shop inventory based on the per-item price in descending order

             import Standard.Examples

             example_sort =
                table = Examples.inventory_table
                table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "price" Sort_Direction.Descending])

       > Example
         Sort the shop inventory based on the total stock, using the number sold
         to break ties in descending order.

             import Standard.Examples

             example_sort =
                 table = Examples.inventory_table
                 table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "total_stock" Sort_Direction.Descending, Sort_Column.Name "sold_stock" Sort_Direction.Descending])

       > Example
         Sort the shop inventory in ascending order by the total stock, using
         the number of items sold in descending order to break ties.

             import Standard.Examples
             from Standard.Table import Table

             example_sort =
                 table = Examples.inventory_table
                 table.order_by (Sort_Column_Selector.By_Name ["total_stock", Sort_Column.Name "sold_stock" Sort_Direction.Descending])

    order_by : Text | Sort_Column | Vector (Text | Sort_Column) | Sort_Column_Selector -> Text_Ordering -> Problem_Behavior -> Table ! Incomparable_Values
    order_by self (columns = (Sort_Column_Selector.By_Name [(Sort_Column.Name (self.columns.at 0 . name))])) text_ordering=Text_Ordering.Default on_problems=Report_Warning =
        problem_builder = Problem_Builder.new
        columns_for_ordering = Table_Helpers.prepare_order_by self.columns columns problem_builder
        problem_builder.attach_problems_before on_problems <|
            selected_columns = columns_for_ordering.map c->c.column.java_column
            ordering = columns_for_ordering.map c->c.associated_selector.direction.to_sign
            comparator = Comparator.for_text_ordering text_ordering
            java_table = Illegal_Argument.handle_java_exception <| Incomparable_Values.handle_errors <|
                self.java_table.orderBy selected_columns.to_array ordering.to_array comparator
            Table.Value java_table

    ## Returns the distinct set of rows within the specified columns from the
       input table.

       When multiple rows have the same values within the specified columns, the
       first row of each such set is returned.

       For the in-memory table, the unique rows will be in the order they
       occurred in the input (this is not guaranteed for database operations).

       Arguments:
       - columns: The columns of the table to use for distinguishing the rows.
       - case_sensitivity: Specifies if the text values should be compared case
         sensitively.
       - on_problems: Specifies how to handle if a problem occurs, raising as a
         warning by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`.
         - If no valid columns are selected, a `No_Input_Columns_Selected`.
         - If floating points values are present in the distinct columns, a
           `Floating_Point_Grouping` warning.
    distinct : Vector Text | Column_Selector -> Case_Sensitivity -> Problem_Behavior -> Table
    distinct self (columns = Column_Selector.By_Name (self.columns.map .name)) case_sensitivity=Case_Sensitivity.Sensitive on_problems=Report_Warning =
        warning_mapper error = case error of
            No_Output_Columns -> Maybe.Some No_Input_Columns_Selected
            _ -> Nothing
        key_columns = Warning.map_warnings_and_errors warning_mapper <|
            self.columns_helper.select_columns selector=columns reorder=True on_problems=on_problems
        java_columns = key_columns.map .java_column
        text_folding_strategy = Case_Sensitivity.folding_strategy case_sensitivity
        java_table = Illegal_Argument.handle_java_exception <|
            self.java_table.distinct java_columns.to_array text_folding_strategy
        on_problems.attach_problems_after (Table.Value java_table) <|
            problems = java_table.getProblems
            Aggregate_Column_Helper.parse_aggregated_problems problems


    ## Parses columns within a Table to a specific value type.
       By default, it looks at all `Text` columns and attempts to deduce the
       type (columns with other types are not affected). If `column_types` are
       provided, only selected columns are parsed, according to the specified
       type.

       The default parser options only parse values where the process is
       reversible (e.g., 0123 would not be converted to an integer as there is
       a leading 0). However, settings in the `Data_Formatter` can
       control this.
    parse_values : Data_Formatter -> (Nothing | Vector Column_Type_Selection) -> Problem_Behavior -> Table
    parse_values self value_formatter=Data_Formatter.Value column_types=Nothing on_problems=Report_Warning =
        columns = self.columns
        problem_builder = Vector.new_builder

        find_datatype index column =
            matching_input = column_types.filter selection->
                selector = selection.column
                case selector of
                    _ : Text -> column.name == selector
                    _ : Integer -> if selector >= 0 then index == selector else
                        index == columns.length + selector
            if matching_input.length == 0 then Nothing else
                if matching_input.length == 1 then matching_input.first.datatype else
                    first_type = matching_input.first.datatype
                    ambiguous = matching_input.exists s-> s.datatype != first_type
                    problem_builder.append (Duplicate_Type_Selector.Error column.name ambiguous)
                    if ambiguous then Nothing else first_type

        expected_types = case column_types of
            Nothing -> columns.map _->Auto
            _ ->
                missing_columns = Vector.new_builder
                invalid_indices = Vector.new_builder
                column_types.each selection->
                    selector = selection.column
                    case selector of
                        _ : Integer ->
                            valid = Table_Helpers.is_index_valid columns.length selector
                            if valid.not then
                                invalid_indices.append selector
                        _ : Text ->
                            found = columns.exists col-> col.name == selector
                            if found.not then
                                missing_columns.append selector
                if missing_columns.is_empty.not then
                    problem_builder.append (Missing_Input_Columns.Error missing_columns.to_vector)
                if invalid_indices.is_empty.not then
                    problem_builder.append (Column_Indexes_Out_Of_Range.Error invalid_indices.to_vector)
                columns.map_with_index find_datatype

        new_columns = columns.zip expected_types column-> expected_type-> case expected_type of
            Nothing -> column
            _ ->
                parser = if expected_type == Auto then value_formatter.make_auto_parser else
                    value_formatter.make_datatype_parser expected_type
                storage = column.java_column.getStorage
                new_storage_and_problems = parser.parseColumn column.name storage
                new_storage = new_storage_and_problems.value
                problems = Vector.from_polyglot_array new_storage_and_problems.problems . map (Parse_Values_Helper.translate_parsing_problem expected_type)
                problems.each problem_builder.append
                Column.Value (Java_Column.new column.name column.java_column.getIndex new_storage)

        ## TODO [RW] this case of is a workaround for wrong dataflow handling on arrays, it can be removed once the PR fixing it is merged, the relevant PR is:
           https://github.com/enso-org/enso/pull/3400
        result = Table.new new_columns
        on_problems.attach_problems_after result problem_builder.to_vector

    ## Replaces the first, last, or all occurrences of `term` with
       `new_text` in each text row of selected columns.
       If `term` is empty, the function returns the table unchanged.

       This method follows the exact replacement semantics of the
       `Text.replace` method.

       Arguments:
       - columns: Column selection criteria or a column name or index.
       - term: The term to find.
       - new_text: The new text to replace occurrences of `term` with.
         If `matcher` is a `Regex_Matcher`, `new_text` can include replacement
         patterns (such as `$<n>`) for a marked group.
       - mode: Specifies which occurences of term the engine tries to find. When the
         mode is `First` or `Last`, this method replaces the first or last occurence
         of term in each individual table cell. If set to `All`, it replaces all
         occurences of term.
       - matcher: If a `Text_Matcher`, the text is compared using case-sensitivity
         rules specified in the matcher. If a `Regex_Matcher`, the term is used as a
         regular expression and matched using the associated options.
       - on_problems: Specifies how to handle if a problem occurs, raising as a
         warning by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`, with the column included the first
           time it is matched.
         - If a column in columns does not have a storage type of `Text`, or `Any`,
           thus it is guaranteed that it can't contain any text values, a
           `Invalid_Value_Type`.

       > Example
         Replace dashes with underscores in a column named "variable_names".

             table.replace_text "variable_names" "-" "_"

       > Example
         Remove leading and trailing spaces from cells in multiple columns.

             table.replace_text (Column_Selector.By_Name ["foo", "bar"]) "^\s*(.*?)\s*$" "$1" matcher=Regex_Matcher.Value

       > Example
         Replace texts in quotes with parentheses in column at index 1.

             table.replace_text 1 '"(.*?)"' '($1)' matcher=Regex_Matcher.Value
    replace_text : (Text | Integer | Column_Selector) -> Text -> Text -> Matching_Mode.First | Matching_Mode.Last | Regex_Mode -> (Text_Matcher | Regex_Matcher) -> Problem_Behavior -> Table
    replace_text self columns=(Column_Selector.By_Index [0]) term="" new_text="" mode=Regex_Mode.All matcher=Text_Matcher.Case_Sensitive on_problems=Problem_Behavior.Report_Warning = if term.is_empty then self else
        problem_builder = Problem_Builder.new

        selector = case columns of
            _ : Column_Selector -> columns
            name : Text -> Column_Selector.By_Name [name]
            index : Integer -> Column_Selector.By_Index [index]
        selection = self.columns_helper.select_columns_helper selector reorder=False problem_builder
        selected_names = Map.from_vector (selection.map column-> [column.name, True])

        map_preserve_name column f = column.map f . rename column.name
        do_replace = _.replace term new_text mode matcher
        do_replace_only_text = case _ of
                item : Text -> do_replace item
                item -> item

        transform column = case column.storage_type of
            Storage.Text -> map_preserve_name column do_replace
            Storage.Any -> map_preserve_name column do_replace_only_text
            _ ->
                problem = Invalid_Value_Type.Error Value_Type.Char column.value_type
                problem_builder.report_other_warning problem
                column

        new_columns = self.columns.map column->
            is_selected = selected_names.get column.name False
            if is_selected then transform column else column

        result = Table.new new_columns
        problem_builder.attach_problems_after on_problems result

    ## ALIAS Filter Rows

       Selects only the rows of this table that correspond to `True` values of
       `filter`.

       Arguments:
       - column: The column to use for filtering. Can be a column name, index or
         the `Column` object itself.
       - filter: The filter to apply to the column. It can either be an instance
         of `Filter_Condition` or a predicate taking a cell value and returning
         a boolean value indicating whether the corresponding row should be kept
         or not.
       - on_problems: is the behavior to take when the filter cannot be applied.
         The following happens in warning mode:
         If a column name cannot be found, a `No_Such_Column` warning is
         raised and the original table is returned.
         If a column index is invalid, an `Index_Out_Of_Bounds` warning is
         raised and the original table is returned.
         If the column is an invalid type for the filter, an
         `Invalid_Value_Type` warning is raised and an empty table is returned.
         In error mode, the first warning is returned as a dataflow error. In
         ignore mode the same values are returned but without the warnings
         attached.

       > Example
         Get people older than 30.

             people.filter "Age" (Greater 30)

       > Example
         Filter people between 30 and 40.

             people.filter "Age" (Between 30 40)

       > Example
         Select rows where more than 50% of the stock is sold.

             table.filter "sold_stock" (Greater (table.at "total_stock" / 2))

       > Example
         Select people celebrating a jubilee.

             people.filter "age" (age -> (age%10 == 0))
    filter : (Column | Text | Integer) -> (Filter_Condition|(Any->Boolean)) -> Problem_Behavior -> Table
    filter self column filter=(Filter_Condition.Is_True) on_problems=Report_Warning = case column of
        _ : Column ->
            mask filter_column = Table.Value (self.java_table.mask filter_column.java_column)
            case filter of
                _ : Filter_Condition ->
                    on_problems.handle_errors fallback=self.with_no_rows <|
                        mask (make_filter_column column filter)
                _ : Function -> mask (column.map filter)
        _ : Text ->
            table_at = self.at column
            if table_at.is_error.not then self.filter table_at filter on_problems else
                expression = self.evaluate column
                if expression.is_error.not then self.filter expression filter on_problems else
                    pick_error = expression.catch Expression_Error.Syntax_Error (_->table_at)
                    on_problems.handle_errors pick_error fallback=self
        _ -> case on_problems.handle_errors (self.at column) fallback=Nothing of
            Nothing -> self
            resolved_column -> self.filter resolved_column filter on_problems

    ## PRIVATE
    with_no_rows self = self.take (First 0)

    ## Creates a new Table with the specified range of rows from the input
       Table.

       Arguments:
       - range: The selection of rows from the table to return.

       For the purposes of the `Index_Sub_Range.While` predicate a single
       "element" of the table is represented by the `Row` type.

       > Example
         Take first 10 rows of the table.

             table.take (First 10)

       > Example
         Take rows from the top of the table as long as their values sum to 10.

             table.take (While row-> row.to_vector.sum == 10)
    take : (Index_Sub_Range | Range | Integer) -> Table
    take self range=(First 1) =
        Index_Sub_Range_Module.take_helper self.row_count self.rows.at self.slice (slice_ranges self) range

    ## Creates a new Table from the input with the specified range of rows
       removed.

       Arguments:
       - range: The selection of rows from the table to remove.

       For the purposes of the `Index_Sub_Range.While` predicate a single
       "element" of the table is represented by the `Row` type.

       > Example
         Drop first 10 rows of the table.

             table.drop (First 10)

       > Example
         Drop rows from the top of the table as long as their values sum to 10.

             table.drop (While row-> row.to_vector.sum == 10)
    drop : (Index_Sub_Range | Range | Integer) -> Table
    drop self range=(First 1) =
        Index_Sub_Range_Module.drop_helper self.row_count self.rows.at self.slice (slice_ranges self) range

    ## ALIAS Add Column

       Sets the column value at the given name.

       Arguments:
       - name: The name of the column to set the value of.
       - column: The new value for the column either a `Column` or `Text` of an
         expression.
       - on_problems: Specifies how to handle if a problem occurs, raising as a
         warning by default.

       If a column with the given name already exists, it will be replaced.
       Otherwise a new column is added.

       > Example
         Create a table where the values of the total stock in the inventory is
         doubled.

             import Standard.Examples

             example_set =
                 table = Examples.inventory_table
                 double_inventory = table.at "total_stock" * 2
                 table.set "total_stock" double_inventory
                 table.set "total_stock_expr" "2 * [total_stock]"
    set : Text -> Column | Vector | Text -> Problem_Behavior -> Table
    set self name column on_problems=Report_Warning = case column of
        _ : Text ->
            expression = self.evaluate column
            if expression.is_error.not then self.set name expression on_problems else
                on_problems.handle_errors expression fallback=self
        _ : Vector -> self.set name (Column.from_vector name column)
        _ : Column ->
            Table.Value (self.java_table.addOrReplaceColumn (column.rename name . java_column))

    ## PRIVATE
    evaluate : Text -> Column
    evaluate self expression =
        get_column name = self.at name
        make_constant value = Column.from_vector_repeated (UUID.randomUUID.to_text) [value] self.row_count
        Expression.evaluate expression get_column make_constant "Standard.Table.Data.Column" "Column" Column.var_args_functions

    ## Returns the vector of columns contained in this table.

       > Examples
         Get a vector containing the columns in the table.

             import Standard.Examples

             example_columns = Examples.inventory_table.columns
    columns : Vector
    columns self = Vector.from_polyglot_array self.java_table.getColumns . map Column.Value

    ## UNSTABLE

       Returns the vector of column names contained in this table.
    column_names : Vector Text
    column_names self = Vector.from_polyglot_array self.java_table.getColumns . map _.getName

    ## Returns a vector of rows contained in this table.

       In the database backend, it first materializes the table to in-memory.

       Arguments:
       - max_rows: The maximum amount of rows to return. It is mainly meant for
         the Database backend, to limit how many rows are downloaded. In the
         in-memory backend it is only kept for API compatibility.
    rows : Integer -> Vector Row
    rows self max_rows=Nothing =
        table = case max_rows of
            Nothing -> self
            _ : Integer -> self.slice 0 max_rows
        proxy = Rows_View.Value table
        Vector.from_polyglot_array (Array_Proxy.from_proxy_object proxy)

    ## Sets the index of this table, using the column with the provided name.

       Arguments:
       - index: The name of the column to use as the index in this table, or the
         column itself to use.

       > Example
         Set the index of the inventory table to be the item name.

             import Standard.Examples

             example_set_index = Examples.inventory_table.set_index "item_name"
    set_index : Text | Column -> Table
    set_index self index = case index of
        _ : Text -> Table.Value (self.java_table.indexFromColumn index)
        Column.Value c -> Table.Value (self.java_table.indexFromColumn c)

    ## Returns the index of this table, as a column that is indexed by itself.

       Throws `No_Index_Set_Error` if there is no index set in the table it is
       being called on.

       > Example
         Get the column that is used as the index for a table.

             import Standard.Examples

             example_index = Examples.inventory_table.index
    index : Column ! No_Index_Set_Error
    index self = case self.java_table.getIndex.toColumn of
        Nothing -> Error.throw No_Index_Set_Error
        i -> Column.Value i

    ## Joins two tables according to the specified join conditions.

       Arguments:
       - right: The table to join with.
       - join_kind: The `Join_Kind` for the joining the two tables.
       - on: A single condition or a common column name, or a list thereof, on
         which to correlate rows from the two tables. If multiple conditions
         are supplied, rows are correlated only if all are true.
         If common column names are provided, these columns should be present
         in both tables and an equality condition is added for each of them.
       - right_prefix: The prefix added to right table column names in case of
         name conflict.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         - If a column name cannot be found, a `No_Such_Column` is reported
           and an empty result is reported.
         - If a column index is invalid, an `Index_Out_Of_Bounds` is
           reported and an empty result is reported.
         - If a join condition correlates columns whose types are not compatible
           (for example comparing numeric types with text), an
           `Invalid_Value_Type` is reported.
         - If decimal columns are joined on equality, a
           `Floating_Point_Grouping` is reported.

         In any of the above cases, if a problem occurs, the resulting table
         will have the desired structure, but it will be empty to indicate that
         the join has failed due to an erroneous join condition.

       ? Column Renaming

         If columns from the two tables have colliding names, a prefix (by
         default `Right_`) is added to the name of the column from the right
         table. The left column remains unchanged. It is possible that the new
         name will be in use, in this case it will be resolved using the normal
         renaming strategy - adding subsequent `_1`, `_2` etc.

       ? Result Ordering

         The ordering of rows in the resulting table is not specified.

       ? Joining on equality of columns with the same name

         When joining two columns with the same name and an equality condition,
         only one copy of column will be included in the output (avoiding
         unnecessary duplication and renaming).

       ? Same-name column join shorthand

         As a shorthand, providing a column name or a list of column names
         allows to join the two tables on equality of corresponding columns with
         the same name. So `table.join other on=["A", "B"]` is a shorthand for:
             table.join other on=[Join_Condition.Equals "A" "A", Join_Condition.Equals "B" "B"]
    join : Table -> Join_Kind -> Join_Condition | Text | Vector (Join_Condition | Text) -> Text -> Problem_Behavior -> Table
    join self right join_kind=Join_Kind.Inner on=[Join_Condition.Equals 0 0] right_prefix="Right_" on_problems=Report_Warning =
        if Table_Helpers.is_table right . not then Error.throw (Type_Error.Error Table right "right") else
            same_backend = case right of
                _ : Table -> True
                _ -> False
            if same_backend . not then Error.throw (Illegal_Argument.Error "Currently cross-backend joins are not supported. Materialize the table using `.read` before joining it with an in-memory Table.") else
                # [left_unmatched, matched, right_unmatched]
                rows_to_keep = case join_kind of
                    Join_Kind.Inner           -> [False, True, False]
                    Join_Kind.Left_Outer      -> [True, True, False]
                    Join_Kind.Right_Outer     -> [False, True, True]
                    Join_Kind.Full            -> [True, True, True]
                    Join_Kind.Left_Exclusive  -> [True, False, False]
                    Join_Kind.Right_Exclusive -> [False, False, True]

                columns_to_keep = case join_kind of
                    Join_Kind.Left_Exclusive  -> [True, False]
                    Join_Kind.Right_Exclusive -> [False, True]
                    _                         -> [True, True]

                join_resolution = make_join_helpers self right . resolve on on_problems
                right_columns_to_drop = join_resolution.redundant_column_names

                object_comparator = Comparator.new
                equality_fallback = .==

                new_java_table = case join_resolution.conditions of
                    # Nothing is returned if some conditions failed to resolve, we will return an empty result in such case.
                    Nothing ->
                        self.java_table.join right.java_table Nothing False False False (columns_to_keep.at 0) (columns_to_keep.at 1) right_columns_to_drop right_prefix object_comparator equality_fallback
                    java_conditions ->
                        self.java_table.join right.java_table java_conditions (rows_to_keep.at 0) (rows_to_keep.at 1) (rows_to_keep.at 2) (columns_to_keep.at 0) (columns_to_keep.at 1) right_columns_to_drop right_prefix object_comparator equality_fallback

                on_problems.attach_problems_after (Table.Value new_java_table) <|
                    problems = new_java_table.getProblems
                    Aggregate_Column_Helper.parse_aggregated_problems problems

    ## ALIAS dropna
       ALIAS drop_missing_rows
       Remove rows which are all blank or containing blank values.

       Arguments:
       - when_any: If `True`, then remove any row containing any blank values.
         If `False`, then only remove rows with all blank values.
       - treat_nans_as_blank: If `True`, then `Number.nan` is considered as blank.

       ? Blank values
         Blank values are `Nothing`, `""` and depending on setting `Number.nan`.
    filter_blank_rows : Boolean -> Boolean -> Table
    filter_blank_rows self when_any=False treat_nans_as_blank=False =
        Table_Helpers.filter_blank_rows self when_any treat_nans_as_blank

    ## Returns the number of rows in this table.

       > Example
         Count the number of rows in the table.

             import Standard.Examples

             example_row_count = Examples.inventory_table.row_count
    row_count : Integer
    row_count self = self.java_table.rowCount

    ## Returns a Table describing this table's contents.

       The table lists all columns, counts of non-null items and storage types
       of each column.

       > Example
         Get information about a table.

             import Standard.Examples

             example_info = Examples.inventory_table.info
    info : Table
    info self =
        cols = self.columns
        Table.new [["Column", cols.map .name], ["Items Count", cols.map .count], ["Storage Type", cols.map .storage_type]] . set_index "Column"

    ## UNSTABLE

       Concatenates `other` to `self`, resulting in a table with the number of rows
       being the sum of numbers of rows of `tables`. Any column that is present in
       some tables, but missing in others, will be `Nothing`-padded in the positions
       corresponding to the missing values.

       Arguments:
       - other: The table or vector of tables to concatenate to `self`.

       Any column that is present in one table, but missing in another, will be
       `Nothing`-padded in the positions corresponding to the missing column.

       > Example
         Concatenate two tables together.

             import Standard.Examples

             example_concat =
                 Examples.inventory_table.concat Examples.popularity_table
    concat : Table | Vector Table -> Table
    concat self other = case other of
        _ : Vector ->
            java_tables = Vector.new (other.length + 1) i->(if i==0 then self else other.at i).java_table
            Table.Value (Java_Table.concat java_tables.to_array)
        Table.Value other_java_table -> Table.Value (Java_Table.concat [self.java_table, other_java_table].to_array)

    ## Returns a new table with a chosen subset of columns left unchanged and
       the other columns pivoted to rows with a single name field and a single
       value field.

       Arguments:
       - id_fields: Set of fields to remain as columns. These values will be
         repeated for each data field that is pivoted.
       - name_field: The name of the field that will contain the names of the
         pivoted fields. If this name is already in use, it will be renamed
         with a numeric suffix.
       - value_field: The name of the field that will contain the values of the
         pivoted fields. If this name is already in use, it will be renamed
         with a numeric suffix.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column in columns is not in the input table, a
           `Missing_Input_Columns`.
         - If duplicate columns, names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`, with the column included the first
           time it is matched.
         - If there are no columns to transpose, a `No_Input_Columns`.
    transpose : Text | Vector Text | Column_Selector -> Text -> Text -> Problem_Behavior -> Table
    transpose self (id_fields = Column_Selector.By_Name []) (name_field="Name") (value_field="Value") (on_problems = Report_Warning) =
        columns_helper = self.columns_helper
        unique = Unique_Name_Strategy.new
        problem_builder = Problem_Builder.new

        id_columns = columns_helper.select_columns_helper id_fields False problem_builder
        count = self.column_count - id_columns.length
        if count == 0 then problem_builder.report_other_warning No_Input_Columns_Selected

        selected_names = Map.from_vector (id_columns.map column-> [column.name, True])

        data = columns_helper.internal_columns.filter column->(selected_names.get column.name False . not)
        java_data = data.map .java_column

        java_id = id_columns.map .java_column

        id_columns.each k-> unique.make_unique k.name
        result = Table.Value (Java_Table.transpose java_id.to_array java_data.to_array (unique.make_unique name_field) (unique.make_unique value_field))
        problem_builder.attach_problems_after on_problems result

    ## Returns a new table using a chosen field as the column header and then
       aggregating the rows within each value as specified. Optionally, a set of
       fields can be used to group the rows.

       Arguments:
       - group_by: Set of fields to group by. If not provided, a single row will
         be produced.
       - name_column: The field to use as the column header. If this field is
         not found, then each value will be a single column.
       - values: The aggregation to perform on each set of rows. Can be a single
         aggregation or a vector of aggregations. Expressions can be used within
         the aggregation to perform more complicated calculations.
       - on_problems: Specifies how to handle problems if they occur, reporting
         them as warnings by default.

         The following problems can occur:
         - If a column in the input is not in the input table, a
           `Missing_Input_Columns`.
         - If a column index is out of range, a `Column_Indexes_Out_Of_Range`.
         - In `grouping`, if duplicate column names or indices are provided, a
           `Duplicate_Column_Selectors`.
         - In `grouping`, If two distinct indices refer to the same column, an
           `Input_Indices_Already_Matched`, with the column included the first
           time it is matched.
         - If grouping on, using as the column name, or computing the `Mode` on
           a floating point number, a `Floating_Point_Grouping`.
         - If an aggregation fails, an `Invalid_Aggregation`.
         - If when concatenating values there is an quoted delimited, an `Unquoted_Delimiter`
         - If there are more than 10 issues with a single column, an `Additional_Warnings`.
    cross_tab : Text | Vector Text | Column_Selector -> (Text | Integer | Column) -> Vector Aggregate_Column -> Problem_Behavior -> Table
    cross_tab self group_by=[] name_column=self.column_names.first values=Aggregate_Column.Count (on_problems=Report_Warning) =
        columns_helper = self.columns_helper
        problem_builder = Problem_Builder.new

        ## validate the name and group_by columns
        matched_name = columns_helper.select_columns_helper [name_column] True problem_builder
        grouping = columns_helper.select_columns_helper group_by True problem_builder

        ## Validate the values
        values_vector = case values of
            _ : Vector -> values
            _ -> [values]
        resolved_values = values_vector.map (Aggregate_Column_Helper.resolve_aggregate self problem_builder)
        is_group_by c = case c of
            Aggregate_Column.Group_By _ _ -> True
            _ -> False
        if resolved_values.any is_group_by then problem_builder.report_other_warning (Illegal_Argument.Error "Cannot use group_by for a cross_tab value.")
        validated_values = resolved_values.filter c->((c!=Nothing) && (is_group_by c).not)

        on_problems.attach_problems_before (problem_builder.build_problemset) <| Illegal_Argument.handle_java_exception <|
            java_key_columns = grouping.map .java_column
            index  = self.java_table.indexFromColumns java_key_columns.to_array

            name_mapper = if matched_name.is_empty then Aggregate_Column_Helper.default_aggregate_column_name else
                if validated_values.length == 1 then (_ -> "") else
                    all_same = Aggregate_Column_Helper.all_same_column validated_values
                    c -> Aggregate_Column_Helper.default_aggregate_column_name c all_same

            data_columns = validated_values.map c->
                col_name = c.new_name.if_nothing (name_mapper c)
                Aggregate_Column_Helper.java_aggregator col_name c

            result = case matched_name.is_empty of
                True ->
                    group_by = grouping.map g->(Aggregate_Column_Helper.java_aggregator g.name (Aggregate_Column.Group_By g))
                    index.makeTable (group_by + data_columns).to_array
                False ->
                    index.makeCrossTabTable java_key_columns.to_array matched_name.first.java_column data_columns.to_array

            on_problems.attach_problems_after (Table.Value result) <|
                problems = result.getProblems
                Aggregate_Column_Helper.parse_aggregated_problems problems

    ## PRIVATE
       Returns a table with a continuous sub-range of rows taken.
    slice : Integer -> Integer -> Table
    slice self start end =
        length = self.row_count
        offset = Math.max (Math.min start length) 0
        limit = Math.max (Math.min (end - offset) (length - offset)) 0
        Table.Value (self.java_table.slice offset limit)

    ## UNSTABLE

       Returns a table containing the rows of `self` table with their order
       reversed.

       > Example
         Reverse the rows in a table.

             import Standard.Examples

             example_reverse = Examples.inventory_table.reverse
    reverse : Table
    reverse self =
        mask = OrderBuilder.buildReversedMask self.row_count
        Table.Value <| self.java_table.applyMask mask

    ## ALIAS Write JSON
       UNSTABLE

       Writes this table to a specified file, serialized into JSON. The JSON
       serialization is such that the result is an array, in which every entry
       is an object representing a single row, with column names as keys.

       Arguments:
       - file: the file to write data to. If the file exists, it will be
         overwritten.

       > Example
         Write a table to a JSON file.

             import Standard.Examples

             example_to_json = Examples.inventory_table.write_json (enso_project.data / 'example.json')
    write_json : File -> Nothing
    write_json self file = self.to_json.write file

    ## This function writes a table from memory into a file.

       The specific behavior of the various `File_Format`s is specified below.

       Arguments:
       - path: The path to the output file.
       - format: The format of the file.
         If `Auto_Detect` is specified; the provided file determines the
         specific type and configures it appropriately. Details of this type are
         below.
       - on_existing_file: Specified how to handle if the file already exists.
       - match_columns: Specifies how to match columns against an existing file.
         If `Match_Columns.By_Name` - the columns are mapped by name against an
         existing file. If there is a mismatch, then a `Column_Name_Mismatch`
         error is raised.
         If `Match_Columns.By_Position` - the columns are mapped by position
         against an existing file. If there is a mismatch, then a
         `Column_Count_Mismatch` error is raised.
       - on_problems: Specifies how to handle if a problem occurs, raising as a
         warning by default. The specific issues depend on the `File_Format`
         argument.

       Returns:
       - If an unsupported `File_Format` is specified, an
         `Illegal_Argument` is raised.
       - If the path to the parent location cannot be found or the filename is
         invalid, a `File_Error.Not_Found` is raised.
       - If another IO error occurs, such as access denied, an
         `File_Error.IO_Error` is raised.
       - If appending and the columns do not match, a `Column_Mismatch` is
         raised.
       - Other specific errors or warnings that can be raised depend on the
         format argument.
       - Otherwise, the file is loaded following the rules of the format
         parameter.

       ? `File_Format` write behaviors

         - `Auto_Detect`: The file format is determined by the provided file.
         - `Bytes` and `Plain_Text`: The Table does not support these types in
           the `write` function. If passed as format, an
           `Illegal_Argument` is raised. To write out the table as plain
           text, the user needs to call the `Text.from Table` method and then
           use the `Text.write` function.

       > Example
         Write a table to a CSV file, without writing the header.

             import Standard.Examples
             from Standard.Table import Delimited

             example_to_csv = Examples.inventory_table.write (Enso_Project.data / "example_csv_output.csv") (Delimited delimiter="," headers=False)

       > Example
         Write a table to an XLSX file.

             import Standard.Examples
             from Standard.Table import Excel

             example_to_xlsx = Examples.inventory_table.write (enso_project.data / "example_xlsx_output.xlsx") Excel
    write : File|Text -> File_Format -> Existing_File_Behavior -> Match_Columns -> Problem_Behavior -> Nothing ! Column_Mismatch | Illegal_Argument | File_Error
    write self path format=Auto_Detect on_existing_file=Existing_File_Behavior.Backup match_columns=Match_Columns.By_Name on_problems=Report_Warning =
        file = File.new path
        case format of
            _ : Auto_Detect ->
                base_format = format.get_format file
                if base_format == Nothing then Error.throw (File_Error.Unsupported_Type file) else
                    self.write file format=base_format on_existing_file match_columns on_problems
            _ ->
                Panic.catch No_Such_Method.Error (format.write_table file self on_existing_file match_columns on_problems) _->
                    name = (Meta.meta format).constructor.name
                    Error.throw (Illegal_Argument.Error ("Saving a Table as " + name + " is not supported."))

    ## Creates a text representation of the table using the CSV format.
    to_csv : Text
    to_csv self = Text.from self (Delimited_Format.Delimited delimiter=",")

    ## PRIVATE
    columns_helper : Table_Column_Helper
    columns_helper self =
        Table_Helpers.Table_Column_Helper.Value self.columns (x->x) self (x->x)

## UNSTABLE

   An error returned when the table contains no rows.
type Empty_Error
    ## PRIVATE

       Pretty prints the empty table error.
    to_display_text : Text
    to_display_text self = "The table is empty."

## PRIVATE

   Ensures that the `txt` has at least `len` characters by appending spaces at
   the end.

   Arguments:
   - txt: The text to pad.
   - len: The minimum length of the text.
pad : Text -> Integer -> Text
pad txt len =
    true_len = txt.characters.length
    txt + (" ".repeat (len - true_len))

## PRIVATE

   Adds ANSI bold escape sequences to text if the feature is enabled.

   Arguments:
   - enabled: will insert ANSI sequences only if this flag is true and we are not on Windows.
   - txt: The text to possibly bold.
ansi_bold : Boolean -> Text -> Text
ansi_bold enabled txt =
    case Platform.os of
        ## Output formatting for Windows is not currently supported.
        Platform.OS.Windows -> txt
        _ -> if enabled then '\e[1m' + txt + '\e[m' else txt

## PRIVATE

   A helper function for creating an ASCII-art representation of tabular data.

   Arguments:
   - header: vector of names of columns in the table.
   - rows: a vector of rows, where each row is a vector that contains a text
     representation of each cell
   - indices_count: the number specifying how many columns should be treated as
     indices; this will make them in bold font if `format_term` is enabled.
   - format_term: a boolean flag, specifying whether to use ANSI escape codes
     for rich formatting in the terminal.
print_table : Vector Text -> (Vector (Vector Text)) -> Integer -> Boolean -> Text
print_table header rows indices_count format_term =
    content_lengths = Vector.new header.length i->
        max_row = 0.up_to rows.length . fold 0 a-> j-> Math.max a (rows.at j . at i . characters . length)
        Math.max max_row (header.at i . characters . length)
    header_line = header.zip content_lengths pad . map (ansi_bold format_term) . join ' | '
    divider = content_lengths . map (l -> "-".repeat l+2) . join '+'
    row_lines = rows.map r->
        x = r.zip content_lengths pad
        ixes = x.take (First indices_count) . map (ansi_bold format_term)
        with_bold_ix = ixes + x.drop (First indices_count)
        y = with_bold_ix . join ' | '
        " " + y
    ([" " + header_line, divider] + row_lines).join '\n'

## PRIVATE
   A helper to create a new table consisting of slices of the original table.
slice_ranges table ranges =
    normalized = Index_Sub_Range_Module.normalize_ranges ranges
    Table.Value (table.java_table.slice normalized.to_array)

## PRIVATE
make_join_helpers left_table right_table =
    make_equals left right = Java_Join_Equals.new left.java_column right.java_column
    make_equals_ignore_case left right locale =
        Java_Join_Equals_Ignore_Case.new left.java_column right.java_column locale.java_locale
    make_between left right_lower right_upper =
        Java_Join_Between.new left.java_column right_lower.java_column right_upper.java_column
    Join_Helpers.Join_Condition_Resolver.Value (left_table.at _) (right_table.at _) make_equals make_equals_ignore_case make_between
