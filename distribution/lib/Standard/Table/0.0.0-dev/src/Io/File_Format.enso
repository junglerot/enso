from Standard.Base import all
import Standard.Table

import Standard.Base.Error.Common as Errors
from Standard.Base.Error.Problem_Behavior as Problem_Behavior_Module import Problem_Behavior
from Standard.Base.Data.Text.Encoding as Encoding_Module import Encoding
import Standard.Base.Runtime.Ref
import Standard.Table.Internal.Delimited_Reader

from Standard.Table.Data.Data_Formatter as Data_Formatter_Module import Data_Formatter
import Standard.Table.Io.Excel as Excel_Module

## This type needs to be here to allow for the usage of Standard.Table
   functions. Ideally, it would be an interface within Standard.Base and
   expanded by additional implementations in Standard.Table.

## Determines the format of file to use based on the file extension.
type Auto
    type Auto

    ## ADVANCED
       Gets the underlying File_Format for the specified file
    materialise : File->File_Format
    materialise file =
        extension = file.extension

        output = Ref.new File_Format.Bytes
        if ".txt".equals_ignore_case extension then output.put File_Format.Text
        if ".log".equals_ignore_case extension then output.put File_Format.Text
        if ".csv".equals_ignore_case extension then output.put (File_Format.Delimited ',')
        if ".tsv".equals_ignore_case extension then output.put (File_Format.Delimited '\t')
        if ".xlsx".equals_ignore_case extension then output.put File_Format.Excel
        if ".xlsm".equals_ignore_case extension then output.put File_Format.Excel
        if ".xls".equals_ignore_case extension then output.put File_Format.Excel
        if ".xlt".equals_ignore_case extension then output.put File_Format.Excel

        output.get

    ## Implements the `File.read` for this `File_Format`
    read : File -> Problem_Behavior -> Any
    read file on_problems =
        materialised = this.materialise file
        materialised.read file on_problems

## Reads the file to a `Vector` of bytes.
type Bytes
    type Bytes

    ## Implements the `File.read` for this `File_Format`
    read : File -> Problem_Behavior -> Any
    read file _ =
        file.read_bytes

## Reads the file to a `Text` with specified encoding.
type Text
    type Text (encoding:Encoding=Encoding.utf_8)

    ## Implements the `File.read` for this `File_Format`
    read : File -> Problem_Behavior -> Any
    read file on_problems =
        file.read_text this.encoding on_problems

## Read delimited files such as CSVs into a Table.
type Delimited
    ## Read delimited files such as CSVs into a Table.

       If a row does not match the first row's column count, the function raises
       an `Invalid_Row`. If a quote is opened and never closed, a
       `Mismatched_Quote` warning occurs.

       Arguments:
       - delimiter: The delimiter character to split the file into columns. An
         `Illegal_Argument_Error` error is returned if this is an empty string.
       - encoding: The encoding to use when reading the file.
       - quote: The quote character denotes the start and end of a quoted value.
         No quote character is used if set to `Nothing`. Quoted items are not
         split on the delimiter and can also contain newlines. Within a quoted
         value, two consecutive quote characters are interpreted as an instance
         of the quote character. Empty input strings must be quoted (e.g. "") as
         otherwise an empty value is treated as `Nothing`.
       - quote_escape: The character to escape the quote character in a quoted
         value. For example, if both `quote` and `quote_escape` are set to `"`,
         then escaping quotes is done by double quotes: `"ab""cd"` will yield
         the text `ab"cd"`. Another popular choice for `quote_escape` is the `\`
         character. Then `"ab\"cd"` will yield the same text.
       - headers: If set to `True`, the first row is used as column names. If
         set to `False`, the column names are generated by adding increasing
         numeric suffixes to the base name `Column` (i.e. `Column_1`,
         `Column_2` etc.). If set to `Infer`, the process tries to infer if
         headers are present on the first row. If the column names are not
         unique, numeric suffixes will be appended to disambiguate them.
       - skip_rows: The number of rows to skip from the top of the file.
       - row_limit: The maximum number of rows to read from the file. This count
         does not include the header row (if applicable).
       - value_formatter: Formatter to parse text values into numbers, dates,
         times, etc. If `Nothing` values are left as Text.
       - keep_invalid_rows: Specifies whether rows that contain less or more
         columns than expected should be kept (setting the missing columns to
         `Nothing` or dropping the excess columns) or dropped.
    type Delimited (delimiter:Text) (encoding:Encoding=Encoding.utf_8) (quote:Text|Nothing='"') (quote_escape:Text|Nothing='"') (headers:True|False|Infer=Infer) (skip_rows:Integer|Nothing=Nothing) (row_limit:Integer|Nothing=Nothing) (value_formatter:Data_Formatter|Nothing=Data_Formatter) (keep_invalid_rows:Boolean=True)

    ## Implements the `File.read` for this `File_Format`
    read : File -> Problem_Behavior -> Any
    read file on_problems =
        Delimited_Reader.read_file this file on_problems

## A setting to infer the default behaviour of some option.
type Infer

## Read the file to a `Table` from an Excel file
type Excel
    ## Read Excels files into a Table or Vector.

       Arguments:
       - section: The `Excel_Section` to read from the workbook.
         This can be one of:
         - `Sheet_Names` - outputs a `Vector` of sheet names.
         - `Range_Names` - outputs a `Vector` of range names.
         - `Sheet` - outputs a `Table` containing the specified sheet.
         - `Range` - outputs a `Table` containing the specified range.
       - `xls_format`:
         If set to `True`, the file is read as an Excel 95-2003 format.
         If set to `False`, the file is read as an Excel 2007+ format.
         `Infer` will attempt to deduce this from the extension of the filename.
    type Excel (section:Excel_Section=Excel_Module.Sheet_Names) (xls_format:(True|False|Infer)=Infer)

    ## Implements the `File.read` for this `File_Format`
    read : File -> Problem_Behavior -> Any
    read file on_problems =
        format = if this.xls_format != Infer then this.xls_format else
            extension = file.extension
            (extension.equals_ignore_case ".xls") || (extension.equals_ignore_case ".xlt")

        Excel_Module.read_excel file this.section on_problems format
