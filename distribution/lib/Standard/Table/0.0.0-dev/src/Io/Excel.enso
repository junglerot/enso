from Standard.Base import all
from Standard.Base.Error.Problem_Behavior as Problem_Behavior_Module import Problem_Behavior
from Standard.Table.Io.File_Format import Infer

import Standard.Table.Data.Table
from Standard.Table.Error as Error_Module import Invalid_Location, Duplicate_Output_Column_Names, Invalid_Output_Column_Names

polyglot java import org.enso.table.excel.ExcelRange as Java_Range
polyglot java import org.enso.table.read.ExcelReader

polyglot java import java.lang.IllegalArgumentException
polyglot java import java.io.IOException
polyglot java import org.apache.poi.UnsupportedFileFormatException
polyglot java import org.enso.table.util.problems.DuplicateNames
polyglot java import org.enso.table.util.problems.InvalidNames

type Excel_Section
    ## Gets a list of sheets within a workbook.
    type Sheet_Names

    ## Gets a list of named ranges within a workbook.
    type Range_Names

    ## Gets the data from a specific sheet. Column names are the Excel column
       names.
    type Sheet (sheet:(Integer|Text)=1) (skip_rows:Integer=0) (row_limit:(Integer|Nothing)=Nothing)

    ## Gets a specific range (taking either a defined name or external style
       address) from the workbook.
       If it is a single cell, it will be treated as the top left cell and will
       expand right and down to cover the connected cells.
    type Cell_Range (address:(Text|Excel_Range)) (skip_rows:Integer=0) (row_limit:(Integer|Nothing)=Nothing)

type Excel_Range
    ## Specifies a range within an Excel Workbook.
    type Excel_Range java_range:Java_Range

    ## Gets the name of the sheet.
    sheet_name : Text
    sheet_name = self.java_range.getSheetName

    ## Gets the index (1-based) of the top row of the range.
       Returns `Nothing` if referring to a complete column.
    top_row : Integer | Nothing
    top_row = if self.java_range.isWholeColumn then Nothing else
        self.java_range.getTopRow

    ## Gets the index (1-based) of the bottom row of the range.
       Returns `Nothing` if referring to a complete column.
    bottom_row : Integer | Nothing
    bottom_row = if self.java_range.isWholeColumn then Nothing else
        self.java_range.getBottomRow

    ## Gets the index (1-based) of the left column of the range.
       Returns `Nothing` if referring to a complete row.
    left_column : Integer | Nothing
    left_column = if self.java_range.isWholeRow then Nothing else
        self.java_range.getLeftColumn

    ## Gets the index (1-based) of the right column of the range.
       Returns `Nothing` if referring to a complete row.
    right_column : Integer | Nothing
    right_column = if self.java_range.isWholeRow then Nothing else
        self.java_range.getRightColumn

    ## Is the Excel_Range referring to a single cell
    is_single_cell : Boolean
    is_single_cell = self.java_range.isSingleCell

    ## Gets the address to this in A1 format.
    address : Text
    address = self.java_range.getAddress

    ## Displays the Excel_Range.
    to_text : Text
    to_text = "Excel_Range " + self.address

    ## Validates if a column index (1-based) is within the valid range for
       Excel.

       Arguments:
       - column: 1-based index to check.
    is_valid_column : Integer -> Boolean
    is_valid_column column =
        excel_2007_column_limit = 16384
        (column > 0) && (column <= excel_2007_column_limit)

    ## Validates if a row index (1-based) is within the valid range for Excel.

       Arguments:
       - row: 1-based index to check.
    is_valid_row : Integer -> Boolean
    is_valid_row row =
        excel_2007_row_limit = 1048576
        (row > 0) && (row <= excel_2007_row_limit)

    ## Given a column name, parses to the index (1-based) or return index
       unchanged.
    column_index : (Text|Integer) -> Integer
    column_index column =
        if column.is_an Integer then column else Java_Range.parseA1Column column

    ## Creates a Range from an address.
    from_address : Text -> Excel_Range
    from_address address =
        Panic.catch IllegalArgumentException (Excel_Range (Java_Range.new address)) caught_panic->
            Error.throw (Illegal_Argument_Error caught_panic.payload.cause.getMessage caught_panic.payload.cause)

    ## Create a Range for a single cell.
    for_cell : Text -> (Text|Integer) -> Integer -> Excel_Range
    for_cell sheet column row =
        col_index = Excel_Range.column_index column

        col_valid = here.validate (Excel_Range.is_valid_column col_index) ("Invalid column for Excel: " + column.to_text + ".")
        row_valid = here.validate (Excel_Range.is_valid_row row) ("Invalid row for Excel: " + row.to_text + ".")

        col_valid <| row_valid <|
            Excel_Range (Java_Range.new sheet col_index row)

    ## Create an Excel_Range for a range of cells.
    for_range : Text -> (Text|Integer) -> Integer -> (Text|Integer) -> Integer -> Excel_Range
    for_range sheet left top right bottom =
        left_index = Excel_Range.column_index left
        right_index = Excel_Range.column_index right

        left_valid = here.validate (Excel_Range.is_valid_column left_index) ("Invalid left column for Excel: " + left.to_text + ".")
        right_valid = here.validate (Excel_Range.is_valid_column right_index) ("Invalid right column for Excel: " + right.to_text + ".")
        top_valid = here.validate (Excel_Range.is_valid_row top) ("Invalid top row for Excel: " + top.to_text + ".")
        bottom_valid = here.validate (Excel_Range.is_valid_row bottom) ("Invalid bottom row for Excel: " + bottom.to_text + ".")

        left_valid <| right_valid <| top_valid <| bottom_valid <|
            Excel_Range (Java_Range.new sheet left_index top right_index bottom)

    ## Create an Excel_Range for a set of columns.
    for_columns : Text -> (Text|Integer) -> (Text|Integer) -> Excel_Range
    for_columns sheet left (right=left) =
        left_index = Excel_Range.column_index left
        right_index = Excel_Range.column_index right

        left_valid = here.validate (Excel_Range.is_valid_column left_index) ("Invalid left column for Excel: " + left.to_text + ".")
        right_valid = here.validate (Excel_Range.is_valid_column right_index) ("Invalid right column for Excel: " + right.to_text + ".")

        left_valid <| right_valid <|
            Excel_Range (Java_Range.forColumns sheet left_index right_index)

    ## Create an Excel_Range for a set of rows.
    for_rows : Text -> Integer -> Integer -> Excel_Range
    for_rows sheet top (bottom=top) =
        top_valid = here.validate (Excel_Range.is_valid_row top) ("Invalid top row for Excel: " + top.to_text + ".")
        bottom_valid = here.validate (Excel_Range.is_valid_row bottom) ("Invalid bottom row for Excel: " + bottom.to_text + ".")

        top_valid <| bottom_valid <|
            Excel_Range (Java_Range.forRows sheet top bottom)


## PRIVATE
   Wrapper for validation of a value prior to execution.
validate : Boolean -> Text -> Any
validate validation ~error_message ~wrapped =
    if validation then wrapped else Error.throw (Illegal_Argument_Error error_message)

## PRIVATE
   Reads an input Excel file according to the provided section.

   Arguments:
   - file: The File object to read.
   - section: The part of the Excel document to read.
   - on_problems: Specifies the behavior when a problem occurs during the
     operation. By default, a warning is issued, but the operation proceeds.
     If set to `Report_Error`, the operation fails with a dataflow error.
     If set to `Ignore`, the operation proceeds without errors or warnings.
   - xls_format: If `True` then the file is read in using Excel 95-2003 format
     otherwise reads in Excel 2007+ format.
read_excel : File -> Excel_Section -> (Boolean|Infer) -> Problem_Behavior -> Boolean -> (Table | Vector)
read_excel file section headers on_problems xls_format=False =
    reader stream = case section of
        Sheet_Names -> Vector.Vector (ExcelReader.readSheetNames stream xls_format)
        Range_Names -> Vector.Vector (ExcelReader.readRangeNames stream xls_format)
        Sheet sheet skip_rows row_limit ->
            here.prepare_reader_table on_problems <| case sheet of
                Integer -> ExcelReader.readSheetByIndex stream sheet (here.make_java_headers headers) skip_rows row_limit xls_format
                Text -> ExcelReader.readSheetByName stream sheet (here.make_java_headers headers) skip_rows row_limit xls_format
        Cell_Range address skip_rows row_limit ->
            here.prepare_reader_table on_problems <| case address of
                Excel_Range _ -> ExcelReader.readRange stream address.java_range (here.make_java_headers headers) skip_rows row_limit xls_format
                Text -> ExcelReader.readRangeByName stream address (here.make_java_headers headers) skip_rows row_limit xls_format

    bad_argument caught_panic = Error.throw (Invalid_Location caught_panic.payload.cause.getCause)
    handle_bad_argument = Panic.catch IllegalArgumentException handler=bad_argument

    bad_format caught_panic = Error.throw (File.Io_Error file caught_panic.payload.cause.getMessage)
    handle_bad_format = Panic.catch UnsupportedFileFormatException handler=bad_format

    File.handle_java_exceptions file <| handle_bad_argument <| handle_bad_format <|
        file.with_input_stream [File.Option.Read] stream->(stream.with_java_stream reader)

## PRIVATE
prepare_reader_table on_problems result_with_problems =
    map_problem java_problem =
        if Java.is_instance java_problem DuplicateNames then Duplicate_Output_Column_Names (Vector.Vector java_problem.duplicatedNames) else
              if Java.is_instance java_problem InvalidNames then Invalid_Output_Column_Names (Vector.Vector java_problem.invalidNames) else
                java_problem
    parsing_problems = Vector.Vector (result_with_problems.problems) . map map_problem
    on_problems.attach_problems_after (Table.Table result_with_problems.value) parsing_problems

## PRIVATE
   Convert True|False|Infer to the correct HeaderBehavior
make_java_headers : (True|False|Infer) -> ExcelReader.HeaderBehavior
make_java_headers headers = case headers of
        True -> ExcelReader.HeaderBehavior.USE_FIRST_ROW_AS_HEADERS
        Infer -> ExcelReader.HeaderBehavior.INFER
        False -> ExcelReader.HeaderBehavior.EXCEL_COLUMN_NAMES
