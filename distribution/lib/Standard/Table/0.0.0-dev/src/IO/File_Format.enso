from Standard.Base import all
import Standard.Table

import Standard.Base.Error.Common as Errors
import Standard.Base.System
import Standard.Table.Data.Match_Columns
from Standard.Base.Error.Problem_Behavior as Problem_Behavior_Module import Problem_Behavior
from Standard.Base.Data.Text.Encoding as Encoding_Module import Encoding
import Standard.Base.Runtime.Ref
import Standard.Table.Internal.Delimited_Reader
import Standard.Table.Internal.Delimited_Writer
from Standard.Table.Errors as Table_Errors import Unsupported_File_Type

from Standard.Table.Data.Data_Formatter as Data_Formatter_Module import Data_Formatter
import Standard.Table.IO.Excel as Excel_Module
import Standard.Table.IO.Quote_Style

## This type needs to be here to allow for the usage of Standard.Table
   functions. Ideally, it would be an interface within Standard.Base and
   expanded by additional implementations in Standard.Table.

## Determines the format of file to use based on the file extension.
type Auto
    type Auto

    ## ADVANCED
       Gets the underlying File_Format for the specified file
    materialise : File->File_Format
    materialise file =
        extension = file.extension

        output = Ref.new Nothing
        if ".txt".equals_ignore_case extension then output.put File_Format.Plain_Text
        if ".log".equals_ignore_case extension then output.put File_Format.Plain_Text
        if ".csv".equals_ignore_case extension then output.put (File_Format.Delimited ',')
        if ".tsv".equals_ignore_case extension then output.put (File_Format.Delimited '\t')
        if ".xlsx".equals_ignore_case extension then output.put File_Format.Excel
        if ".xlsm".equals_ignore_case extension then output.put File_Format.Excel
        if ".xls".equals_ignore_case extension then output.put File_Format.Excel
        if ".xlt".equals_ignore_case extension then output.put File_Format.Excel

        output.get.if_nothing <|
            Error.throw (Unsupported_File_Type file.name)

    ## Implements the `File.read` for this `File_Format`
    read : File -> Problem_Behavior -> Any
    read file on_problems =
        materialised = self.materialise file
        materialised.read file on_problems

    ## Implements the `Table.write` for this `File_Format`.
    write_table : File -> Table -> Existing_File_Behavior -> Match_Columns -> Problem_Behavior -> Nothing
    write_table file table on_existing_file match_columns on_problems =
        materialised = self.materialise file
        materialised.write_table file table on_existing_file match_columns on_problems

## Reads the file to a `Vector` of bytes.
type Bytes
    type Bytes

    ## Implements the `File.read` for this `File_Format`
    read : File -> Problem_Behavior -> Any
    read file _ =
        file.read_bytes

    ## Implements the `Table.write` for this `File_Format`.
    write_table : File -> Table -> Existing_File_Behavior -> Match_Columns -> Problem_Behavior -> Nothing
    write_table _ _ _ _ _ =
        Error.throw (Illegal_Argument_Error "Saving a Table as Bytes is not supported.")

## Reads the file to a `Text` with specified encoding.
type Plain_Text
    type Plain_Text (encoding:Encoding=Encoding.utf_8)

    ## Implements the `File.read` for this `File_Format`
    read : File -> Problem_Behavior -> Any
    read file on_problems =
        file.read_text self.encoding on_problems

    ## Implements the `Table.write` for this `File_Format`.
    write_table : File -> Table -> Existing_File_Behavior -> Match_Columns -> Problem_Behavior -> Nothing
    write_table _ _ _ _ _ =
        Error.throw (Illegal_Argument_Error "Saving a Table as Plain_Text is not directly supported. You may convert the Table to a Text using `Text.from` and then use `Text.write` to write it.")

## Read delimited files such as CSVs into a Table.
type Delimited
    ## Read delimited files such as CSVs into a Table.

       If a row does not match the first row's column count, the function raises
       an `Invalid_Row`. If a quote is opened and never closed, a
       `Mismatched_Quote` warning occurs.

       Arguments:
       - delimiter: The delimiter character to split the file into columns. An
         `Illegal_Argument_Error` error is returned if this is an empty string.
       - encoding: The encoding to use when reading the file.
       - skip_rows: The number of rows to skip from the top of the file.
       - row_limit: The maximum number of rows to read from the file. This count
         does not include the header row (if applicable).
       - quote_style: Specifies the style of quotes used for reading and
         writing.
       - headers: If set to `True`, the first row is used as column names. If
         set to `False`, the column names are generated by adding increasing
         numeric suffixes to the base name `Column` (i.e. `Column_1`,
         `Column_2` etc.). If set to `Infer`, the process tries to infer if
         headers are present on the first row. If the column names are not
         unique, numeric suffixes will be appended to disambiguate them.
       - value_formatter: Formatter to parse text values into numbers, dates,
         times, etc. If `Nothing` values are left as Text.
       - keep_invalid_rows: Specifies whether rows that contain less or more
         columns than expected should be kept (setting the missing columns to
         `Nothing` or dropping the excess columns) or dropped.
       - line_endings: Sets the line ending style to use. Defaults to `Infer` -
         when reading a file or appending to an existing file, the line endings
         are detected from file contents; when writing a new file, the OS
         defaults are used.
       - comment_character: Sets the character which indicates the start of a
         comment within a delimited file. Any line that begins with the comment
         character is skipped. The comment character is treated as any other
         character if it anywhere else than at the beginning of the line. This
         option is only applicable for read mode and does not affect writing. It
         defaults to `Nothing` which means that comments are disabled.
    type Delimited (delimiter:Text) (encoding:Encoding=Encoding.utf_8) (skip_rows:Integer=0) (row_limit:Integer|Nothing=Nothing) (quote_style:Quote_Style=Quote_Style.With_Quotes) (headers:Boolean|Infer=Infer) (value_formatter:Data_Formatter|Nothing=Data_Formatter) (keep_invalid_rows:Boolean=True) (line_endings:Line_Ending_Style=Infer) (comment_character:Text|Nothing=Nothing)

    ## Implements the `File.read` for this `File_Format`
    read : File -> Problem_Behavior -> Any
    read file on_problems =
        Delimited_Reader.read_file self file on_problems

    ## Implements the `Table.write` for this `File_Format`.
    write_table : File -> Table -> Existing_File_Behavior -> Match_Columns -> Problem_Behavior -> Nothing
    write_table file table on_existing_file match_columns on_problems =
        Delimited_Writer.write_file table self file on_existing_file match_columns on_problems

    ## PRIVATE
     Clone the instance with some properties overridden.
     Note: This function is internal until such time as Atom cloning with modification is built into Enso.
    clone : Text->Text->(Boolean|Infer)->Data_Formatter->Boolean->(Text|Nothing)->(Text|Nothing)->Delimited
    clone (quote_style=self.quote_style) (headers=self.headers) (value_formatter=self.value_formatter) (keep_invalid_rows=self.keep_invalid_rows) (line_endings=self.line_endings) (comment_character=self.comment_character) =
        Delimited self.delimiter self.encoding self.skip_rows self.row_limit quote_style headers value_formatter keep_invalid_rows line_endings comment_character

    ## Create a clone of this with specified quoting settings.
    with_quotes : Text->Text->Boolean->Delimited
    with_quotes quote='"' quote_escape=quote always_quote=False =
        self.clone quote_style=(Quote_Style.With_Quotes always_quote=always_quote quote=quote quote_escape=quote_escape)

    ## Create a clone of this with specified quoting settings.
    without_quotes : Delimited
    without_quotes =
        self.clone quote_style=Quote_Style.No_Quotes

    ## Create a clone of this with first row treated as header.
    with_headers : Delimited
    with_headers = self.clone headers=True

    ## Create a clone of this where the first row is treated as data, not a
       header.
    without_headers : Delimited
    without_headers = self.clone headers=False

    ## Create a clone of this with value parsing.

       A custom `Data_Formatter` can be provided to customize parser options.
    with_parsing : Data_Formatter -> Delimited
    with_parsing (value_formatter=Data_Formatter) =
        self.clone value_formatter=value_formatter

    ## Create a clone of this without value parsing.
    without_parsing : Delimited
    without_parsing =
        self.clone value_formatter=Nothing

    ## Creates a clone of this with a changed line ending style.
    with_line_endings : Line_Ending_Style -> Delimited
    with_line_endings line_endings=Infer =
        self.clone line_endings=line_endings

    ## Creates a clone of this with comment parsing enabled.
    with_comments : Text -> Delimited
    with_comments comment_character='#' =
        self.clone comment_character=comment_character

    ## Creates a clone of this with comment parsing disabled.
    without_comments : Delimited
    without_comments =
        self.clone comment_character=Nothing

## A setting to infer the default behaviour of some option.
type Infer

## Read the file to a `Table` from an Excel file
type Excel
    ## Read Excels files into a Table or Vector.

       Arguments:
       - section: The `Excel_Section` to read from the workbook.
         This can be one of:
         - `Sheet_Names` - outputs a `Vector` of sheet names.
         - `Range_Names` - outputs a `Vector` of range names.
         - `Sheet` - outputs a `Table` containing the specified sheet.
         - `Cell_Range` - outputs a `Table` containing the specified range.
       - headers: If set to `True`, the first row is used as column names. If
         set to `False`, the column names are Excel column names. If set to
         `Infer`, the process tries to infer if headers are present on the first
          row. If the column names are not unique, numeric suffixes will be
          appended to disambiguate them.
       - xls_format:
         If set to `True`, the file is read as an Excel 95-2003 format.
         If set to `False`, the file is read as an Excel 2007+ format.
         `Infer` will attempt to deduce this from the extension of the filename.
    type Excel (section:Excel_Section=Excel_Module.Sheet) (headers:(True|False|Infer)=Infer) (xls_format:(True|False|Infer)=Infer)

    ## Implements the `File.read` for this `File_Format`
    read : File -> Problem_Behavior -> Any
    read file on_problems =
        format = Excel.is_xls_format self.xls_format file
        Excel_Module.read_excel file self.section self.headers on_problems format

    ## Implements the `Table.write` for this `File_Format`.
    write_table : File -> Table -> Existing_File_Behavior -> Match_Columns -> Problem_Behavior -> Nothing
    write_table file table on_existing_file match_columns on_problems =
        format = Excel.is_xls_format self.xls_format file

        case self.section of
            Excel_Module.Sheet_Names -> Error.throw (Illegal_Argument_Error "Sheet_Names cannot be used for `write`.")
            Excel_Module.Range_Names -> Error.throw (Illegal_Argument_Error "Range_Names cannot be used for `write`.")
            _ -> Excel_Module.write_excel file table on_existing_file self.section self.headers match_columns on_problems format

    ## PRIVATE
       Resolve the xls_format setting to a boolean.
    is_xls_format : (Boolean|Infer) -> File -> Boolean
    is_xls_format xls_format file =
        if xls_format != Infer then xls_format else
            extension = file.extension
            (extension.equals_ignore_case ".xls") || (extension.equals_ignore_case ".xlt")
