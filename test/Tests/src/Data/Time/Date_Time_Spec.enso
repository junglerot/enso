from Standard.Base import all
import Standard.Base.Error.Common.Type_Error
import Standard.Base.Error.Time_Error.Time_Error

from Standard.Test import Test, Test_Suite
import Standard.Test.Extensions

import project.Data.Time.Date_Part_Spec

polyglot java import org.enso.base.Time_Utils
polyglot java import java.time.ZonedDateTime
polyglot java import java.time.LocalDateTime
polyglot java import java.time.ZoneOffset
polyglot java import java.time.format.DateTimeFormatter
polyglot java import java.lang.Exception as JException

spec =
    spec_with "Date_Time" enso_datetime Date_Time.parse
    spec_with "JavascriptDate" js_datetime js_parse nanoseconds_loss_in_precision=True
    spec_with "JavaZonedDateTime" java_datetime java_parse
    spec_with "JavascriptDataInArray" js_array_datetime js_parse nanoseconds_loss_in_precision=True

    Test.group "Date_Time equality" <|
        Test.specify "should work with values coming from various sources" <|
            d1 = Date_Time.new 2022 3 4 5 6
            d2 = java_datetime 2022 3 4 5 6
            d1 . should_equal d2

            d3 = Date_Time.new 2022 (zone = Time_Zone.utc)
            d4 = java_datetime 2022 (zone = Time_Zone.utc)
            d5 = js_datetime 2022 (zone = Time_Zone.utc)

            d3 . should_equal d4
            d4 . should_equal d5

        Test.specify "should provide equality operator" <|
            (Date_Time.new 2022 zone=(Time_Zone.parse "CET")).should_not_equal (Date_Time.new 2022 zone=(Time_Zone.parse "UTC"))
            (Date_Time.new 2022 zone=(Time_Zone.parse "CET")).should_equal (Date_Time.new 2022 zone=(Time_Zone.parse "CET"))
            (Date_Time.new 2022 12 12).should_equal (Date_Time.new 2022 12 12)
            (Date_Time.new 2022 12 12).should_not_equal (Date_Time.new 1996)

spec_with name create_new_datetime parse_datetime nanoseconds_loss_in_precision=False =
    Test.group name <|

        Test.specify "should create time" <|
            time = create_new_datetime 1970 (zone = Time_Zone.utc)
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal Time_Zone.utc.zone_id

        Test.specify "should handle errors when creating time" <|
            case create_new_datetime 1970 0 0 . catch of
                Time_Error.Error msg ->
                    msg . should_equal "Invalid value for MonthOfYear (valid values 1 - 12): 0"
                result ->
                    Test.fail ("Unexpected result: " + result.to_text)

        Test.specify "should format using provided pattern" <|
            text = create_new_datetime 1970 (zone = Time_Zone.utc) . format "yyyy-MM-dd'T'HH:mm:ss"
            text . should_equal "1970-01-01T00:00:00"

        Test.specify "should format using default pattern" <|
            text = create_new_datetime 1970 (zone = Time_Zone.utc) . to_text
            text . should_equal "1970-01-01T00:00:00Z[UTC]"

        Test.specify "should convert to Json" <|
            time = create_new_datetime 1970 12 21 (zone = Time_Zone.utc)
            time.to_json.should_equal <|
                zone_pairs = [["zone", Time_Zone.utc]]
                time_pairs = [["year", time.year], ["month", time.month], ["day", time.day], ["hour", time.hour], ["minute", time.minute], ["second", time.second], ["nanosecond", time.nanosecond]]
                JS_Object.from_pairs ([["type", "Date_Time"], ["constructor", "new"]] + time_pairs + zone_pairs) . to_text

        Test.specify "should parse default time format" <|
            text = create_new_datetime 1970 (zone = Time_Zone.utc) . to_text
            time = parse_datetime text
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal Time_Zone.utc.zone_id

        Test.specify "should parse local time adding system zone" <|
            time = parse_datetime "1970-01-01T00:00:01"
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 1
            time . nanosecond . should_equal 0
            time . zone . should_equal Time_Zone.system

        Test.specify "should parse time Z" <|
            time = parse_datetime "1582-10-15T00:00:01Z"
            time . to_enso_epoch_seconds . should_equal 1
            time . zone . zone_id . should_equal "Z"

        Test.specify "should parse time UTC" <|
            time = parse_datetime "1582-10-15T00:00:01Z[UTC]"
            time . to_enso_epoch_seconds . should_equal 1
            time . zone . zone_id . should_equal "UTC"

        Test.specify "should parse time with nanoseconds" <|
            time = parse_datetime "1970-01-01T00:00:01.123456789Z"
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 1
            if nanoseconds_loss_in_precision then time . nanosecond . should_equal 123000000 else
                time . nanosecond . should_equal 123456789
            time . zone . zone_id . should_equal "Z"

        Test.specify "should parse time with offset-based zone" <|
            time = parse_datetime "1970-01-01T00:00:01+01:00"
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 1
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal (Time_Zone.new 1 . zone_id)

        Test.specify "should parse time with id-based zone" <|
            time = parse_datetime "1970-01-01T00:00:01+01:00[Europe/Paris]"
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 1
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal "Europe/Paris"

        Test.specify "should throw error when parsing invalid time" <|
            case parse_datetime "2008-1-1" . catch of
                Time_Error.Error msg ->
                    msg . should_equal "Text '2008-1-1' could not be parsed at index 5"
                result ->
                    Test.fail ("Unexpected result: " + result.to_text)

        Test.specify "should parse custom format of zoned time" <|
            time = parse_datetime "2020-05-06 04:30:20 UTC" "yyyy-MM-dd HH:mm:ss z"
            time . year . should_equal 2020
            time . month . should_equal 5
            time . day . should_equal 6
            time . hour . should_equal 4
            time . minute . should_equal 30
            time . second . should_equal 20
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal "Etc/UTC"

        Test.specify "should parse custom format of local time" <|
            time = parse_datetime "06 of May 2020 at 04:30AM" "dd 'of' MMMM yyyy 'at' hh:mma"
            time . year . should_equal 2020
            time . month . should_equal 5
            time . day . should_equal 6
            time . hour . should_equal 4
            time . minute . should_equal 30
            time . second . should_equal 0
            time . nanosecond . should_equal 0

        Test.specify "should throw error when parsing custom format" <|
            time = parse_datetime "2008-01-01" "yyyy-MM-dd'T'HH:mm:ss'['z']'"
            case time.catch of
                Time_Error.Error msg ->
                    msg . should_equal "Text '2008-01-01' could not be parsed at index 10"
                result ->
                    Test.fail ("Unexpected result: " + result.to_text)

        Test.specify "should get Enso epoch seconds" <|
            (create_new_datetime 1582 10 15 0 0 8 (zone = Time_Zone.utc)).to_enso_epoch_seconds . should_equal 8
            (Date_Time.enso_epoch_start + (Duration.new minutes=2)).to_enso_epoch_seconds . should_equal (2 * 60)
            (Date_Time.enso_epoch_start - (Duration.new minutes=2)).to_enso_epoch_seconds . should_equal -(2 * 60)

        Test.specify "should get Enso epoch millis" <|
            (create_new_datetime 1582 10 15 0 0 8 (zone = Time_Zone.utc)).to_enso_epoch_milliseconds . should_equal 8000
            (Date_Time.enso_epoch_start + (Duration.new seconds=2)).to_enso_epoch_milliseconds . should_equal (2 * 1000)

        Test.specify "should set offset-based timezone" <|
            tz = Time_Zone.new 1 1 1
            time = create_new_datetime 1970 (zone = Time_Zone.utc) . at_zone tz
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 1
            time . minute . should_equal 1
            time . second . should_equal 1
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal tz.zone_id

        Test.specify "should set id-based timezone" <|
            tz = Time_Zone.parse "Europe/Moscow"
            time = create_new_datetime 1970 (zone = Time_Zone.utc) . at_zone tz
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 3
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal tz.zone_id

        Test.specify "should get time of day from offsed-based time" <|
            time = parse_datetime "1970-01-01T00:00:01+01:00" . time_of_day
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 1
            time . nanosecond . should_equal 0

        Test.specify "should get time of day from id-based time" <|
            time = parse_datetime "1970-01-01T00:00:01+01:00[Europe/Paris]" . time_of_day
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 1
            time . nanosecond . should_equal 0

        Test.specify "should get date from offsed-based time" <|
            time = parse_datetime "1970-01-01T00:00:01+01:00" . date
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1

        Test.specify "should get date from id-based time" <|
            time = parse_datetime "1970-01-01T00:00:01+01:00[Europe/Paris]" . date
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1

        Test.specify "should add time interval" <|
            time = create_new_datetime 1970 (zone = Time_Zone.utc) + (Duration.new nanoseconds=1)
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 1
            time . zone . should_equal Time_Zone.utc

        Test.specify "should add date interval" <|
            time = (create_new_datetime 1970 (zone = Time_Zone.utc)) + (Period.new months=1)
            time . year . should_equal 1970
            time . month . should_equal 2
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal Time_Zone.utc.zone_id

        Test.specify "should add mixed date time interval" <|
            time = create_new_datetime 1970 (zone = Time_Zone.utc) + (Period.new months=1) + (Duration.new hours=3)
            time . year . should_equal 1970
            time . month . should_equal 2
            time . day . should_equal 1
            time . hour . should_equal 3
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal Time_Zone.utc.zone_id

        Test.specify "should subtract time interval" <|
            time = create_new_datetime 1970 (zone = Time_Zone.utc) - (Duration.new hours=1)
            time . year . should_equal 1969
            time . month . should_equal 12
            time . day . should_equal 31
            time . hour . should_equal 23
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal Time_Zone.utc.zone_id

        Test.specify "should subtract date interval" <|
            time = create_new_datetime 1970 (zone = Time_Zone.utc) - (Period.new months=1)
            time . year . should_equal 1969
            time . month . should_equal 12
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal Time_Zone.utc.zone_id

        Test.specify "should subtract mixed date time interval" <|
            time = create_new_datetime 1970 (zone = Time_Zone.utc) - (Period.new months=1) - (Duration.new hours=3)
            time . year . should_equal 1969
            time . month . should_equal 11
            time . day . should_equal 30
            time . hour . should_equal 21
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal Time_Zone.utc.zone_id

        Test.specify "should support mixed interval operators" <|
            time = create_new_datetime 1970 (zone = Time_Zone.utc) - (Period.new months=1) + (Duration.new hours=12)
            time . year . should_equal 1969
            time . month . should_equal 12
            time . day . should_equal 1
            time . hour . should_equal 12
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal Time_Zone.utc.zone_id

        Test.specify "should get default ordered comparator for datetimes" <|
            Comparable.from (create_new_datetime 2023 2 3 23 59) . should_equal Default_Ordered_Comparator
            Comparable.from (parse_datetime "2021-01-01T00:30:12.7102[UTC]") . should_equal Default_Ordered_Comparator
            Comparable.from (create_new_datetime 2022 10 31 2 30 55 1234) . should_equal Default_Ordered_Comparator

        Test.specify "should be comparable" <|
            time_1 = parse_datetime "2021-01-01T00:30:12.7102[UTC]"
            time_2 = parse_datetime "2021-01-01T04:00:10.0+04:00"
            (time_1 == time_2) . should_be_false
            time_1==time_1 . should_be_true
            time_1!=time_2 . should_be_true
            time_1>time_2 . should_be_true
            time_1<time_2 . should_be_false

            tod = Time_Of_Day.new 4 0 10
            Ordering.compare time_1 tod . should_fail_with Type_Error.Error
            time_1<tod . should_fail_with Type_Error.Error
            time_1==tod . should_be_false

            date = Date.new 2021 1 1
            Ordering.compare time_1 date . should_fail_with Type_Error.Error
            time_1==date . should_be_false

        Test.specify "simple computations before Enso epoch should produce a warning" <|
            expect_value_with_warning actual_value expected_value=Nothing =
                if expected_value != Nothing then actual_value . should_equal expected_value
                (((Warning.get_all actual_value).length) > 0) . should_be_true

            expect_value_with_warning (Date_Time.enso_epoch_start - (Duration.new hours=3)) (create_new_datetime 1582 10 14 21 (zone = Time_Zone.utc))
            expect_value_with_warning (Date_Time.enso_epoch_start - (Duration.new minutes=1)) (create_new_datetime 1582 10 14 23 59 (zone = Time_Zone.utc))

            expect_value_with_warning (create_new_datetime 100).week_of_year
            expect_value_with_warning (create_new_datetime 100).is_leap_year
            expect_value_with_warning (create_new_datetime 100).length_of_year
            expect_value_with_warning (create_new_datetime 100 4).length_of_month
            expect_value_with_warning (create_new_datetime 100 4 15).day_of_week

        Test.specify "should create datetime before epoch start" <|
            (create_new_datetime 100 1 2 3 4).year   . should_equal 100
            (create_new_datetime 100 1 2 3 4).month  . should_equal 1
            (create_new_datetime 100 1 2 3 4).day    . should_equal 2
            (create_new_datetime 100 1 2 3 4).hour   . should_equal 3
            (create_new_datetime 100 1 2 3 4).minute . should_equal 4

        Test.specify "should correctly determine the type of datetime" <|
            new_datetime = create_new_datetime 2020 6 1 10 0 0
            parsed_datetime = parse_datetime "2021-02-01T00:30:12.7102[UTC]"

            Meta.type_of new_datetime . should_equal_type Date_Time
            Meta.type_of parsed_datetime . should_equal_type Date_Time

        max_nanos = 999999999
        Test.specify "should allow to find start/end of a Date_Period containing the current datetime" <|
            d1 = create_new_datetime 2022 9 12 15 37 58
            d1.start_of Date_Period.Year . should_equal (Date_Time.new 2022 1 1)
            d1.end_of Date_Period.Year . should_equal (Date_Time.new 2022 12 31 23 59 59 nanosecond=max_nanos)
            d1.start_of Date_Period.Quarter . should_equal (Date_Time.new 2022 7 1)
            d1.end_of Date_Period.Quarter . should_equal (Date_Time.new 2022 9 30 23 59 59 nanosecond=max_nanos)
            d1.start_of Date_Period.Month . should_equal (Date_Time.new 2022 9 1)
            d1.end_of Date_Period.Month . should_equal (Date_Time.new 2022 9 30 23 59 59 nanosecond=max_nanos)
            d1.start_of (Date_Period.Week) . should_equal (Date_Time.new 2022 9 12)
            d1.end_of (Date_Period.Week) . should_equal (Date_Time.new 2022 9 18 23 59 59 nanosecond=max_nanos)
            d1.start_of (Date_Period.Week first_day=Day_Of_Week.Sunday) . should_equal (Date_Time.new 2022 9 11)
            d1.end_of (Date_Period.Week first_day=Day_Of_Week.Sunday) . should_equal (Date_Time.new 2022 9 17 23 59 59 nanosecond=max_nanos)
            d1.start_of (Date_Period.Week first_day=Day_Of_Week.Saturday) . should_equal (Date_Time.new 2022 9 10)
            d1.end_of (Date_Period.Week first_day=Day_Of_Week.Saturday) . should_equal (Date_Time.new 2022 9 16 23 59 59 nanosecond=max_nanos)

            d2 = create_new_datetime 2022 2 6 12 34 56 123456789
            d2.start_of Date_Period.Quarter . should_equal (Date_Time.new 2022 1 1)
            d2.end_of Date_Period.Quarter . should_equal (Date_Time.new 2022 3 31 23 59 59 nanosecond=max_nanos)
            d2.start_of Date_Period.Month . should_equal (Date_Time.new 2022 2 1)
            d2.end_of Date_Period.Month . should_equal (Date_Time.new 2022 2 28 23 59 59 nanosecond=max_nanos)
            d2.start_of (Date_Period.Week) . should_equal (Date_Time.new 2022 1 31)
            d2.end_of (Date_Period.Week) . should_equal (Date_Time.new 2022 2 6 23 59 59 nanosecond=max_nanos)
            d2.start_of (Date_Period.Week first_day=Day_Of_Week.Sunday) . should_equal (Date_Time.new 2022 2 6)
            d2.end_of (Date_Period.Week first_day=Day_Of_Week.Sunday) . should_equal (Date_Time.new 2022 2 12 23 59 59 nanosecond=max_nanos)

            d3 = create_new_datetime 2020 2 19
            d3.start_of Date_Period.Year . should_equal (Date_Time.new 2020 1 1)
            d3.end_of Date_Period.Year . should_equal (Date_Time.new 2020 12 31 23 59 59 nanosecond=max_nanos)
            d3.start_of Date_Period.Month . should_equal (Date_Time.new 2020 2 1)
            d3.end_of Date_Period.Month . should_equal (Date_Time.new 2020 2 29 23 59 59 nanosecond=max_nanos)
            d3.start_of (Date_Period.Week) . should_equal (Date_Time.new 2020 2 17)
            d3.end_of (Date_Period.Week) . should_equal (Date_Time.new 2020 2 23 23 59 59 nanosecond=max_nanos)
            d3.start_of (Date_Period.Week first_day=Day_Of_Week.Sunday) . should_equal (Date_Time.new 2020 2 16)
            d3.end_of (Date_Period.Week first_day=Day_Of_Week.Sunday) . should_equal (Date_Time.new 2020 2 22 23 59 59 nanosecond=max_nanos)

            d4 = create_new_datetime 1970 12 31 23 59 59 nanosecond=max_nanos
            d4.start_of Date_Period.Year . should_equal (Date_Time.new 1970 1 1)
            d4.end_of Date_Period.Year . should_equal (Date_Time.new 1970 12 31 23 59 59 nanosecond=max_nanos)
            d4.start_of Date_Period.Quarter . should_equal (Date_Time.new 1970 10 1)
            d4.end_of Date_Period.Quarter . should_equal (Date_Time.new 1970 12 31 23 59 59 nanosecond=max_nanos)
            d4.start_of Date_Period.Month . should_equal (Date_Time.new 1970 12 1)
            d4.end_of Date_Period.Month . should_equal (Date_Time.new 1970 12 31 23 59 59 nanosecond=max_nanos)

            d5 = create_new_datetime 2040 1 1
            d5.start_of Date_Period.Year . should_equal (Date_Time.new 2040 1 1)
            d5.end_of Date_Period.Year . should_equal (Date_Time.new 2040 12 31 23 59 59 nanosecond=max_nanos)
            d5.start_of Date_Period.Quarter . should_equal (Date_Time.new 2040 1 1)
            d5.end_of Date_Period.Quarter . should_equal (Date_Time.new 2040 3 31 23 59 59 nanosecond=max_nanos)
            d5.start_of Date_Period.Month . should_equal (Date_Time.new 2040 1 1)
            d5.end_of Date_Period.Month . should_equal (Date_Time.new 2040 1 31 23 59 59 nanosecond=max_nanos)

            (create_new_datetime 2000 7 1 14 54).start_of Date_Period.Quarter . should_equal (Date_Time.new 2000 7 1)
            (create_new_datetime 2000 6 30 15 34).start_of Date_Period.Quarter . should_equal (Date_Time.new 2000 4 1)

            (create_new_datetime 2000 7 1 16 50).end_of Date_Period.Quarter . should_equal (Date_Time.new 2000 9 30 23 59 59 nanosecond=max_nanos)
            (create_new_datetime 2000 6 30 17 40).end_of Date_Period.Quarter . should_equal (Date_Time.new 2000 6 30 23 59 59 nanosecond=max_nanos)

        Test.specify "should allow to find start/end of a Time_Period containing the current datetime" <|
            d1 = create_new_datetime 2022 9 12 15 37 58 123456789
            d1.start_of Time_Period.Day . should_equal (Date_Time.new 2022 9 12)
            d1.end_of Time_Period.Day . should_equal (Date_Time.new 2022 9 12 23 59 59 nanosecond=max_nanos)
            d1.start_of Time_Period.Hour . should_equal (Date_Time.new 2022 9 12 15 0 0 0)
            d1.end_of Time_Period.Hour . should_equal (Date_Time.new 2022 9 12 15 59 59 nanosecond=max_nanos)
            d1.start_of Time_Period.Minute . should_equal (Date_Time.new 2022 9 12 15 37 0 0)
            d1.end_of Time_Period.Minute . should_equal (Date_Time.new 2022 9 12 15 37 59 nanosecond=max_nanos)
            d1.start_of Time_Period.Second . should_equal (Date_Time.new 2022 9 12 15 37 58 0)
            d1.end_of Time_Period.Second . should_equal (Date_Time.new 2022 9 12 15 37 58 nanosecond=max_nanos)

            d2 = create_new_datetime 1970 1 1 0 0 0
            d2.start_of Time_Period.Day . should_equal (Date_Time.new 1970)
            d2.end_of Time_Period.Day . should_equal (Date_Time.new 1970 1 1 23 59 59 nanosecond=max_nanos)
            d2.start_of Time_Period.Hour . should_equal (Date_Time.new 1970 1 1 0 0 0 0)
            d2.end_of Time_Period.Hour . should_equal (Date_Time.new 1970 1 1 0 59 59 nanosecond=max_nanos)
            d2.start_of Time_Period.Minute . should_equal (Date_Time.new 1970 1 1 0 0 0 0)
            d2.end_of Time_Period.Minute . should_equal (Date_Time.new 1970 1 1 0 0 59 nanosecond=max_nanos)
            d2.start_of Time_Period.Second . should_equal (Date_Time.new 1970 1 1 0 0 0 0)
            d2.end_of Time_Period.Second . should_equal (Date_Time.new 1970 1 1 0 0 0 nanosecond=max_nanos)

            d3 = create_new_datetime 2100 12 31 23 59 59 max_nanos
            d3.start_of Time_Period.Day . should_equal (Date_Time.new 2100 12 31)
            d3.end_of Time_Period.Day . should_equal (Date_Time.new 2100 12 31 23 59 59 nanosecond=max_nanos)
            d3.start_of Time_Period.Hour . should_equal (Date_Time.new 2100 12 31 23 0 0 0)
            d3.end_of Time_Period.Hour . should_equal (Date_Time.new 2100 12 31 23 59 59 nanosecond=max_nanos)
            d3.start_of Time_Period.Minute . should_equal (Date_Time.new 2100 12 31 23 59 0 0)
            d3.end_of Time_Period.Minute . should_equal (Date_Time.new 2100 12 31 23 59 59 nanosecond=max_nanos)
            d3.start_of Time_Period.Second . should_equal (Date_Time.new 2100 12 31 23 59 59 0)
            d3.end_of Time_Period.Second . should_equal (Date_Time.new 2100 12 31 23 59 59 nanosecond=max_nanos)

        offset_1_h = ZoneOffset.ofTotalSeconds 3600
        offset_2_h = ZoneOffset.ofTotalSeconds 2*3600
        tz = Time_Zone.parse "Europe/Warsaw"
        js_dst_pending = if name.contains "Javascript" then
            "Javascript implementation does not support time zones correctly, so the tests for conversion around DST switches would fail and thus are disabled. We may revisit once JS gets better time support, see project Temporal: https://tc39.es/proposal-temporal/docs/ and our Pivotal issue tracking our integration: https://www.pivotaltracker.com/story/show/183261296"
        Test.specify "should find start/end of a Date_Period or Time_Period containing the current datetime correctly near the spring DST switch" pending=js_dst_pending <|
            d1 = create_new_datetime 2022 3 27 1 34 15 0 tz
            d2 = create_new_datetime 2022 3 27 3 34 15 0 tz
            d1_plus = d1 + (Duration.new hours=1)
            d1_plus . should_equal d2

            check_dates_spring date =
                date.start_of Time_Period.Day . should_equal (Date_Time.new 2022 3 27 zone=tz)
                date.end_of Time_Period.Day . should_equal (Date_Time.new 2022 3 27 23 59 59 nanosecond=max_nanos zone=tz)

                date.start_of Date_Period.Month . should_equal (Date_Time.new 2022 3 1 zone=tz)
                date.end_of Date_Period.Month . should_equal (Date_Time.new 2022 3 31 23 59 59 nanosecond=max_nanos zone=tz)

            check_dates_spring d1
            check_dates_spring d2

            d1_start = d1.start_of Time_Period.Hour
            d1_end = d1.end_of Time_Period.Hour
            (d1.to_enso_epoch_seconds - d1_start.to_enso_epoch_seconds) . should_equal (34*60 + 15)
            (d1_end.to_enso_epoch_seconds - d1.to_enso_epoch_seconds) . should_equal (60*60 - (34*60 + 15) - 1)
            d1_start . should_equal (Date_Time.new 2022 3 27 1 zone=tz)
            d1_end . should_equal (Date_Time.new 2022 3 27 1 59 59 nanosecond=max_nanos zone=tz)
            d1.start_of Time_Period.Minute . should_equal (Date_Time.new 2022 3 27 1 34 0 0 zone=tz)
            d1.end_of Time_Period.Minute . should_equal (Date_Time.new 2022 3 27 1 34 59 nanosecond=max_nanos zone=tz)

            d2_start = d2.start_of Time_Period.Hour
            d2_end = d2.end_of Time_Period.Hour
            (d2.to_enso_epoch_seconds - d2_start.to_enso_epoch_seconds) . should_equal (34*60 + 15)
            (d2_end.to_enso_epoch_seconds - d2.to_enso_epoch_seconds) . should_equal (60*60 - (34*60 + 15) - 1)
            d2_start . should_equal (Date_Time.new 2022 3 27 3 zone=tz)
            d2_end . should_equal (Date_Time.new 2022 3 27 3 59 59 nanosecond=max_nanos zone=tz)

        dst_overlap_message = "We cannot correctly migrate the datetime inside of the timeline overlap through the polyglot boundary - as due to polyglot conversion limitation, always the earlier one is chosen. See the bug report: https://github.com/oracle/graal/issues/4918"
        Test.specify "should find start/end of a Date_Period or Time_Period containing the current datetime correctly near the autumn DST switch" pending=dst_overlap_message <|
            d3 = create_new_datetime 2022 10 30 2 30 15 0 tz
            d4 = d3 + (Duration.new hours=1)

            d3.hour . should_equal 2
            d4.hour . should_equal 2
            d3.minute . should_equal 30
            d4.minute . should_equal 30
            (d4.to_enso_epoch_milliseconds - d3.to_enso_epoch_milliseconds) . should_equal 60*60*1000
            Time_Utils.get_datetime_offset d3 . should_equal offset_2_h
            Time_Utils.get_datetime_offset d4 . should_equal offset_1_h

            check_dates_autumn date =
                date.start_of Time_Period.Day . should_equal (Date_Time.new 2022 10 30 zone=tz)
                date.end_of Time_Period.Day . should_equal (Date_Time.new 2022 10 30 23 59 59 nanosecond=max_nanos zone=tz)

                date.start_of Date_Period.Month . should_equal (Date_Time.new 2022 10 1 zone=tz)
                date.end_of Date_Period.Month . should_equal (Date_Time.new 2022 10 31 23 59 59 nanosecond=max_nanos zone=tz)

            check_dates_autumn d3
            check_dates_autumn d4

            d3_start = d3.start_of Time_Period.Hour
            d3_end = d3.end_of Time_Period.Hour
            (d3.to_enso_epoch_seconds - d3_start.to_enso_epoch_seconds) . should_equal (30*60 + 15)
            (d3_end.to_enso_epoch_seconds - d3.to_enso_epoch_seconds) . should_equal (60*60 - (30*60 + 15) - 1)
            d3_start . should_equal (Date_Time.new 2022 10 30 2 zone=tz)
            Time_Utils.get_datetime_offset d3_start . should_equal offset_2_h
            d3_end . should_equal (Date_Time.new 2022 10 30 2 59 59 nanosecond=max_nanos zone=tz)
            Time_Utils.get_datetime_offset d3_end . should_equal offset_2_h

            d4_start = d4.start_of Time_Period.Hour
            d4_end = d4.end_of Time_Period.Hour
            (d4.to_enso_epoch_seconds - d4_start.to_enso_epoch_seconds) . should_equal (30*60 + 15)
            (d4_end.to_enso_epoch_seconds - d4.to_enso_epoch_seconds) . should_equal (60*60 - (30*60 + 15) - 1)
            d4_start.hour . should_equal 2
            d4_start.minute . should_equal 0
            Time_Utils.get_datetime_offset d4_start . should_equal offset_1_h
            d4_end.hour . should_equal 2
            d4_end.minute . should_equal 59
            d4_end.second . should_equal 59
            d4_end.nanosecond . should_equal max_nanos
            Time_Utils.get_datetime_offset d4_end . should_equal offset_1_h

        Test.specify "should allow to shift the date by N working days" <|
            # 2000-2-1 is a Tuesday
            create_new_datetime 2000 2 1 12 30 . add_work_days 0 . should_equal (Date_Time.new 2000 2 1 12 30)
            create_new_datetime 2000 2 1 12 15 55 . add_work_days . should_equal (Date_Time.new 2000 2 2 12 15 55)
            create_new_datetime 2000 2 1 . add_work_days 2 . should_equal (Date_Time.new 2000 2 3)

            create_new_datetime 2000 2 1 23 59 . add_work_days 21 . should_equal (Date_Time.new 2000 3 1 23 59)

            # 2000-2-5 is a Saturday
            create_new_datetime 2000 2 5 0 10 . add_work_days 0 . should_equal (Date_Time.new 2000 2 7 0 10)
            create_new_datetime 2000 2 5 23 30 . add_work_days 1 . should_equal (Date_Time.new 2000 2 8 23 30)
            create_new_datetime 2000 2 5 . add_work_days 2 . should_equal (Date_Time.new 2000 2 9)

            # 2000-2-6 is a Sunday
            create_new_datetime 2000 2 6 16 50 . add_work_days 0 . should_equal (Date_Time.new 2000 2 7 16 50)
            create_new_datetime 2000 2 6 17 17 . add_work_days 1 . should_equal (Date_Time.new 2000 2 8 17 17)

            # Behaviour in February depending on leap year.
            create_new_datetime 2000 2 27 12 10 . add_work_days 3 . should_equal (Date_Time.new 2000 3 2 12 10)
            create_new_datetime 1999 2 27 12 10 . add_work_days 3 . should_equal (Date_Time.new 1999 3 4 12 10)

        Test.specify "should handle shifting dates around spring DST edge cases" <|
            # 2022-10-30 and 2022-03-27 are DST switch days, Sundays.
            create_new_datetime 2022 10 30 2 30 55 1234 . add_work_days 0 . should_equal (create_new_datetime 2022 10 31 2 30 55 1234)
            create_new_datetime 2022 10 30 1 30 . add_work_days 1 . should_equal (Date_Time.new 2022 11 1 1 30)
            create_new_datetime 2022 10 30 3 30 . add_work_days 1 . should_equal (Date_Time.new 2022 11 1 3 30)

            create_new_datetime 2022 3 27 1 30 . add_work_days 0 . should_equal (Date_Time.new 2022 3 28 1 30)
            create_new_datetime 2022 3 27 3 30 . add_work_days 1 . should_equal (Date_Time.new 2022 3 29 3 30)

        Test.specify "should handle shifting dates around autumn DST edge cases" pending=dst_overlap_message <|
            d3 = create_new_datetime 2022 10 30 2 30 15 0 tz
            d4 = d3 + (Duration.new hours=1)

            # TODO we need to check and document the actual behaviour once it is expressible, it may be equally acceptable to shift to 3:30 instead of 2:30.
            d4 . add_work_days 0 . should_equal (Date_Time.new 2022 10 31 2 30 15 0 tz)

        Test.specify "should allow to shift the date by negative amount of working days" <|
            # 2000-2-1 is a Tuesday
            create_new_datetime 2000 2 1 12 30 . add_work_days -1 . should_equal (Date_Time.new 2000 1 31 12 30)
            create_new_datetime 2000 2 1 13 30 . add_work_days -2 . should_equal (Date_Time.new 2000 1 28 13 30)

            # 2000-2-6 is a Sunday
            create_new_datetime 2000 2 6 14 45 . add_work_days -1 . should_equal (Date_Time.new 2000 2 4 14 45)
            create_new_datetime 2000 2 6 0 1 . add_work_days -2 . should_equal (Date_Time.new 2000 2 3 0 1)
            create_new_datetime 2000 2 6 23 59 . add_work_days -6 . should_equal (Date_Time.new 2000 1 28 23 59)

        Test.specify "should allow to shift the date by N working days, skipping custom holidays" <|
            all_year_holiday year =
                first_day = Date.new year 1 1
                Vector.new first_day.length_of_year (n -> first_day + (Period.new days=n))
            holiday_november year =
                [Date.new year 11 1, Date.new year 11 2, Date.new year 11 11]
            # We duplicate the holiday entries to check that the functions are resilient to such input data.
            duplicated_holiday_november year =
                holiday_november year + holiday_november year + holiday_november year

            # The whole year 1999 is skipped as it's marked as holiday, and 1st and 2nd of January of 2000 are a weekend.
            create_new_datetime 1999 3 23 12 10 . add_work_days 0 (all_year_holiday 1999) . should_equal (Date_Time.new 2000 1 3 12 10)
            create_new_datetime 1999 3 23 15 50 . add_work_days 1 (all_year_holiday 1999) . should_equal (Date_Time.new 2000 1 4 15 50)

            # When going backwards, again whole 1999 is skipped and we wind back at Thursday 31 December 1998.
            create_new_datetime 1999 3 23 22 40 . add_work_days -1 (all_year_holiday 1999) . should_equal (Date_Time.new 1998 12 31 22 40)

            create_new_datetime 1999 10 30 11 30 . add_work_days 0 (holiday_november 1999) . should_equal (Date_Time.new 1999 11 3 11 30)
            create_new_datetime 1999 10 30 12 30 . add_work_days 1 (holiday_november 1999) . should_equal (Date_Time.new 1999 11 4 12 30)
            create_new_datetime 1999 10 30 23 59 . add_work_days -1 (holiday_november 1999) . should_equal (Date_Time.new 1999 10 29 23 59)
            create_new_datetime 1999 10 30 14 40 . add_work_days 0 (duplicated_holiday_november 1999) . should_equal (Date_Time.new 1999 11 3 14 40)
            create_new_datetime 1999 10 30 15 50 . add_work_days 1 (duplicated_holiday_november 1999) . should_equal (Date_Time.new 1999 11 4 15 50)

    Date_Part_Spec.spec name create_new_datetime

js_datetime year month=1 day=1 hour=0 minute=0 second=0 nanosecond=0 zone=Time_Zone.system =
    Panic.catch Any (js_datetime_with_zone year month day hour minute second nanosecond zone) (err -> Error.throw (Time_Error.Error err.payload))

# This ensures that date returned by javascript has the right timezone specified by the zone parameter.
# Javascript's toLocaleString will accept the timezone but it will just adapt the datetime while keeping the local timezone.
js_datetime_with_zone year month day hour minute second nanosecond zone =
    js_set_zone (js_local_datetime_impl year month day hour minute second nanosecond) zone

js_set_zone local_datetime zone =
    datetime_with_tz = local_datetime.at_zone zone
    diff = Duration.between datetime_with_tz local_datetime (timezone_aware=False)
    datetime_with_tz + diff

foreign js js_local_datetime_impl year month day hour minute second nanosecond = """
    if (month > 12 || month < 1) {
        throw `Invalid value for MonthOfYear (valid values 1 - 12): ${month}`;
    }
    return new Date(year, month - 1, day, hour, minute, second, nanosecond / 1000000);

js_parse text format=Nothing =
    d = Date_Time.parse text format
    js_datetime d.year d.month d.day d.hour d.minute d.second d.nanosecond d.zone

js_array_datetime year month=1 day=1 hour=0 minute=0 second=0 nanosecond=0 zone=Time_Zone.system =
    arr = Panic.catch Any (js_array_datetimeCreate year month day hour minute second nanosecond) (err -> Error.throw (Time_Error.Error err.payload))
    js_set_zone arr.at(0) zone

foreign js js_array_datetimeCreate year month day hour minute second nanosecond = """
    if (month > 12 || month < 1) {
        throw `Invalid value for MonthOfYear (valid values 1 - 12): ${month}`;
    }
    return [ new Date(year, month - 1, day, hour, minute, second, nanosecond / 1000000) ];

enso_datetime year month=1 day=1 hour=0 minute=0 second=0 nanosecond=0 zone=Time_Zone.system =
    Date_Time.new year month day hour minute second nanosecond=nanosecond zone=zone

java_datetime year month=1 day=1 hour=0 minute=0 second=0 nanosecond=0 zone=Time_Zone.system =
    Panic.catch Any (ZonedDateTime.of year month day hour minute second nanosecond zone) (err -> Error.throw (Time_Error.Error <| err.payload.getMessage))

maybe_parse_java_zoned text pattern=Nothing =
    if pattern == Nothing then ZonedDateTime.parse text else
        ZonedDateTime.parse text pattern

parse_java_local original_error text pattern=Nothing =
    Panic.catch Any handler=(_ -> Error.throw (Time_Error.Error original_error.getMessage)) <|
        if pattern.is_nothing then LocalDateTime.parse text else
            formatter = DateTimeFormatter.ofPattern pattern
            LocalDateTime.parse text (formatter.withLocale Locale.default.java_locale)

java_parse date_text_raw pattern=Nothing =
  utc_replaced = date_text_raw.replace "[UTC]" "Z"
  date_text = if utc_replaced.ends_with "ZZ" then date_text_raw else utc_replaced
  if pattern == Nothing then Panic.catch Any (maybe_parse_java_zoned date_text) (cause -> parse_java_local cause.payload date_text pattern) else
      formatter = DateTimeFormatter.ofPattern(pattern)
      Panic.catch Any (maybe_parse_java_zoned date_text formatter) (cause -> parse_java_local cause.payload date_text pattern)

main = Test_Suite.run_main spec
