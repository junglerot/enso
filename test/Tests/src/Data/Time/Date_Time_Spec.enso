from Standard.Base import all
import Standard.Base.Data.Time.Date_Period
import Standard.Base.Data.Time.Time_Period
import Standard.Base.Data.Time.Duration

import Standard.Test

import project.Data.Time.Date_Part_Spec

polyglot java import org.enso.base.Time_Utils
polyglot java import java.time.ZonedDateTime
polyglot java import java.time.LocalDateTime
polyglot java import java.time.ZoneOffset
polyglot java import java.time.format.DateTimeFormatter

spec =
    spec_with "Date_Time" Date_Time.new Date_Time.parse
    spec_with "JavascriptDate" js_datetime js_parse nanoseconds_loss_in_precision=True
    spec_with "JavaZonedDateTime" java_datetime java_parse
    spec_with "JavascriptDataInArray" js_array_datetime js_parse nanoseconds_loss_in_precision=True

spec_with name create_new_datetime parse_datetime nanoseconds_loss_in_precision=False =
    Test.group name <|

        Test.specify "should create time" <|
            time = create_new_datetime 1970 (zone = Time_Zone.utc)
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal Time_Zone.utc.zone_id

        Test.specify "should handle errors when creating time" <|
            case create_new_datetime 1970 0 0 . catch of
                Time_Error_Data msg ->
                    msg . should_equal "Invalid value for MonthOfYear (valid values 1 - 12): 0"
                result ->
                    Test.fail ("Unexpected result: " + result.to_text)

        Test.specify "should format using provided pattern" <|
            text = create_new_datetime 1970 (zone = Time_Zone.utc) . format "yyyy-MM-dd'T'HH:mm:ss"
            text . should_equal "1970-01-01T00:00:00"

        Test.specify "should format using default pattern" <|
            text = create_new_datetime 1970 (zone = Time_Zone.utc) . to_text
            text . should_equal "1970-01-01T00:00:00Z[UTC]"

        Test.specify "should convert to Json" <|
            time = create_new_datetime 1970 12 21 (zone = Time_Zone.utc)
            time.to_json.should_equal <|
                zone_pairs = [["zone", Time_Zone.utc]]
                time_pairs = [["year", time.year], ["month", time.month], ["day", time.day], ["hour", time.hour], ["minute", time.minute], ["second", time.second], ["nanosecond", time.nanosecond]]
                Json.from_pairs ([["type", "Date_Time"]] + time_pairs + zone_pairs)

        Test.specify "should parse default time format" <|
            text = create_new_datetime 1970 (zone = Time_Zone.utc) . to_text
            time = parse_datetime text
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal Time_Zone.utc.zone_id

        Test.specify "should parse local time adding system zone" <|
            time = parse_datetime "1970-01-01T00:00:01"
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 1
            time . nanosecond . should_equal 0
            time . zone . should_equal Time_Zone.system

        Test.specify "should parse time Z" <|
            time = parse_datetime "1970-01-01T00:00:01Z"
            time . to_epoch_seconds . should_equal 1
            time . zone . zone_id . should_equal "Z"

        Test.specify "should parse time UTC" <|
            time = parse_datetime "1970-01-01T00:00:01Z[UTC]"
            time . to_epoch_seconds . should_equal 1
            time . zone . zone_id . should_equal "UTC"

        Test.specify "should parse time with nanoseconds" <|
            time = parse_datetime "1970-01-01T00:00:01.123456789Z"
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 1
            if nanoseconds_loss_in_precision then time . nanosecond . should_equal 123000000 else
                time . nanosecond . should_equal 123456789
            time . zone . zone_id . should_equal "Z"

        Test.specify "should parse time with offset-based zone" <|
            time = parse_datetime "1970-01-01T00:00:01+01:00"
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 1
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal (Time_Zone.new 1 . zone_id)

        Test.specify "should parse time with id-based zone" <|
            time = parse_datetime "1970-01-01T00:00:01+01:00[Europe/Paris]"
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 1
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal "Europe/Paris"

        Test.specify "should throw error when parsing invalid time" <|
            case parse_datetime "2008-1-1" . catch of
                Time_Error_Data msg ->
                    msg . should_equal "Text '2008-1-1' could not be parsed at index 5"
                result ->
                    Test.fail ("Unexpected result: " + result.to_text)

        Test.specify "should parse custom format of zoned time" <|
            time = parse_datetime "2020-05-06 04:30:20 UTC" "yyyy-MM-dd HH:mm:ss z"
            time . year . should_equal 2020
            time . month . should_equal 5
            time . day . should_equal 6
            time . hour . should_equal 4
            time . minute . should_equal 30
            time . second . should_equal 20
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal "Etc/UTC"

        Test.specify "should parse custom format of local time" <|
            time = parse_datetime "06 of May 2020 at 04:30AM" "dd 'of' MMMM yyyy 'at' hh:mma"
            time . year . should_equal 2020
            time . month . should_equal 5
            time . day . should_equal 6
            time . hour . should_equal 4
            time . minute . should_equal 30
            time . second . should_equal 0
            time . nanosecond . should_equal 0

        Test.specify "should throw error when parsing custom format" <|
            time = parse_datetime "2008-01-01" "yyyy-MM-dd'T'HH:mm:ss'['z']'"
            case time.catch of
                Time_Error_Data msg ->
                    msg . should_equal "Text '2008-01-01' could not be parsed at index 10"
                result ->
                    Test.fail ("Unexpected result: " + result.to_text)

        Test.specify "should get epoch seconds" <|
            time = create_new_datetime 1970 1 1 0 0 8 (zone = Time_Zone.utc)
            time . to_epoch_seconds . should_equal 8

        Test.specify "should get epoch millis" <|
            time = create_new_datetime 1970 1 1 0 0 8 (zone = Time_Zone.utc)
            time . to_epoch_milliseconds . should_equal 8000

        Test.specify "should set offset-based timezone" <|
            tz = Time_Zone.new 1 1 1
            time = create_new_datetime 1970 (zone = Time_Zone.utc) . at_zone tz
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 1
            time . minute . should_equal 1
            time . second . should_equal 1
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal tz.zone_id

        Test.specify "should set id-based timezone" <|
            tz = Time_Zone.parse "Europe/Moscow"
            time = create_new_datetime 1970 (zone = Time_Zone.utc) . at_zone tz
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 3
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal tz.zone_id

        Test.specify "should get time of day from offsed-based time" <|
            time = parse_datetime "1970-01-01T00:00:01+01:00" . time_of_day
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 1
            time . nanosecond . should_equal 0

        Test.specify "should get time of day from id-based time" <|
            time = parse_datetime "1970-01-01T00:00:01+01:00[Europe/Paris]" . time_of_day
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 1
            time . nanosecond . should_equal 0

        Test.specify "should get date from offsed-based time" <|
            time = parse_datetime "1970-01-01T00:00:01+01:00" . date
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1

        Test.specify "should get date from id-based time" <|
            time = parse_datetime "1970-01-01T00:00:01+01:00[Europe/Paris]" . date
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1

        Test.specify "should add time interval" <|
            time = create_new_datetime 1970 (zone = Time_Zone.utc) + 1.nanosecond
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 1
            time . zone . should_equal Time_Zone.utc

        Test.specify "should add date interval" <|
            time = create_new_datetime 1970 (zone = Time_Zone.utc) + 1.month
            time . year . should_equal 1970
            time . month . should_equal 2
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal Time_Zone.utc.zone_id

        Test.specify "should add mixed date time interval" <|
            time = create_new_datetime 1970 (zone = Time_Zone.utc) + (1.month + 3.hours)
            time . year . should_equal 1970
            time . month . should_equal 2
            time . day . should_equal 1
            time . hour . should_equal 3
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal Time_Zone.utc.zone_id

        Test.specify "should subtract time interval" <|
            time = create_new_datetime 1970 (zone = Time_Zone.utc) - 1.hour
            time . year . should_equal 1969
            time . month . should_equal 12
            time . day . should_equal 31
            time . hour . should_equal 23
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal Time_Zone.utc.zone_id

        Test.specify "should subtract date interval" <|
            time = create_new_datetime 1970 (zone = Time_Zone.utc) - 1.month
            time . year . should_equal 1969
            time . month . should_equal 12
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal Time_Zone.utc.zone_id

        Test.specify "should subtract mixed date time interval" <|
            time = create_new_datetime 1970 (zone = Time_Zone.utc) - (1.month - 3.hours)
            time . year . should_equal 1969
            time . month . should_equal 12
            time . day . should_equal 1
            time . hour . should_equal 3
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal Time_Zone.utc.zone_id

        Test.specify "should support mixed interval operators" <|
            time = create_new_datetime 1970 (zone = Time_Zone.utc) - 1.month + 12.hours
            time . year . should_equal 1969
            time . month . should_equal 12
            time . day . should_equal 1
            time . hour . should_equal 12
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal Time_Zone.utc.zone_id

        Test.specify "should be comparable" <|
            time_1 = parse_datetime "2021-01-01T00:30:12.7102[UTC]"
            time_2 = parse_datetime "2021-01-01T04:00:10.0+04:00"
            (time_1 == time_2) . should_be_false
            time_1==time_1 . should_be_true
            time_1!=time_2 . should_be_true
            time_1>time_2 . should_be_true
            time_1<time_2 . should_be_false

        max_nanos = 999999999
        Test.specify "should allow to find start/end of a Date_Period containing the current datetime" <|
            d1 = create_new_datetime 2022 9 12 15 37 58
            d1.start_of Date_Period.Year . should_equal (Date_Time.new 2022 1 1)
            d1.end_of Date_Period.Year . should_equal (Date_Time.new 2022 12 31 23 59 59 max_nanos)
            d1.start_of Date_Period.Quarter . should_equal (Date_Time.new 2022 7 1)
            d1.end_of Date_Period.Quarter . should_equal (Date_Time.new 2022 9 30 23 59 59 max_nanos)
            d1.start_of Date_Period.Month . should_equal (Date_Time.new 2022 9 1)
            d1.end_of Date_Period.Month . should_equal (Date_Time.new 2022 9 30 23 59 59 max_nanos)

            d2 = create_new_datetime 2022 2 7 12 34 56 123456789
            d2.start_of Date_Period.Quarter . should_equal (Date_Time.new 2022 1 1)
            d2.end_of Date_Period.Quarter . should_equal (Date_Time.new 2022 3 31 23 59 59 max_nanos)
            d2.start_of Date_Period.Month . should_equal (Date_Time.new 2022 2 1)
            d2.end_of Date_Period.Month . should_equal (Date_Time.new 2022 2 28 23 59 59 max_nanos)

            d3 = create_new_datetime 2020 2 17
            d3.start_of Date_Period.Year . should_equal (Date_Time.new 2020 1 1)
            d3.end_of Date_Period.Year . should_equal (Date_Time.new 2020 12 31 23 59 59 max_nanos)
            d3.start_of Date_Period.Month . should_equal (Date_Time.new 2020 2 1)
            d3.end_of Date_Period.Month . should_equal (Date_Time.new 2020 2 29 23 59 59 max_nanos)

            d4 = create_new_datetime 1970 12 31 23 59 59 max_nanos
            d4.start_of Date_Period.Year . should_equal (Date_Time.new 1970 1 1)
            d4.end_of Date_Period.Year . should_equal (Date_Time.new 1970 12 31 23 59 59 max_nanos)
            d4.start_of Date_Period.Quarter . should_equal (Date_Time.new 1970 10 1)
            d4.end_of Date_Period.Quarter . should_equal (Date_Time.new 1970 12 31 23 59 59 max_nanos)
            d4.start_of Date_Period.Month . should_equal (Date_Time.new 1970 12 1)
            d4.end_of Date_Period.Month . should_equal (Date_Time.new 1970 12 31 23 59 59 max_nanos)

            d5 = create_new_datetime 2040 1 1
            d5.start_of Date_Period.Year . should_equal (Date_Time.new 2040 1 1)
            d5.end_of Date_Period.Year . should_equal (Date_Time.new 2040 12 31 23 59 59 max_nanos)
            d5.start_of Date_Period.Quarter . should_equal (Date_Time.new 2040 1 1)
            d5.end_of Date_Period.Quarter . should_equal (Date_Time.new 2040 3 31 23 59 59 max_nanos)
            d5.start_of Date_Period.Month . should_equal (Date_Time.new 2040 1 1)
            d5.end_of Date_Period.Month . should_equal (Date_Time.new 2040 1 31 23 59 59 max_nanos)

            (create_new_datetime 2000 7 1 14 54).start_of Date_Period.Quarter . should_equal (Date_Time.new 2000 7 1)
            (create_new_datetime 2000 6 30 15 34).start_of Date_Period.Quarter . should_equal (Date_Time.new 2000 4 1)

            (create_new_datetime 2000 7 1 16 50).end_of Date_Period.Quarter . should_equal (Date_Time.new 2000 9 30 23 59 59 max_nanos)
            (create_new_datetime 2000 6 30 17 40).end_of Date_Period.Quarter . should_equal (Date_Time.new 2000 6 30 23 59 59 max_nanos)

        Test.specify "should allow to find start/end of a Time_Period containing the current datetime" <|
            d1 = create_new_datetime 2022 9 12 15 37 58 123456789
            d1.start_of Time_Period.Day . should_equal (Date_Time.new 2022 9 12)
            d1.end_of Time_Period.Day . should_equal (Date_Time.new 2022 9 12 23 59 59 max_nanos)
            d1.start_of Time_Period.Hour . should_equal (Date_Time.new 2022 9 12 15 0 0 0)
            d1.end_of Time_Period.Hour . should_equal (Date_Time.new 2022 9 12 15 59 59 max_nanos)
            d1.start_of Time_Period.Minute . should_equal (Date_Time.new 2022 9 12 15 37 0 0)
            d1.end_of Time_Period.Minute . should_equal (Date_Time.new 2022 9 12 15 37 59 max_nanos)
            d1.start_of Time_Period.Second . should_equal (Date_Time.new 2022 9 12 15 37 58 0)
            d1.end_of Time_Period.Second . should_equal (Date_Time.new 2022 9 12 15 37 58 max_nanos)

            d2 = create_new_datetime 1970 1 1 0 0 0
            d2.start_of Time_Period.Day . should_equal (Date_Time.new 1970)
            d2.end_of Time_Period.Day . should_equal (Date_Time.new 1970 1 1 23 59 59 max_nanos)
            d2.start_of Time_Period.Hour . should_equal (Date_Time.new 1970 1 1 0 0 0 0)
            d2.end_of Time_Period.Hour . should_equal (Date_Time.new 1970 1 1 0 59 59 max_nanos)
            d2.start_of Time_Period.Minute . should_equal (Date_Time.new 1970 1 1 0 0 0 0)
            d2.end_of Time_Period.Minute . should_equal (Date_Time.new 1970 1 1 0 0 59 max_nanos)
            d2.start_of Time_Period.Second . should_equal (Date_Time.new 1970 1 1 0 0 0 0)
            d2.end_of Time_Period.Second . should_equal (Date_Time.new 1970 1 1 0 0 0 max_nanos)

            d3 = create_new_datetime 2100 12 31 23 59 59 max_nanos
            d3.start_of Time_Period.Day . should_equal (Date_Time.new 2100 12 31)
            d3.end_of Time_Period.Day . should_equal (Date_Time.new 2100 12 31 23 59 59 max_nanos)
            d3.start_of Time_Period.Hour . should_equal (Date_Time.new 2100 12 31 23 0 0 0)
            d3.end_of Time_Period.Hour . should_equal (Date_Time.new 2100 12 31 23 59 59 max_nanos)
            d3.start_of Time_Period.Minute . should_equal (Date_Time.new 2100 12 31 23 59 0 0)
            d3.end_of Time_Period.Minute . should_equal (Date_Time.new 2100 12 31 23 59 59 max_nanos)
            d3.start_of Time_Period.Second . should_equal (Date_Time.new 2100 12 31 23 59 59 0)
            d3.end_of Time_Period.Second . should_equal (Date_Time.new 2100 12 31 23 59 59 max_nanos)

        offset_1_h = ZoneOffset.ofTotalSeconds 3600
        offset_2_h = ZoneOffset.ofTotalSeconds 2*3600
        tz = Time_Zone.parse "Europe/Warsaw"
        js_dst_pending = if name.contains "Javascript" then
            "Javascript implementation does not support time zones correctly, so the tests for conversion around DST switches would fail and thus are disabled. We may revisit once JS gets better time support, see project Temporal: https://tc39.es/proposal-temporal/docs/ and our Pivotal issue tracking our integration: https://www.pivotaltracker.com/story/show/183261296"
        Test.specify "should find start/end of a Date_Period or Time_Period containing the current datetime correctly near the spring DST switch" pending=js_dst_pending <|
            d1 = create_new_datetime 2022 3 27 1 34 15 0 tz
            d2 = create_new_datetime 2022 3 27 3 34 15 0 tz
            d1_plus = d1 + 1.hour
            d1_plus . should_equal d2

            check_dates_spring date =
                date.start_of Time_Period.Day . should_equal (Date_Time.new 2022 3 27 0 0 0 0 tz)
                date.end_of Time_Period.Day . should_equal (Date_Time.new 2022 3 27 23 59 59 max_nanos tz)

                date.start_of Date_Period.Month . should_equal (Date_Time.new 2022 3 1 0 0 0 0 tz)
                date.end_of Date_Period.Month . should_equal (Date_Time.new 2022 3 31 23 59 59 max_nanos tz)

            check_dates_spring d1
            check_dates_spring d2

            d1_start = d1.start_of Time_Period.Hour
            d1_end = d1.end_of Time_Period.Hour
            (d1.to_epoch_seconds - d1_start.to_epoch_seconds) . should_equal (34*60 + 15)
            (d1_end.to_epoch_seconds - d1.to_epoch_seconds) . should_equal (60*60 - (34*60 + 15) - 1)
            d1_start . should_equal (Date_Time.new 2022 3 27 1 0 0 0 tz)
            d1_end . should_equal (Date_Time.new 2022 3 27 1 59 59 max_nanos tz)
            d1.start_of Time_Period.Minute . should_equal (Date_Time.new 2022 3 27 1 34 0 0 tz)
            d1.end_of Time_Period.Minute . should_equal (Date_Time.new 2022 3 27 1 34 59 max_nanos tz)

            d2_start = d2.start_of Time_Period.Hour
            d2_end = d2.end_of Time_Period.Hour
            (d2.to_epoch_seconds - d2_start.to_epoch_seconds) . should_equal (34*60 + 15)
            (d2_end.to_epoch_seconds - d2.to_epoch_seconds) . should_equal (60*60 - (34*60 + 15) - 1)
            d2_start . should_equal (Date_Time.new 2022 3 27 3 0 0 0 tz)
            d2_end . should_equal (Date_Time.new 2022 3 27 3 59 59 max_nanos tz)

        dst_overlap_message = "We cannot correctly migrate the datetime inside of the timeline overlap through the polyglot boundar - as due to polyglot conversion limitation, always the earlier one is chosen. See the bug report: https://github.com/oracle/graal/issues/4918"
        Test.specify "should find start/end of a Date_Period or Time_Period containing the current datetime correctly near the autumn DST switch" pending=dst_overlap_message <|
            d3 = create_new_datetime 2022 10 30 2 30 15 0 tz
            d4 = d3 + (1.hour)

            d3.hour . should_equal 2
            d4.hour . should_equal 2
            d3.minute . should_equal 30
            d4.minute . should_equal 30
            (d4.to_epoch_milliseconds - d3.to_epoch_milliseconds) . should_equal 60*60*1000
            Time_Utils.get_datetime_offset d3 . should_equal offset_2_h
            Time_Utils.get_datetime_offset d4 . should_equal offset_1_h

            check_dates_autumn date =
                date.start_of Time_Period.Day . should_equal (Date_Time.new 2022 10 30 0 0 0 0 tz)
                date.end_of Time_Period.Day . should_equal (Date_Time.new 2022 10 30 23 59 59 max_nanos tz)

                date.start_of Date_Period.Month . should_equal (Date_Time.new 2022 10 1 0 0 0 0 tz)
                date.end_of Date_Period.Month . should_equal (Date_Time.new 2022 10 31 23 59 59 max_nanos tz)

            check_dates_autumn d3
            check_dates_autumn d4

            d3_start = d3.start_of Time_Period.Hour
            d3_end = d3.end_of Time_Period.Hour
            (d3.to_epoch_seconds - d3_start.to_epoch_seconds) . should_equal (30*60 + 15)
            (d3_end.to_epoch_seconds - d3.to_epoch_seconds) . should_equal (60*60 - (30*60 + 15) - 1)
            d3_start . should_equal (Date_Time.new 2022 10 30 2 0 0 0 tz)
            Time_Utils.get_datetime_offset d3_start . should_equal offset_2_h
            d3_end . should_equal (Date_Time.new 2022 10 30 2 59 59 max_nanos tz)
            Time_Utils.get_datetime_offset d3_end . should_equal offset_2_h

            d4_start = d4.start_of Time_Period.Hour
            d4_end = d4.end_of Time_Period.Hour
            (d4.to_epoch_seconds - d4_start.to_epoch_seconds) . should_equal (30*60 + 15)
            (d4_end.to_epoch_seconds - d4.to_epoch_seconds) . should_equal (60*60 - (30*60 + 15) - 1)
            d4_start.hour . should_equal 2
            d4_start.minute . should_equal 0
            Time_Utils.get_datetime_offset d4_start . should_equal offset_1_h
            d4_end.hour . should_equal 2
            d4_end.minute . should_equal 59
            d4_end.second . should_equal 59
            d4_end.nanosecond . should_equal max_nanos
            Time_Utils.get_datetime_offset d4_end . should_equal offset_1_h

    Date_Part_Spec.spec name create_new_datetime

js_datetime year month=1 day=1 hour=0 minute=0 second=0 nanosecond=0 zone=Time_Zone.system =
    Panic.catch Any (js_datetime_with_zone year month day hour minute second nanosecond zone) (err -> Error.throw (Time_Error_Data err.payload.cause))

# This ensures that date returned by javascript has the right timezone specified by the zone parameter.
# Javascript's toLocaleString will accept the timezone but it will just adapt the datetime while keeping the local timezone.
js_datetime_with_zone year month day hour minute second nanosecond zone =
    js_set_zone (js_local_datetime_impl year month day hour minute second nanosecond) zone

js_set_zone local_datetime zone =
    datetime_with_tz = local_datetime.at_zone zone
    diff = Duration.between datetime_with_tz local_datetime (timezone_aware=False)
    datetime_with_tz + diff

foreign js js_local_datetime_impl year month day hour minute second nanosecond = """
    if (month > 12 || month < 1) {
        throw `Invalid value for MonthOfYear (valid values 1 - 12): ${month}`;
    }
    return new Date(year, month - 1, day, hour, minute, second, nanosecond / 1000000);

js_parse text format=Nothing =
    d = Date_Time.parse text format
    js_datetime d.year d.month d.day d.hour d.minute d.second d.nanosecond d.zone

js_array_datetime year month=1 day=1 hour=0 minute=0 second=0 nanosecond=0 zone=Time_Zone.system =
    arr = Panic.catch Any (js_array_datetimeCreate year month day hour minute second nanosecond) (err -> Error.throw (Time_Error_Data err.payload.cause))
    js_set_zone arr.at(0) zone

foreign js js_array_datetimeCreate year month day hour minute second nanosecond = """
    if (month > 12 || month < 1) {
        throw `Invalid value for MonthOfYear (valid values 1 - 12): ${month}`;
    }
    return [ new Date(year, month - 1, day, hour, minute, second, nanosecond / 1000000) ];

java_datetime year month=1 day=1 hour=0 minute=0 second=0 nanosecond=0 zone=Time_Zone.system =
    Panic.catch Any (ZonedDateTime.of year month day hour minute second nanosecond zone) (err -> Error.throw (Time_Error_Data <| err.payload.to_display_text.drop (Text_Sub_Range.First 16)))

maybe_parse_java_zoned text pattern=Nothing =
    if pattern == Nothing then ZonedDateTime.parse text else
        ZonedDateTime.parse text pattern

parse_java_local original_error text pattern=Nothing =
    Panic.catch Polyglot_Error_Data handler=(_ -> Error.throw (Time_Error_Data original_error.payload.cause.getMessage)) <|
        if pattern.is_nothing then LocalDateTime.parse text else
            formatter = DateTimeFormatter.ofPattern pattern
            LocalDateTime.parse text (formatter.withLocale Locale.default.java_locale)

java_parse date_text_raw pattern=Nothing =
  utc_replaced = date_text_raw.replace "[UTC]" "Z"
  date_text = if utc_replaced.ends_with "ZZ" then date_text_raw else utc_replaced
  if pattern == Nothing then Panic.catch Polyglot_Error_Data (maybe_parse_java_zoned date_text) (err -> parse_java_local err date_text pattern) else
      formatter = DateTimeFormatter.ofPattern(pattern)
      Panic.catch Polyglot_Error_Data (maybe_parse_java_zoned date_text formatter) (err -> parse_java_local err date_text pattern)

main = Test.Suite.run_main spec
