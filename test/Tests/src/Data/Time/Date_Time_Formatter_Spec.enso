from Standard.Base import all
import Standard.Base.Data.Time.Date_Time_Formatter.Date_Time_Format_Parse_Error
import Standard.Base.Errors.Time_Error.Time_Error

from Standard.Test import Test, Test_Suite
import Standard.Test.Extensions

polyglot java import java.time.format.DateTimeFormatter

spec =
    Test.group "Parsing formats" <|
        Test.specify "should throw informative error for replacements of Java patterns in Simple format" <|
            r1 = Date_Time_Formatter.from "d LLL yyyy"
            r1.should_fail_with Date_Time_Format_Parse_Error
            r1.catch.to_display_text . should_contain "use `MMM`"

            r2 = Date_Time_Formatter.from "dd-MM-yyyy HH:mm:ss '['XX']'"
            r2.should_fail_with Date_Time_Format_Parse_Error
            r2.catch.to_display_text . should_contain "use `zz`"

            r3 = Date_Time_Formatter.from "yyyy-ww-dd"
            r3.should_fail_with Date_Time_Format_Parse_Error
            r3.catch.to_display_text . should_contain "consider using `from_iso_week_date_pattern`"

            r4 = Date_Time_Formatter.from "yyyy-MMMMMMM-dd"
            r4.should_fail_with Date_Time_Format_Parse_Error
            r4.catch.to_display_text . should_contain "at most 4"

        Test.specify "should report format parse failures" <|
            Date_Time_Formatter.from "yyyy[" . should_fail_with Date_Time_Format_Parse_Error
            Date_Time_Formatter.from "yyyy{12}" . should_fail_with Date_Time_Format_Parse_Error
            Date_Time_Formatter.from "yy{baz}" . should_fail_with Date_Time_Format_Parse_Error
            Date_Time_Formatter.from "MM{baz}" . should_fail_with Date_Time_Format_Parse_Error
            Date_Time_Formatter.from "{baz}" . should_fail_with Date_Time_Format_Parse_Error
            Date_Time_Formatter.from "]" . should_fail_with Date_Time_Format_Parse_Error
            Date_Time_Formatter.from "'" . should_fail_with Date_Time_Format_Parse_Error

    Test.group "Formatting date/time values" <|
        Test.specify "should allow printing month names" <|
            d = Date.new 2020 6 30
            d.format "d. MMM yyyy" . should_equal "30. Jun 2020"
            d.format (Date_Time_Formatter.from "d. MMMM yyyy" Locale.us) . should_equal "30. June 2020"
            # Note that the default (ROOT) locale returns a short name even for MMMM (full name) month format.
            d.format (Date_Time_Formatter.from "d. MMMM yyyy" Locale.default) . should_equal "30. Jun 2020"

        Test.specify "should allow using a Java formatter" <|
            jformatter = Date_Time_Formatter.from_java DateTimeFormatter.ISO_ORDINAL_DATE
            Date.new 2020 2 1 . format jformatter . should_equal "2020-032"

        Test.specify "should allow parsing Java patterns" <|
            Date.new 2020 2 1 . format (Date_Time_Formatter.from_java "E, d LLL yyyy") . should_equal "Sat, 1 Feb 2020"

        Test.specify "should handle various formats" <|
            Date.new 2023 09 21 . format "E, dd.MM.yy" . should_equal "Thu, 21.09.23"
            Date.new 2023 09 21 . format (Date_Time_Formatter.from "DDDD" Locale.poland) . should_equal "czwartek"
            Date.new 2023 09 21 . format (Date_Time_Formatter.from_iso_week_date_pattern "eee, 'W'WW ''yy" Locale.uk) . should_equal "Thursday, W38 '23"
            Date.new 2023 09 21 . format "'Q'Q ''yy{1999}" . should_equal "Q3 '23"

            tz = Time_Zone.parse "US/Hawaii"
            Date_Time.new 2023 09 21 12 zone=tz . format "yyyy/MM/dd HH:mm:ss VV" . should_equal "2023/09/21 12:00:00 US/Hawaii"

        Test.specify "should allow to customize the 'zero' of a zone offset" <|
            dt = Date_Time.new 2020 01 02 12 zone=(Time_Zone.utc)
            dt.format "yyyy/MM/dd HH:mm:ss ZZ" . should_equal "2020/01/02 12:00:00 +0000"
            dt.format "yyyy/MM/dd HH:mm:ss ZZ{Z}" . should_equal "2020/01/02 12:00:00 Z"
            dt.format "yyyy/MM/dd HH:mm:ss ZZ{<no offset>}" . should_equal "2020/01/02 12:00:00 <no offset>"

            dt2 = Date_Time.new 2020 01 02 12 zone=(Time_Zone.parse "US/Hawaii")
            dt2.format "yyyy/MM/dd HH:mm:ss ZZ" . should_equal "2020/01/02 12:00:00 -1000"
            dt2.format "yyyy/MM/dd HH:mm:ss ZZ{Z}" . should_equal "2020/01/02 12:00:00 -1000"
            dt2.format "yyyy/MM/dd HH:mm:ss ZZZZZ{<no offset>}" . should_equal "2020/01/02 12:00:00 -10:00"

    Test.group "Parsing date/time values" <|
        Test.specify "should allow short month names" <|
            Date.parse "30. Jun 2020" "d. MMM yyyy" . should_equal (Date.new 2020 6 30)

        Test.specify "should allow long month names" <|
            Date.parse "30. June 2020" (Date_Time_Formatter.from "d. MMMM yyyy" Locale.uk) . should_equal (Date.new 2020 6 30)

        Test.specify "should parse default time format" <|
            text = Date_Time.new 1970 (zone = Time_Zone.utc) . to_text
            time = Date_Time.parse text
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 0
            time . nanosecond . should_equal 0
            time . zone . zone_id . should_equal Time_Zone.utc.zone_id

        Test.specify "should parse local time adding system zone" <|
            time = Date_Time.parse "1970-01-01T00:00:01"
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 1
            time . nanosecond . should_equal 0
            (time.zone.offset time) . should_equal (Time_Zone.system.offset time)

        Test.specify "should parse time Z" <|
            time = Date_Time.parse "1582-10-15T00:00:01Z"
            time . to_enso_epoch_seconds . should_equal 1
            time.zone.zone_id . should_equal "Z"

        Test.specify "should parse time UTC" <|
            time = Date_Time.parse "1582-10-15T00:00:01Z[UTC]"
            time . to_enso_epoch_seconds . should_equal 1
            time . zone . zone_id . should_equal "UTC"

        Test.specify "should parse time with nanoseconds" <|
            time = Date_Time.parse "1970-01-01T00:00:01.123456789Z"
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 1
            time . nanosecond include_milliseconds=True . should_equal 123456789
            time . millisecond . should_equal 123
            time . microsecond . should_equal 456
            time . nanosecond . should_equal 789
            time.zone.zone_id . should_equal "Z"

        Test.specify "should parse time with offset-based zone" <|
            time = Date_Time.parse "1970-01-01T00:00:01+01:00"
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 1
            time . millisecond . should_equal 0
            time . microsecond . should_equal 0
            time . nanosecond . should_equal 0
            time.zone.zone_id . take (Last 6) . should_equal "+01:00"

        Test.specify "should parse time with id-based zone" <|
            time = Date_Time.parse "1970-01-01T00:00:01+01:00[Europe/Paris]"
            time . year . should_equal 1970
            time . month . should_equal 1
            time . day . should_equal 1
            time . hour . should_equal 0
            time . minute . should_equal 0
            time . second . should_equal 1
            time . millisecond . should_equal 0
            time . microsecond . should_equal 0
            time . nanosecond . should_equal 0
            zone = time.zone
            zone.offset time . should_equal 3600
            zone.zone_id . should_equal "Europe/Paris"
            time.to_display_text . should_equal "1970-01-01 00:00:01 Europe/Paris"

        Test.specify "should throw error when parsing invalid time" <|
            case Date_Time.parse "2008-1-1" . catch of
                Time_Error.Error msg _ ->
                    msg . should_contain "Text '2008-1-1' could not be parsed"
                result ->
                    Test.fail ("Unexpected result: " + result.to_text)

        Test.specify "should parse custom format of zoned time" <|
            time = Date_Time.parse "2020-05-06 04:30:20 UTC" "yyyy-MM-dd HH:mm:ss VV"
            time . year . should_equal 2020
            time . month . should_equal 5
            time . day . should_equal 6
            time . hour . should_equal 4
            time . minute . should_equal 30
            time . second . should_equal 20
            time . millisecond . should_equal 0
            time . microsecond . should_equal 0
            time . nanosecond . should_equal 0
            (time.zone.zone_id . take (Last 3) . to_case Case.Upper) . should_equal "UTC"

        Test.specify "should parse custom format of local time" <|
            time = Date_Time.parse "06 of May 2020 at 04:30AM" "dd 'of' MMMM yyyy 'at' hh:mma"
            time . year . should_equal 2020
            time . month . should_equal 5
            time . day . should_equal 6
            time . hour . should_equal 4
            time . minute . should_equal 30
            time . second . should_equal 0
            time . millisecond . should_equal 0
            time . microsecond . should_equal 0
            time . nanosecond . should_equal 0

        Test.specify "should throw error when parsing custom format" <|
            time = Date_Time.parse "2008-01-01" "yyyy-MM-dd'T'HH:mm:ss'['tt']'"
            case time.catch of
                Time_Error.Error msg _ ->
                    msg . should_contain "Text '2008-01-01' could not be parsed"
                result ->
                    Test.fail ("Unexpected result: " + result.to_text)

        Test.specify "should be able to parse YYYY as well as yyyy" <|
            Date.parse "2020-01-02" "YYYY-MM-dd" . should_equal (Date.new 2020 1 2)
            Date.parse "2020-01-02" "yyyy-MM-dd" . should_equal (Date.new 2020 1 2)

        Test.specify "should be able to parse year-month without day" <|
            Date.parse "2022-05" "yyyy-MM" . should_equal (Date.new 2022 5 1)

        Test.specify "should be able to parse a quarter without day" <|
            Date.parse "Q2 of 2022" "'Q'Q 'of' yyyy" . should_equal (Date.new 2022 4 1)

        Test.specify "should be able to parse a day and month without year - defaulting to current year" <|
            current_year = Date.today.year
            Date.parse "07/23" "MM/dd" . should_equal (Date.new current_year 7 23)
            Date.parse "14. of May" "d. 'of' MMMM" . should_equal (Date.new current_year 5 14)

        Test.specify "should be able to parse 2-digit year" <|
            Date.parse "22-05-06" "yy-MM-dd" . should_equal (Date.new 2022 5 6)
            Date.parse "99-01-02" "yy-MM-dd" . should_equal (Date.new 1999 1 2)
            Date.parse "49-03-04" "yy-MM-dd" . should_equal (Date.new 2049 3 4)
            Date.parse "50-03-04" "yy-MM-dd" . should_equal (Date.new 1950 3 4)

        Test.specify "should be able to parse 2-digit year with custom base-year" <|
            Date.parse "22-05-06" "yy{1999}-MM-dd" . should_equal (Date.new 1922 5 6)
            Date.parse "99-01-02" "yy{1949}-MM-dd" . should_equal (Date.new 1899 1 2)
            Date.parse "49-03-04" "yy{3099}-MM-dd" . should_equal (Date.new 3049 3 4)
            Date.parse "50-03-04" "yy{2099}-MM-dd" . should_equal (Date.new 2050 3 4)

        Test.specify "should work like in examples" <|
             Date.parse "Tue, 12 Oct 2021" "ddd, d MMM yyyy" . should_equal (Date.new 2021 10 12)
             Date.parse "Thursday, 1 October '98" (Date_Time_Formatter.from "dddd, d MMMM ''yy" Locale.uk) . should_equal (Date.new 1998 10 01)
             Date_Time.parse "12/10/2021 5:34 PM" "d/M/Y h:mm a" . should_equal (Date_Time.new 2021 10 12 17 34 00)
             Date.parse "2021-10" "yyyy-MM" . should_equal (Date.new 2021 10 01)
             Date.parse "10-12" "MM-dd" . should_equal (Date.new (Date.today.year) 10 12)
             Date.parse "1 Nov '95" "d MMM ''yy{2099}" . should_equal (Date.new 2095 11 01)
             Date_Time.parse "2021-10-12T12:34:56.789+0200" "yyyy-MM-dd'T'HH:mm:ss.fZ" . should_equal (Date_Time.new 2021 10 12 12 34 56 millisecond=789 zone=(Time_Zone.new hours=2))

        Test.specify "should be able to parse a week-based year format" <|
             Date.parse "1976-W53-6" (Date_Time_Formatter.from_iso_week_date_pattern "YYYY-'W'WW-d") . should_equal (Date.new 1977 01 01)
             Date_Time.parse "1978-W01-4 12:34:56" (Date_Time_Formatter.from_iso_week_date_pattern "YYYY-'W'WW-d HH:mm:ss") . should_equal (Date_Time.new 1978 01 05 12 34 56)

             Date.parse "1978-W01, Mon" (Date_Time_Formatter.from_iso_week_date_pattern "YYYY-'W'WW, eee") . should_equal (Date.new 1978 01 02)
             # Just week will parse to first day of the week:
             Date.parse "1978-W01" (Date_Time_Formatter.from_iso_week_date_pattern "YYYY-'W'WW") . should_equal (Date.new 1978 01 02)

main = Test_Suite.run_main spec
