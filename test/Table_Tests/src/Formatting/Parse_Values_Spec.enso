from Standard.Base import all
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument

from Standard.Table import Table, Data_Formatter, Column, Column_Selector
from Standard.Table.Data.Type.Value_Type import Value_Type, Auto
from Standard.Table.Errors import all

from Standard.Test import Test, Test_Suite, Problems
import Standard.Test.Extensions

import project.Util

spec =
    Test.group "Table.parse" <|
        Test.specify "should correctly parse integers" <|
            t1 = Table.new [["ints", ["0", "+0", "-0", "+1", "-1", "1", "000", "0010", "12345", Nothing]]]
            t2 = t1.parse type=Value_Type.Integer
            t2.at "ints" . to_vector . should_equal [0, 0, 0, 1, -1, 1, Nothing, Nothing, 12345, Nothing]

        Test.specify "should correctly parse decimals" <|
            t1 = Table.new [["ints", ["0", "+0", "-0", "+1", "-1", "1", "12345", Nothing]]]
            t2 = t1.parse type=Value_Type.Float
            t2.at "ints" . to_vector . should_equal [0, 0, 0, 1, -1, 1, 12345, Nothing]
            t2.at "ints" . to_vector . map .to_text . should_equal ["0.0", "0.0", "-0.0", "1.0", "-1.0", "1.0", "12345.0", "Nothing"]

            t3 = Table.new [["floats", ["0.0", "+0.0", "-0.0", "+1.0", "-1.0", "1.0", "0.0000", "10.", "12345."]]]
            t4 = t3.parse type=Value_Type.Float
            t4.at "floats" . to_vector . should_equal [0, 0, 0, 1, -1, 1, 0, 10, 12345]

            t5 = Table.new [["floats", [".0", "0.", "1.", ".1", ".123", "-.1", "+.1", "+0.0", "0.1234", Nothing, "11111111.111"]]]
            t6 = t5.parse type=Value_Type.Float
            t6.at "floats" . to_vector . should_equal [0.0, 0.0, 1.0, 0.1, 0.123, -0.1, 0.1, 0.0, 0.1234, Nothing, 11111111.111]

        Test.specify "should warn on leading zeros in numbers, if asked" <|
            t1 = Table.new [["ints", ["0", "+00", "-00", "+01", "-01", "01", "000", "0010", "12345", Nothing]]]
            t2 = Table.new [["floats", ["0.0000", ".0", "00.", "01.0", "-0010.0000", "1.0000"]]]

            t1_parsed = [0, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, 12345, Nothing]
            t1_zeros = ["+00", "-00", "+01", "-01", "01", "000", "0010"]
            t3 = t1.parse type=Value_Type.Integer
            t3.at "ints" . to_vector . should_equal t1_parsed
            Problems.get_attached_warnings t3 . should_equal [Leading_Zeros.Error "ints" Value_Type.Integer t1_zeros]

            t4 = t1.parse type=Value_Type.Float
            t4.at "ints" . to_vector . should_equal t1_parsed
            Problems.get_attached_warnings t4 . should_equal [Leading_Zeros.Error "ints" Value_Type.Float t1_zeros]

            t5 = t2.parse type=Value_Type.Float
            t5.at "floats" . to_vector . should_equal [0.0, 0.0, Nothing, Nothing, Nothing, 1.0]
            Problems.get_attached_warnings t5 . should_equal [Leading_Zeros.Error "floats" Value_Type.Float ["00.", "01.0", '-0010.0000']]

            opts = Data_Formatter.Value allow_leading_zeros=True
            t1_parsed_zeros = [0, 0, 0, 1, -1, 1, 0, 10, 12345, Nothing]
            t6 = t1.parse format=opts type=Value_Type.Integer
            t6.at "ints" . to_vector . should_equal t1_parsed_zeros
            Problems.assume_no_problems t6

            t7 = t1.parse format=opts type=Value_Type.Float
            t7.at "ints" . to_vector . should_equal t1_parsed_zeros
            Problems.assume_no_problems t7

            t8 = t2.parse format=opts type=Value_Type.Float
            t8.at "floats" . to_vector . should_equal [0.0, 0.0, 0.0, 1.0, -10.0, 1.0]
            Problems.assume_no_problems t8

        Test.specify "should correctly parse booleans" <|
            t1 = Table.new [["bools", ["true", "false", "True", "TRUE", "FALSE", Nothing, "False"]]]
            t2 = t1.parse type=Value_Type.Boolean
            t2.at "bools" . to_vector . should_equal [True, False, True, True, False, Nothing, False]

            t3 = Table.new [["bools", ["1", "0", "true", "yes", "oui", "no", "NO!"]]]
            t4 = t3.parse type=Value_Type.Boolean format="yes|no"
            t4.at "bools" . to_vector . should_equal [Nothing, Nothing, Nothing, True, Nothing, False, Nothing]

        Test.specify "should correctly parse date and time" <|
            t1 = Table.new [["dates", ["2022-05-07", "2000-01-01", "2010-12-31"]]]
            t2 = t1.parse type=Value_Type.Date
            t2.at "dates" . to_vector . should_equal [Date.new 2022 5 7, Date.new 2000 1 1, Date.new 2010 12 31]

            t3 = Table.new [["datetimes", ["2022-05-07 23:59:59", "2000-01-01 00:00:00", "2010-12-31 12:34:56"]]]
            t4 = t3.parse type=Value_Type.Date_Time
            t4.at "datetimes" . to_vector . should_equal [Date_Time.new 2022 5 7 23 59 59, Date_Time.new 2000 1 1, Date_Time.new 2010 12 31 12 34 56]

            t5 = Table.new [["times", ["23:59:59", "00:00:00", "12:34:56"]]]
            t6 = t5.parse type=Value_Type.Time
            t6.at "times" . to_vector . should_equal [Time_Of_Day.new 23 59 59, Time_Of_Day.new, Time_Of_Day.new 12 34 56]

            t7 = Table.new [["dates", ["07/05/2022", "01/01/2001", "31/12/2010"]]]
            t8 = t7.parse type=Value_Type.Date format="dd/MM/yyyy"
            t8.at "dates" . value_type . should_equal Value_Type.Date
            t8.at "dates" . to_vector . should_equal [Date.new 2022 5 7, Date.new 2001 1 1, Date.new 2010 12 31]

        Test.specify "should parse date and time in various formats" <|
            opts = Data_Formatter.Value date_formats=["d.M.y", "d MMM y[ G]", "E, d MMM y"] datetime_formats=["yyyy-MM-dd'T'HH:mm:ss", "dd/MM/yyyy HH:mm"] time_formats=["H:mm:ss.n", "h:mma"]

            t1 = Table.new [["dates", ["1.2.476", "10 Jan 1900 AD", "Tue, 3 Jun 2008"]]]
            t2 = t1.parse format=opts type=Value_Type.Date
            t2.at "dates" . to_vector . should_equal [Date.new 476 2 1, Date.new 1900 1 10, Date.new 2008 6 3]

            t3 = Table.new [["datetimes", ["2011-12-03T10:15:30", "31/12/2012 22:33"]]]
            t4 = t3.parse format=opts type=Value_Type.Date_Time
            t4.at "datetimes" . to_vector . should_equal [Date_Time.new 2011 12 3 10 15 30, Date_Time.new 2012 12 31 22 33]

            t5 = Table.new [["times", ["1:02:03.987654321", "1:30PM"]]]
            t6 = t5.parse format=opts type=Value_Type.Time
            t6.at "times" . to_vector . should_equal [Time_Of_Day.new 1 2 3 nanosecond=987654321, Time_Of_Day.new 13 30 0 0]

        Test.specify "should warn when cells do not fit the expected format" <|
            ints = ["ints", ["0", "1", "1.0", "foobar", "", "--1", "+-1", "10", "-+1"]]
            # Currently scientific notation is not supported and we document that in this test, in the future the situation may change and the test may need to be flipped.
            floats = ["floats", ["0", "2.0", "1e6", "foobar", "", "--1", "+-1", "100.", "-+1"]]
            bools = ["bools", ["True", "false", "fAlSE", "foobar", "", "0", "1", "true", "truefalse"]]
            times = ["2001-01-01", "2001-01-01 12:34:56", "10:00:10", "Tuesday", "foobar", "", "10:99:99", "1/2/2003", "2001-30-10"]
            t = Table.new [ints, floats, bools, ["times", times]]

            t0 = t.parse type=Value_Type.Boolean
            t0.at "bools" . to_vector . should_equal [True, False, Nothing, Nothing, Nothing, Nothing, Nothing, True, Nothing]
            t0.at "ints" . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing]
            Problems.expect_warning (Invalid_Format.Error "bools" Value_Type.Boolean ["fAlSE", "foobar", "", "0", "1", "truefalse"]) t0
            Problems.expect_warning (Invalid_Format.Error "ints" Value_Type.Boolean ["0", "1", "1.0", "foobar", "", "--1", "+-1", "10", "-+1"]) t0

            a1 = t.parse columns=["ints"] type=Value_Type.Integer on_problems=_
            t1 t =
                t.at "ints" . to_vector . should_equal [0, 1, Nothing, Nothing, Nothing, Nothing, Nothing, 10, Nothing]
            p1 = [Invalid_Format.Error "ints" Value_Type.Integer ["1.0", "foobar", "", "--1", "+-1", "-+1"]]
            Problems.test_problem_handling a1 p1 t1

            a2 = t.parse columns=["floats"] type=Value_Type.Float on_problems=_
            t2 t =
                t.at "floats" . to_vector . should_equal [0, 2, Nothing, Nothing, Nothing, Nothing, Nothing, 100, Nothing]
            p2 = [Invalid_Format.Error "floats" Value_Type.Float ["1e6", "foobar", "", "--1", "+-1", "-+1"]]
            Problems.test_problem_handling a2 p2 t2

            a3 = t.parse columns=["bools"] type=Value_Type.Boolean on_problems=_
            t3 t =
                t.at "bools" . to_vector . should_equal [True, False, Nothing, Nothing, Nothing, Nothing, Nothing, True, Nothing]
            p3 = [Invalid_Format.Error "bools" Value_Type.Boolean ["fAlSE", "foobar", "", "0", "1", "truefalse"]]
            Problems.test_problem_handling a3 p3 t3

            a4 = t.parse columns=["times"] type=Value_Type.Date on_problems=_
            t4 t =
                t.at "times" . to_vector . should_equal [Date.new 2001 1 1, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing]
            p4 = [Invalid_Format.Error "times" Value_Type.Date ["2001-01-01 12:34:56", "10:00:10", "Tuesday", "foobar", "", "10:99:99", "1/2/2003", "2001-30-10"]]
            Problems.test_problem_handling a4 p4 t4

            a5 = t.parse columns=["times"] type=Value_Type.Date_Time on_problems=_
            t5 t =
                t.at "times" . to_vector . should_equal [Nothing, Date_Time.new 2001 1 1 12 34 56, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing]
            p5 = [Invalid_Format.Error "times" Value_Type.Date_Time ["2001-01-01", "10:00:10", "Tuesday", "foobar", "", "10:99:99", "1/2/2003", "2001-30-10"]]
            Problems.test_problem_handling a5 p5 t5

            a6 = t.parse columns=["times"] type=Value_Type.Time on_problems=_
            t6 t =
                t.at "times" . to_vector . should_equal [Nothing, Nothing, Time_Of_Day.new 10 0 10 0, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing]
            p6 = [Invalid_Format.Error "times" Value_Type.Time ["2001-01-01", "2001-01-01 12:34:56", "Tuesday", "foobar", "", "10:99:99", "1/2/2003", "2001-30-10"]]
            Problems.test_problem_handling a6 p6 t6

        Test.specify "should leave not selected columns unaffected" <|
            t1 = Table.new [["A", ["1", "2"]], ["B", ["3", "4"]]]
            t2 = t1.parse columns="B"
            t2.at "A" . to_vector . should_equal ["1", "2"]
            t2.at "B" . to_vector . should_equal [3, 4]

        Test.specify "should guess the datatype for columns" <|
            c1 = ["ints", ["1", "  +2", "-123", Nothing]]
            c2 = ["ints0", ["01", "02 ", Nothing, "-1"]]
            c3 = ["floats", ["  1.0  ", "2.2", Nothing, "-1.0"]]
            c4 = ["bools", ["true", " False", Nothing, "True"]]
            c5 = ["floats+ints", ["1", "2.2  ", "-1.0", Nothing]]
            c6 = ["text", ["foobar", "foo", "", Nothing]]
            c7 = ["dates", ["2022-10-01", "  2000-01-01", "1999-01-02", Nothing]]
            c8 = ["datetimes", ["2022-10-01 01:02:03  ", "2000-01-01 01:02:03", "1999-01-02 01:02:03", Nothing]]
            c9 = ["times", ["01:02:03", "  00:00:00  ", "01:02:03", Nothing]]
            c10 = ["mixeddates", ["2022-10-01", "2000-01-01 01:02:03", "01:02:03", Nothing]]
            c11 = ["text+ints", ["1", "2", "  foobar", Nothing]]
            t = Table.new [c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11]
            t2 = t.parse

            Problems.assume_no_problems t2
            t2.at "ints" . to_vector . should_equal [1, 2, -123, Nothing]
            t2.at "ints" . to_vector . first . should_be_a Integer
            t2.at "ints0" . to_vector . should_equal ["01", "02", Nothing, "-1"]
            t2.at "floats" . to_vector . should_equal [1.0, 2.2, Nothing, -1.0]
            t2.at "bools" . to_vector . should_equal [True, False, Nothing, True]
            t2.at "floats+ints" . to_vector . should_equal [1.0, 2.2, -1.0, Nothing]
            t2.at "text" . to_vector . should_equal ["foobar", "foo", "", Nothing]
            t2.at "dates" . to_vector . should_equal [Date.new 2022 10 1, Date.new 2000 1 1, Date.new 1999 1 2, Nothing]
            t2.at "datetimes" . to_vector . should_equal [Date_Time.new 2022 10 1 1 2 3, Date_Time.new 2000 1 1 1 2 3, Date_Time.new 1999 1 2 1 2 3, Nothing]
            t2.at "times" . to_vector . should_equal [Time_Of_Day.new 1 2 3, Time_Of_Day.new, Time_Of_Day.new 1 2 3, Nothing]
            t2.at "mixeddates" . to_vector . should_equal ["2022-10-01", "2000-01-01 01:02:03", "01:02:03", Nothing]
            t2.at "text+ints" . to_vector .  should_equal ["1", "2", "foobar", Nothing]

            # In Auto mode, integers take precedence over booleans.
            t3 = Table.new [["bools", ["1", "0", "True"]],  ["ints", ["1", "0", "0"]]] . parse format=(Data_Formatter.Value true_values=["1", "True"] false_values=["0", "False"])
            t3.at "bools" . to_vector . should_equal [True, False, True]
            t3.at "ints" . to_vector . should_equal [1, 0, 0]

            t4 = Table.new [c2] . parse format=(Data_Formatter.Value allow_leading_zeros=True)
            t4 . at "ints0" . to_vector . should_equal [1, 2, Nothing, -1]

            t5 = t.parse columns="ints" type=Value_Type.Float
            t5.at "ints" . to_vector . should_equal [1.0, 2.0, -123.0, Nothing]
            # `ints` are requested to be parsed as decimals.
            t5.at "ints" . to_vector . first . should_be_a Decimal

            t6 = t.parse columns=["floats", "text+ints"] type=Auto
            # `floats` are auto-detected as decimals.
            t6.at "floats" . to_vector . should_equal [1.0, 2.2, Nothing, -1.0]
            # `text+ints` is attempted to be parsed (hence whitespace is stripped), but it only fits the text type.
            t6.at "text+ints" . to_vector .  should_equal ["1", "2", "foobar", Nothing]
            # `bools` are not requested to be parsed, so they are kept as-is, with leading whitespace etc.
            t6.at "bools" . to_vector . should_equal ["true", " False", Nothing, "True"]

        Test.specify "should allow to specify a thousands separator and a custom decimal point" <|
            opts = Data_Formatter.Value decimal_point=',' thousand_separator='_'
            t1 = Table.new [["floats", ["0,0", "+0,0", "-0,0", "+1,5", "-1,2", "1,0", "0,0000", "10_000,", ",0"]]]
            t2 = t1.parse format=opts
            t2.at "floats" . to_vector . should_equal [0.0, 0.0, 0.0, 1.5, -1.2, 1.0, 0.0, 10000.0, 0.0]

            t3 = Table.new [["xs", ["1,2", "1.3", "_0", "0_", "1_0_0"]]]
            t4 = t3.parse format=opts type=Value_Type.Float
            t4.at "xs" . to_vector . should_equal [1.2, Nothing, Nothing, Nothing, 100.0]
            Problems.get_attached_warnings t4 . should_equal [Invalid_Format.Error "xs" Value_Type.Float ["1.3", "_0", "0_"]]
            t5 = t3.parse format=opts type=Value_Type.Integer
            t5.at "xs" . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing, 100]
            Problems.get_attached_warnings t5 . should_equal [Invalid_Format.Error "xs" Value_Type.Integer ["1,2", "1.3", "_0", "0_"]]

        Test.specify "should allow to specify custom values for booleans" <|
            opts_1 = Data_Formatter.Value true_values=["1", "YES"] false_values=["0"]
            t1 = Table.new [["bools", ["1", "0", "YES", "1", "0"]]]
            t2 = t1.parse format=opts_1
            t2.at "bools" . to_vector . should_equal [True, False, True, True, False]

            t3 = Table.new [["bools", ["1", "NO", "False", "True", "YES", "no", "oui", "0"]]]
            t4 = t3.parse format=opts_1 type=Value_Type.Boolean
            t4.at "bools" . to_vector . should_equal [True, Nothing, Nothing, Nothing, True, Nothing, Nothing, False]
            Problems.get_attached_warnings t4 . should_equal [Invalid_Format.Error "bools" Value_Type.Boolean ["NO", "False", "True", "no", "oui"]]

        whitespace_table =
            ints = ["ints", ["0", "1 ", "0 1", "     2"]]
            floats = ["floats", ["0    ", " 2.0", "- 1", "10.0"]]
            bools = ["bools", ["True ", " false", "t rue", "False"]]
            dates = ["dates", [" 2022-01-01", "2022-07-17    ", "2022 - 07 - 17", ""]]
            datetimes = ["datetimes", [" 2022-01-01 11:59:00   ", Nothing, "2022 - 07 - 17  1:2:3 ", "2022-01-01     11:59:00"]]
            times = ["times", ["11:00:00 ", "  00:00:00", "00 : 00 : 00", Nothing]]
            Table.new [ints, floats, bools, dates, datetimes, times]

        Test.specify "should trim input values by default" <|
            t1 = whitespace_table.parse columns="ints" type=Value_Type.Integer
            t1.at "ints" . to_vector . should_equal [0, 1, Nothing, 2]
            Problems.expect_only_warning (Invalid_Format.Error "ints" Value_Type.Integer ["0 1"]) t1

            t2 = whitespace_table.parse columns="floats" type=Value_Type.Float
            t2.at "floats" . to_vector . should_equal [0.0, 2.0, Nothing, 10.0]
            Problems.expect_only_warning (Invalid_Format.Error "floats" Value_Type.Float ["- 1"]) t2

            t3 = whitespace_table.parse columns="bools" type=Value_Type.Boolean
            t3.at "bools" . to_vector . should_equal [True, False, Nothing, False]
            Problems.expect_only_warning (Invalid_Format.Error "bools" Value_Type.Boolean ["t rue"]) t3

            t4 = whitespace_table.parse columns="dates" type=Value_Type.Date
            t4.at "dates" . to_vector . should_equal [Date.new 2022 1 1, Date.new 2022 7 17, Nothing, Nothing]
            Problems.expect_only_warning (Invalid_Format.Error "dates" Value_Type.Date ["2022 - 07 - 17", ""]) t4

            t5 = whitespace_table.parse columns="datetimes" type=Value_Type.Date_Time
            t5.at "datetimes" . to_vector . should_equal [Date_Time.new 2022 1 1 11 59, Nothing, Nothing, Nothing]
            Problems.expect_only_warning (Invalid_Format.Error "datetimes" Value_Type.Date_Time ["2022 - 07 - 17  1:2:3", "2022-01-01     11:59:00"]) t5

            t6 = whitespace_table.parse columns="times" type=Value_Type.Time
            t6.at "times" . to_vector . should_equal [Time_Of_Day.new 11 0 0, Time_Of_Day.new, Nothing, Nothing]
            Problems.expect_only_warning (Invalid_Format.Error "times" Value_Type.Time ["00 : 00 : 00"]) t6

        Test.specify "should fail to parse if whitespace is present and trimming is turned off" <|
            opts = Data_Formatter.Value trim_values=False
            t1 = whitespace_table.parse format=opts columns="ints" type=Value_Type.Integer
            t1.at "ints" . to_vector . should_equal [0, Nothing, Nothing, Nothing]
            Problems.expect_only_warning (Invalid_Format.Error "ints" Value_Type.Integer ["1 ", "0 1", "     2"]) t1

            t2 = whitespace_table.parse format=opts columns="floats" type=Value_Type.Float
            t2.at "floats" . to_vector . should_equal [Nothing, Nothing, Nothing, 10.0]
            Problems.expect_only_warning (Invalid_Format.Error "floats" Value_Type.Float ["0    ", " 2.0", "- 1"]) t2

            t3 = whitespace_table.parse format=opts columns="bools" type=Value_Type.Boolean
            t3.at "bools" . to_vector . should_equal [Nothing, Nothing, Nothing, False]
            Problems.expect_only_warning (Invalid_Format.Error "bools" Value_Type.Boolean ["True ", " false", "t rue"]) t3

            t4 = whitespace_table.parse format=opts columns="dates" type=Value_Type.Date
            t4.at "dates" . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]
            Problems.expect_only_warning (Invalid_Format.Error "dates" Value_Type.Date [" 2022-01-01", "2022-07-17    ", "2022 - 07 - 17", ""]) t4

            t5 = whitespace_table.parse format=opts columns="datetimes" type=Value_Type.Date_Time
            t5.at "datetimes" . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]
            Problems.expect_only_warning (Invalid_Format.Error "datetimes" Value_Type.Date_Time [" 2022-01-01 11:59:00   ", "2022 - 07 - 17  1:2:3 ", "2022-01-01     11:59:00"]) t5

            t6 = whitespace_table.parse format=opts columns="times" type=Value_Type.Time
            t6.at "times" . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]
            Problems.expect_only_warning (Invalid_Format.Error "times" Value_Type.Time ["11:00:00 ", "  00:00:00",  "00 : 00 : 00"]) t6

        Test.specify "should fallback to text if whitespace is present and trimming is turned off" <|
            c1 = ["1", "  +2", "-123", Nothing]
            c2 = ["  1.0  ", "2.2", Nothing, "-1.0"]
            c3 = ["true", " False", Nothing, "True"]
            t = Table.new [["ints", c1], ["floats", c2], ["bools", c3]]
            t2 = t.parse format=(Data_Formatter.Value trim_values=False)

            Warning.get_all t2 . should_equal []
            t2.at "ints" . to_vector . should_equal c1
            t2.at "floats" . to_vector . should_equal c2
            t2.at "bools" . to_vector . should_equal c3

        Test.specify "should allow selecting columns by regex" <|
            t1 = Table.new [["An", ["1", "2", "3"]], ["Am", ["4", "5", "6"]], ["C", ["7", "8", "9"]], ["D", ["10", "11", "12"]]]
            r1 = t1.parse columns=[Column_Selector.By_Name "A.*" use_regex=True]
            r1.at "An" . to_vector . should_equal [1, 2, 3]
            r1.at "Am" . to_vector . should_equal [4, 5, 6]
            r1.at "C" . to_vector . should_equal ["7", "8", "9"]
            r1.at "D" . to_vector . should_equal ["10", "11", "12"]

        Test.specify "should correctly handle problems: missing input columns" <|
            t1 = Table.new [["A", ["1", "2", "3"]]]
            r1 = t1.parse columns=["A", "B", "C", "E"] on_problems=Problem_Behavior.Ignore
            r1.should_fail_with Missing_Input_Columns
            r1.catch.criteria . should_equal ["B", "C", "E"]

            r2 = t1.parse columns=[Column_Selector.By_Name "A.+" use_regex=True]
            r2.should_fail_with Missing_Input_Columns
            r2.catch.criteria . should_equal ["A.+"]

            action = t1.parse columns=["A", "B", "C", "E"] error_on_missing_columns=False on_problems=_
            tester table =
                table.at "A" . to_vector . should_equal [1, 2, 3]
            problems = [Missing_Input_Columns.Error ["B", "C", "E"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: out of bounds indices" <|
            t1 = Table.new [["A", ["1", "2", "3"]]]
            r1 = t1.parse columns=[0, -1, 42, -5]
            r1.should_fail_with Column_Indexes_Out_Of_Range
            r1.catch.indexes . should_equal [42, -5]

            action = t1.parse columns=[0, -1, 42, -5] error_on_missing_columns=False on_problems=_
            tester table =
                table.at "A" . to_vector . should_equal [1, 2, 3]
            problems = [Column_Indexes_Out_Of_Range.Error [42, -5]]
            Problems.test_problem_handling action problems tester

        Test.specify "should allow mixed column selectors" <|
            t1 = Table.new [["Am", ["1", "2", "3"]], ["B", ["4", "5", "6"]], ["C", ["7", "8", "9"]], ["D", ["10", "11", "12"]]]
            r1 = t1.parse columns=[(Column_Selector.By_Name "A.*" use_regex=True), -2, "D"]
            r1.at "Am" . to_vector . should_equal [1, 2, 3]
            r1.at "B" . to_vector . should_equal ["4", "5", "6"]
            r1.at "C" . to_vector . should_equal [7, 8, 9]
            r1.at "D" . to_vector . should_equal [10, 11, 12]

        Test.specify "should handle edge-cases: overlapping selectors" <|
            t1 = Table.new [["Am", ["1", "2", "3"]], ["B", ["4", "5", "6"]], ["C", ["7", "8", "9"]], ["D", ["10", "11", "12"]]]
            r1 = t1.parse columns=[(Column_Selector.By_Name "A.*" use_regex=True), 0, "D", -1, -1, 0, 3]
            r1.at "Am" . to_vector . should_equal [1, 2, 3]
            r1.at "B" . to_vector . should_equal ["4", "5", "6"]
            r1.at "C" . to_vector . should_equal ["7", "8", "9"]
            r1.at "D" . to_vector . should_equal [10, 11, 12]

        Test.specify "should error if invalid target type is provided" <|
            t1 = Table.new [["A", ["1", "2", "3"]]]
            t1.parse type=Nothing . should_fail_with Illegal_Argument

        Test.specify "should error if the input column is not text" <|
            t1 = Table.new [["A", [1, 2, 3]], ["B", ["4", "5", "6"]], ["C", [7, 8, 9]], ["D", ["10", "11", "12"]]]
            r1 = t1.parse columns=["A", "B", "C"]
            r1.should_fail_with Invalid_Value_Type
            r1.catch.related_column . should_equal "A"
            r1.catch.expected.is_text.should_be_true

        Test.specify "should error if no input columns selected, unless error_on_missing_columns=False" <|
            t1 = Table.new [["A", ["1", "2", "3"]]]
            r1 = t1.parse columns=[]
            r1.should_fail_with No_Input_Columns_Selected

            r2 = t1.parse columns=[] error_on_missing_columns=False
            r2 . should_equal t1
            Problems.expect_warning No_Input_Columns_Selected r2

            r3 = t1.parse columns=[] error_on_missing_columns=False on_problems=Problem_Behavior.Ignore
            r3 . should_equal t1
            Problems.assume_no_problems r3

            r4 = t1.parse columns=["nonexistent column :D", -42] error_on_missing_columns=False on_problems=Problem_Behavior.Report_Warning
            r4 . should_equal t1
            Problems.expect_warning No_Input_Columns_Selected r4
            Problems.expect_warning (Missing_Input_Columns.Error ["nonexistent column :D"]) r4
            Problems.expect_warning (Column_Indexes_Out_Of_Range.Error [-42]) r4

    Test.group "Column.parse" <|
        Test.specify "should correctly parse integers" <|
            c1 = Column.from_vector "ints" ["0", "+0", "-0", "+1", "-1", "1", "000", "0010", "12345", Nothing]
            c2 = c1.parse type=Value_Type.Integer
            c2.name.should_equal c1.name
            c2 . to_vector . should_equal [0, 0, 0, 1, -1, 1, Nothing, Nothing, 12345, Nothing]
            c2.value_type.should_equal Value_Type.Integer
            Problems.expect_warning Leading_Zeros c2

            c3 = c1.parse type=Value_Type.Integer format=(Data_Formatter.Value.with_number_formatting allow_leading_zeros=True)
            c3.to_vector . should_equal [0, 0, 0, 1, -1, 1, 0, 10, 12345, Nothing]
            Problems.assume_no_problems c3

        Test.specify "should correctly parse decimals" <|
            c1 = Column.from_vector "ints" ["0", "+0", "-0", "+1", "-1", "1", "000", "0010", "12345", Nothing]
            c2 = c1.parse Value_Type.Float
            c2.name.should_equal c1.name
            c2.to_vector . should_equal [0, 0, 0, 1, -1, 1, Nothing, Nothing, 12345, Nothing]
            c2.value_type.should_equal Value_Type.Float
            c2.to_vector . map .to_text . should_equal ["0.0", "0.0", "-0.0", "1.0", "-1.0", "1.0", "Nothing", "Nothing", "12345.0", "Nothing"]
            Problems.expect_warning Leading_Zeros c2

            c3 = Column.from_vector "floats" ["0.0", "+0.0", "-0.0", "+1.0", "-1.0", "1.0", "0.0000", "10.", "12345."]
            c4 = c3.parse Value_Type.Float
            c4.to_vector . should_equal [0, 0, 0, 1, -1, 1, 0, 10, 12345]
            c4.value_type.is_floating_point.should_be_true
            Problems.assume_no_problems c4

            c5 = Column.from_vector "floats" [".0", "0.", "1.", ".1", ".123", "-.1", "+.1", "+0.0", "0.1234", Nothing, "11111111.111"]
            c6 = c5.parse Value_Type.Float
            c6.to_vector . should_equal [0.0, 0.0, 1.0, 0.1, 0.123, -0.1, 0.1, 0.0, 0.1234, Nothing, 11111111.111]
            Problems.assume_no_problems c6

        Test.specify "should correctly parse booleans" <|
            c1 = Column.from_vector "bools" ["true", "false", "True", "TRUE", "FALSE", Nothing, "False"]
            c2 = c1.parse type=Value_Type.Boolean
            c2.name.should_equal c1.name
            c2.to_vector . should_equal [True, False, True, True, False, Nothing, False]
            c2.value_type.should_equal Value_Type.Boolean
            c1.parse . to_vector . should_equal [True, False, True, True, False, Nothing, False]

            c3 = Column.from_vector "bools" ["yes", "no", Nothing]
            c4 = c3.parse type=Value_Type.Boolean "yes|no"
            c4.to_vector . should_equal [True, False, Nothing]

            c5 = Column.from_vector "bools" ["true", "yes", "false"]
            c6 = c5.parse type=Value_Type.Boolean
            c6.to_vector . should_equal [True, Nothing, False]
            w = Problems.get_attached_warnings c6 . find w-> w.is_a Invalid_Format
            w.column.should_equal "bools"
            w.value_type . should_equal Value_Type.Boolean
            w.cells . should_equal ["yes"]

        Test.specify "should correctly parse date and time" <|
            c1 = Column.from_vector "date" ["2022-05-07", "2000-01-01", "2010-12-31"]
            c2 = c1.parse type=Value_Type.Date
            c2.to_vector . should_equal [Date.new 2022 5 7, Date.new 2000 1 1, Date.new 2010 12 31]
            c2.value_type.should_equal Value_Type.Date

            c3 = Column.from_vector "datetimes" ["2022-05-07 23:59:59", "2000-01-01 00:00:00", "2010-12-31 12:34:56", "2010-12-31T12:34:56", "2010-12-31 12:34:56.123"]
            c4 = c3.parse type=Value_Type.Date_Time
            c4.to_vector . should_equal [Date_Time.new 2022 5 7 23 59 59, Date_Time.new 2000 1 1, Date_Time.new 2010 12 31 12 34 56, Date_Time.new 2010 12 31 12 34 56, Date_Time.new 2010 12 31 12 34 56 123]
            c4.value_type.should_equal Value_Type.Date_Time

            c5 = Column.from_vector "times" ["23:59:59", "00:00:00", "12:34:56"]
            c6 = c5.parse type=Value_Type.Time
            c6.to_vector . should_equal [Time_Of_Day.new 23 59 59, Time_Of_Day.new, Time_Of_Day.new 12 34 56]
            c6.value_type.should_equal Value_Type.Time

            c7 = Column.from_vector "foo" ["2022-05-07 23:59:59", "42", "2010-12-31"]
            c8 = c7.parse type=Value_Type.Date_Time . to_vector . should_equal [Date_Time.new 2022 5 7 23 59 59, Nothing, Nothing]
            w = Problems.get_attached_warnings c8 . find w-> w.is_a Invalid_Format
            w.column.should_equal "foo"
            w.value_type . should_equal Value_Type.Date_Time
            w.cells . should_equal ["42", "2010-12-31"]

        Test.specify "should correctly parse date and time with format" <|
            c1 = Column.from_vector "date" ["5/7/2022", "1/1/2000", "12/31/2010"]
            c2 = c1.parse type=Value_Type.Date "M/d/yyyy"
            c2.to_vector . should_equal [Date.new 2022 5 7, Date.new 2000 1 1, Date.new 2010 12 31]

            c3 = Column.from_vector "datetimes" ["5/7/2022 23:59:59", "1/1/2000 00:00:00", "12/31/2010 12:34:56"]
            c4 = c3.parse type=Value_Type.Date_Time "M/d/yyyy HH:mm:ss"
            c4.to_vector . should_equal [Date_Time.new 2022 5 7 23 59 59, Date_Time.new 2000 1 1, Date_Time.new 2010 12 31 12 34 56]

        Test.specify "should handle invalid format strings gracefully" <|
            c1 = Column.from_vector "date" ["5/7/2022", "1/1/2000", "12/31/2010"]
            c1.parse type=Value_Type.Date "M/d/fqsrf" . should_fail_with Illegal_Argument
            c1.parse type=Value_Type.Time "HH:mm:ss.fff" . should_fail_with Illegal_Argument
            c1.parse type=Value_Type.Date_Time "M/d/fqsrf HH:mm:ss.fff" . should_fail_with Illegal_Argument

        Test.specify "should correctly work in Auto mode" <|
            c1 = Column.from_vector "A" ["1", "2", "3"]
            c2 = Column.from_vector "B" ["1.0", "2.5", "3"]
            c3 = Column.from_vector "C" ["2022-05-07", "2000-01-01", "2010-12-31"]
            c4 = Column.from_vector "D" ["TRUE", "False", Nothing]
            c5 = Column.from_vector "E" ["yes", "no"]
            c6 = Column.from_vector "F" ["this is here to ensure the column has type text... can be replaced one we have retyping"]
            c7 = Column.from_vector "G" ["true", "42"]
            c8 = Column.from_vector "H" ["text-to-force-value-type-to-be-text", Nothing, Nothing, Nothing]
            c8.value_type . should_equal Value_Type.Char

            r1 = c1.parse
            r1.to_vector . should_equal [1, 2, 3]
            r1.value_type.should_equal Value_Type.Integer
            Problems.assume_no_problems r1

            r2 = c2.parse
            r2.to_vector . should_equal [1.0, 2.5, 3.0]
            r2.value_type.should_equal Value_Type.Float
            Problems.assume_no_problems r2

            r3 = c3.parse
            r3.to_vector . should_equal [Date.new 2022 5 7, Date.new 2000 1 1, Date.new 2010 12 31]
            r3.value_type.should_equal Value_Type.Date
            Problems.assume_no_problems r3

            r4 = c4.parse
            r4.to_vector . should_equal [True, False, Nothing]
            r4.value_type.should_equal Value_Type.Boolean
            Problems.assume_no_problems r4

            r5 = c5.parse
            r5.to_vector . should_equal ["yes", "no"]
            Problems.assume_no_problems r5

            c5.parse format="yes|no" . should_fail_with Illegal_Argument
            r5_2 = c5.parse format=(Data_Formatter.Value.with_boolean_values ["yes"] ["no"])
            r5_2.to_vector . should_equal [True, False]
            r5_2.value_type . should_equal Value_Type.Boolean
            Problems.assume_no_problems r5_2

            r6 = (c6.drop 1).parse
            r6.to_vector . should_equal []
            r6.value_type . should_equal Value_Type.Char
            Problems.assume_no_problems r6

            r7 = c7.parse
            r7.to_vector . should_equal ["true", "42"]
            r7.value_type . should_equal Value_Type.Char
            Problems.assume_no_problems r7

            r8 = c8.drop 1 . parse
            r8.value_type . should_equal Value_Type.Char
            r8.to_vector . should_equal [Nothing, Nothing, Nothing]
            Problems.assume_no_problems r8

        Test.specify "should error if invalid target type is provided" <|
            c1 = Column.from_vector "A" ["1", "2", "3"]
            c1.parse type=Nothing . should_fail_with Illegal_Argument

        Test.specify "should error if the input column is not text" <|
            c1 = Column.from_vector "A" [1, 2, 3]
            r1 = c1.parse
            r1.should_fail_with Invalid_Value_Type
            r1.catch.related_column . should_equal "A"
            r1.catch.expected.is_text.should_be_true


main = Test_Suite.run_main spec
