from Standard.Base import all

from Standard.Table.Data.Matching import all
from Standard.Table.Error as Error_Module import all
import Standard.Base.Error.Problem_Behavior
import Standard.Base.Error.Warnings
import Standard.Test

type Foo_Error

spec = Test.group 'Matching Helper' <|
    ## These are workarounds to #1600 - default arguments do not work properly
       on Atom constructors.

       Once this is fixed, the tests should be updated accordingly.
    exact = Exact case_sensitivity=True
    regex = Regex case_sensitivity=True
    Test.specify 'Should match a single name with a single exact criterion' <|
        Matching.match_single_criterion "foo" "foo" exact . should_equal True
        Matching.match_single_criterion "foo" "f.*" exact . should_equal False
        Matching.match_single_criterion "foo" "Foo" exact . should_equal False

    Test.specify 'Should correctly handle Unicode folding with exact matching' <|
        Matching.match_single_criterion '\u00E9' '\u0065\u{301}' exact . should_equal True
        Matching.match_single_criterion 'é' '\u00E9' exact . should_equal True
        Matching.match_single_criterion 'é' 'ę' exact . should_equal False

    Test.specify 'Should match a single name with a single regex criterion' <|
        Matching.match_single_criterion "foo" "foo" regex . should_equal True
        Matching.match_single_criterion "foo" "f.*" regex . should_equal True
        Matching.match_single_criterion "foo" "F.*" regex . should_equal False

    Test.specify 'Should support case-insensitive matching' <|
        Matching.match_single_criterion "foo" "F.*" (Regex case_sensitivity=Case_Insensitive) . should_equal True
        Matching.match_single_criterion "foo" "Foo" (Exact case_sensitivity=Case_Insensitive) . should_equal True

        Matching.match_single_criterion "foo" "fF.*" (Regex case_sensitivity=Case_Insensitive) . should_equal False
        Matching.match_single_criterion "foo" "Foos" (Exact case_sensitivity=Case_Insensitive) . should_equal False

        ## TODO this may not be how we want this to work, but this test is
           included to explicitly illustrate how the current implementation
           behaves in such corner cases
        Matching.match_single_criterion "β" "B" (Exact case_sensitivity=Case_Insensitive) . should_equal False

    Test.specify 'Should match a list of names with a list of criteria, correctly handling reordering' <|
        Matching.match_criteria ["foo", "bar", "baz"] ["baz", "foo"] reorder=True . should_equal ["baz", "foo"]
        Matching.match_criteria ["foo", "bar", "baz"] ["baz", "foo"] reorder=False . should_equal ["foo", "baz"]

    Test.specify 'Should allow multiple matches to a single criterion (Regex)' <|
        Matching.match_criteria ["foo", "bar", "baz", "quux"] ["b.*"] reorder=True matching_strategy=regex . should_equal ["bar", "baz"]
        Matching.match_criteria ["foo", "bar", "baz", "quux"] ["b.*", "foo"] reorder=False matching_strategy=regex . should_equal ["foo", "bar", "baz"]

    Test.specify 'Should include the object only with the first criterion that matched it, avoiding duplication' <|
        Matching.match_criteria ["foo", "bar", "baz", "zap"] [".*z.*", "b.*"] reorder=True matching_strategy=regex . should_equal ["baz", "zap", "bar"]
        Matching.match_criteria ["foo", "bar", "baz", "zap"] [".*z.*", "b.*"] reorder=False matching_strategy=regex . should_equal ["bar", "baz", "zap"]

    Test.specify 'Should correctly handle criteria which did not match anything' <|
        Matching.match_criteria ["foo", "bar", "baz"] ["baz", "unknown_column"] reorder=True on_problems=Problem_Behavior.Report_Error . should_fail_with No_Matches_Found
        result = Matching.match_criteria ["foo", "bar", "baz"] ["baz", "unknown_column_1", "unknown_column_2"] reorder=False on_problems=Problem_Behavior.Report_Error . catch
        result . should_equal <| No_Matches_Found ["unknown_column_1", "unknown_column_2"]

        warnings_builder = Vector.new_builder
        report_warning warning =
            warnings_builder.append warning
        warning_system = Warnings.Warning_System report_warning
        Matching.match_criteria ["foo", "bar", "baz"] ["baz", "unknown_column_1", "unknown_column_2"] reorder=True on_problems=Problem_Behavior.Report_Warning warnings=warning_system . should_equal ["baz"]
        reported = warnings_builder.to_vector
        reported.length . should_equal 1
        reported.first . should_equal <| No_Matches_Found ["unknown_column_1", "unknown_column_2"]

    Test.specify 'Should correctly work with complex object using a function extracting their names' <|
        pairs = [Pair "foo" 42, Pair "bar" 33, Pair "baz" 10, Pair "foo" 0, Pair 10 10]
        selected = [Pair "bar" 33, Pair "foo" 42, Pair "foo" 0]
        Matching.match_criteria pairs ["bar", "foo"] reorder=True name_mapper=_.first . should_equal selected

        Matching.match_criteria [1, 2, 3] ["2"] name_mapper=_.to_text . should_equal [2]

    Test.specify 'Should correctly forward errors' <|
        Matching.match_criteria (Error.throw Foo_Error) [] . should_fail_with Foo_Error
        Matching.match_criteria [] (Error.throw Foo_Error) . should_fail_with Foo_Error
        Matching.match_criteria [] [] (Error.throw Foo_Error) . should_fail_with Foo_Error
        Matching.match_criteria ["a"] ["a"] name_mapper=(_-> Error.throw Foo_Error) . should_fail_with Foo_Error
        Matching.match_criteria ["a"] ["a"] name_mapper=_.nonexistent_function . should_fail_with No_Such_Method_Error

main = Test.Suite.run_main here.spec
