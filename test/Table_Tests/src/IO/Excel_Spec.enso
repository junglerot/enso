from Standard.Base import all
import Standard.Base.Errors.Common.Dry_Run_Operation
import Standard.Base.Errors.File_Error.File_Error
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument
import Standard.Base.Errors.Illegal_State.Illegal_State
import Standard.Base.Runtime.Context
import Standard.Base.Runtime.Managed_Resource.Managed_Resource
import Standard.Base.Runtime.Ref.Ref

from Standard.Table import Table, Match_Columns, Excel, Excel_Range, Data_Formatter, Sheet_Names, Range_Names, Worksheet, Cell_Range, Delimited, Excel_Workbook

from Standard.Table.Errors import Invalid_Column_Names, Duplicate_Output_Column_Names, Invalid_Location, Range_Exceeded, Existing_Data, Column_Count_Mismatch, Column_Name_Mismatch, Empty_Sheet_Error

from Standard.Test import Test, Test_Suite, Problems
import Standard.Test.Extensions

import Standard.Examples

import project.Util

polyglot java import org.enso.table_test_helpers.RandomHelpers

spec_fmt header file read_method sheet_count=5 =
    Test.group header <|
        Test.specify "should read a workbook in" <|
            wb = read_method file
            wb.sheet_count . should_equal sheet_count

        Test.specify "should read the specified sheet by index and use correct headers" <|
            t = read_method file (Excel (Worksheet 1))
            t.columns.map .name . should_equal ['Name', 'Quantity', 'Price']
            t.at 'Name' . to_vector . should_equal ['blouse', 't-shirt', 'trousers', 'shoes', 'skirt', 'dress']
            t.at 'Quantity' . to_vector . should_equal [10, 20, Nothing, 30, Nothing, 5]
            t.at 'Price' . to_vector . should_equal [22.3, 32, 43.2, 54, 31, Nothing]

        Test.specify "should read the specified sheet by index and properly format a table" <|
            t = read_method file (Excel (Worksheet 2) headers=False)
            t.columns.map .name . should_equal ['A', 'B', 'C', 'D', 'E']
            t.at 'A' . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing]
            t.at 'B' . to_vector . should_equal [Nothing, Nothing, 10, Nothing, Nothing, Nothing, Nothing]
            t.at 'C' . to_vector . should_equal [Nothing, 'baz', 20, Nothing, 'bar', Nothing, 30]
            t.at 'D' . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing]
            t.at 'E' . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing, Nothing, 'foo', Nothing]

        Test.specify "should read the specified sheet by name and properly handle dates" <|
            t = read_method file (Excel (Worksheet 'Dates'))
            t.columns.map .name . should_equal ['Student Name', 'Enrolment Date']
            t.at 'Enrolment Date' . map .day . to_vector . should_equal [2, 26, 4, 24, 31, 7]

        Test.specify "should give an informative error when reading an empty table" <|
            t = read_method file (Excel (Worksheet "Empty"))
            t.should_fail_with Empty_Sheet_Error

        Test.specify "should gracefully handle duplicate column names and formulas" <|
            t = read_method file (Excel (Worksheet "Duplicate Columns"))
            t.columns.map .name . should_equal ['Item', 'Price', 'Quantity', 'Price 1']
            t.at 'Price 1' . to_vector . should_equal [20, 40, 0, 60, 0, 10]

        Test.specify "should allow reading with cell range specified" <|
            t_1 = read_method file (Excel (Cell_Range "Simple!B:C"))
            t_1.columns.map .name . should_equal ['Quantity', 'Price']
            t_1.at 'Quantity' . to_vector . should_equal [10, 20, Nothing, 30, Nothing, 5]
            t_1.at 'Price' . to_vector . should_equal [22.3, 32, 43.2, 54, 31, Nothing]

            t_2 = read_method file (Excel (Cell_Range "Simple!3:5") headers=False)
            t_2.column_count.should_equal 3
            t_2.at 'A' . to_vector . should_equal ['t-shirt', 'trousers', 'shoes']
            t_2.at 'B' . to_vector . should_equal [20, Nothing, 30]
            t_2.at 'C' . to_vector . should_equal [32, 43.2, 54]

            t_3 = read_method file (Excel (Cell_Range "Simple!B4:C5") headers=False)
            t_3.column_count.should_equal 2
            t_3.at 'B' . to_vector . should_equal [Nothing, 30]
            t_3.at 'C' . to_vector . should_equal [43.2, 54]

spec_write suffix test_sheet_name =
    Test.group ("Write " + suffix + " Files") <|
        table = enso_project.data/'varied_column.csv' . read
        clothes = enso_project.data/'clothes.csv' . read
        sub_clothes = clothes.select_columns [0, 1]

        counter = Ref.new 0
        create_out =
            i = counter.get + 1
            counter.put i
            f = enso_project.data / "transient" / ("out" + i.to_text + "." + suffix)
            Panic.rethrow f.delete_if_exists
            f

        Test.specify 'should write a table to non-existent file as a new sheet with headers; and return the file object on success' <|
            out = create_out
            table.write out on_problems=Report_Error . should_succeed . should_equal out
            written = out.read
            written.sheet_count . should_equal 1
            written.sheet_names . should_equal ['EnsoSheet']
            written.read 'EnsoSheet' . should_equal table
            written.close
            out.delete_if_exists . should_succeed

        Test.specify 'should write a table to non-existent file in append mode as a new sheet with headers' <|
            out = create_out
            table.write out on_existing_file=Existing_File_Behavior.Append on_problems=Report_Error . should_succeed
            written = out.read
            written.sheet_count . should_equal 1
            written.sheet_names . should_equal ['EnsoSheet']
            written.read 'EnsoSheet' . should_equal table
            written.close
            out.delete_if_exists . should_succeed

        Test.specify 'should write a table to existing file overriding EnsoSheet' <|
            out = create_out
            table.write out on_problems=Report_Error . should_succeed
            table.write out on_problems=Report_Error . should_succeed
            written_workbook = out.read
            written_workbook.sheet_count . should_equal 1
            written_workbook.sheet_names . should_equal ['EnsoSheet']
            written_workbook.read 'EnsoSheet' . should_equal table
            written_workbook.close
            out.delete_if_exists . should_succeed

        Test.specify 'should write a table to existing file in overwrite mode as a new sheet with headers' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            table.write out (Excel (Worksheet "Another")) on_existing_file=Existing_File_Behavior.Overwrite on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "Another"))
            written.should_equal table
            out.delete_if_exists . should_succeed

        Test.specify 'should write a table to existing file in overwrite mode as a new sheet without headers' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            table.write out (Excel (Worksheet "NoHeaders")) on_existing_file=Existing_File_Behavior.Overwrite on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "NoHeaders"))
            written.should_equal (table.rename_columns ['A', 'B', 'C', 'D', 'E', 'F'])
            out.delete_if_exists . should_succeed

        Test.specify 'should create new sheets at the start if index is 0' <|
            out = create_out
            table.write out (Excel (Worksheet 0)) on_problems=Report_Error . should_succeed
            clothes.write out (Excel (Worksheet 0)) on_problems=Report_Error . should_succeed
            read_1 = out.read (Excel (Worksheet "Sheet1"))
            read_1 . should_equal table
            read_2 = out.read (Excel (Worksheet "Sheet2"))
            read_2 . should_equal clothes
            read_3 = out.read (Excel (Sheet_Names))
            read_3 . should_equal ["Sheet2", "Sheet1"]
            out.delete_if_exists . should_succeed

        Test.specify 'should write a table to specific single cell location of an existing sheet' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            table.write out (Excel (Cell_Range "Another!G1")) on_problems=Report_Error . should_succeed
            written = out.read (Excel (Cell_Range "Another!G1"))
            written.should_equal table
            out.delete_if_exists . should_succeed

        Test.specify 'should clear out an existing fixed range and replace' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            sub_clothes.write out (Excel (Cell_Range "Another!A1:D20")) on_problems=Report_Error . should_succeed
            written = out.read (Excel (Cell_Range "Another!A1"))
            written.should_equal sub_clothes
            out.delete_if_exists . should_succeed

        Test.specify 'should clear out an existing range and replace' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            sub_clothes.write out (Excel (Cell_Range "Another!A1")) on_problems=Report_Error . should_succeed
            written = out.read (Excel (Cell_Range "Another!A1"))
            written.should_equal sub_clothes
            out.delete_if_exists . should_succeed

        Test.specify 'should result in Invalid_Location error if trying to write in a bad location' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            sub_clothes.write out (Excel (Cell_Range "DoesNotExist!A1")) . should_fail_with Invalid_Location
            sub_clothes.write out (Excel (Cell_Range "DoesNotExist!A1:B2")) . should_fail_with Invalid_Location
            sub_clothes.write out (Excel (Cell_Range "SillyRangeName")) . should_fail_with Invalid_Location
            out.delete_if_exists . should_succeed

        Test.specify 'should result in Range_Exceeded error if trying to write in too small a range' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            sub_clothes.write out (Excel (Cell_Range "Another!A1:B2")) . should_fail_with Range_Exceeded
            out.delete_if_exists . should_succeed

        Test.specify 'should result in Existing_Data error if in Error mode and trying to replace' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            r1 = sub_clothes.write out (Excel (Worksheet 1)) on_existing_file=Existing_File_Behavior.Error
            r1.should_fail_with File_Error
            r1.catch.should_be_a File_Error.Already_Exists

            sub_clothes.write out (Excel (Worksheet "Another")) on_existing_file=Existing_File_Behavior.Error . should_fail_with File_Error
            sub_clothes.write out (Excel (Cell_Range "Another!A1")) on_existing_file=Existing_File_Behavior.Error . should_fail_with File_Error
            sub_clothes.write out (Excel (Cell_Range "Sheet1!A9")) on_existing_file=Existing_File_Behavior.Error . should_fail_with File_Error

            Test.with_clue "the original file should remain unmodified: " <|
                out.last_modified_time.should_equal lmd
            out.delete_if_exists . should_succeed

        Test.specify 'should not allow adding a new sheet if in Error mode, even if sheet is not clashing' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            result = sub_clothes.write out (Excel (Worksheet "Testing")) on_existing_file=Existing_File_Behavior.Error
            result.should_fail_with File_Error
            result.catch.should_be_a File_Error.Already_Exists
            Test.with_clue "the original file should remain unmodified: " <|
                out.last_modified_time.should_equal lmd
            out.delete_if_exists . should_succeed

        Test.specify 'should write a table to non-existent file as a new sheet without headers' <|
            out = create_out
            table.write out (Excel (Worksheet "Sheet1") headers=False) on_problems=Report_Error . should_succeed
            written = out.read
            written.sheet_count . should_equal 1
            written.sheet_names . should_equal ['Sheet1']
            written.read 'Sheet1' . should_equal (table.rename_columns ['A', 'B', 'C', 'D', 'E', 'F'])

            # We need to close the workbook to be able to delete it.
            written.close
            out.delete_if_exists . should_succeed

        Test.specify 'should be able to append to a sheet by name' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['AA', ['d', 'e']], ['BB',[4, 5]], ['CC',[True, False]], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (Excel (Worksheet "Another")) on_existing_file=Existing_File_Behavior.Append on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "Another")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists . should_succeed

        Test.specify 'should be able to append to a sheet by position' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['A', ['d', 'e']], ['B',[4, 5]], ['C',[True, False]], ['D', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (Excel (Worksheet "Another")) on_existing_file=Existing_File_Behavior.Append match_columns=Match_Columns.By_Position on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "Another")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists . should_succeed

        Test.specify 'should be able to append to a sheet by name out of order' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (Excel (Worksheet "Another")) on_existing_file=Existing_File_Behavior.Append on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "Another")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists . should_succeed

        Test.specify 'should be able to append to a single cell by name' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['AA', ['d', 'e']], ['BB',[4, 5]], ['CC',[True, False]], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (Excel (Cell_Range "Another!A1")) on_existing_file=Existing_File_Behavior.Append on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "Another")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists . should_succeed

        Test.specify 'should be able to append to a single cell by position' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['A', ['d', 'e']], ['B',[4, 5]], ['C',[True, False]], ['D', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (Excel (Cell_Range "Another!A1")) on_existing_file=Existing_File_Behavior.Append match_columns=Match_Columns.By_Position on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "Another")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists . should_succeed

        Test.specify 'should be able to append to a single cell by name out of order' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (Excel (Cell_Range "Another!A1")) on_existing_file=Existing_File_Behavior.Append on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "Another")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists . should_succeed

        Test.specify 'should be able to append to a range by name' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['AA', ['d', 'e']], ['BB', [4, 5]], ['CC', [True, False]], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a', 'b', 'c', 'd', 'e']], ['BB', [1, 2, 3, 4, 5]], ['CC', [True, False, False, True, False]]]
            extra_another.write out (Excel (Cell_Range "Another!A1:D6")) on_existing_file=Existing_File_Behavior.Append on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "Another")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists . should_succeed

        Test.specify 'should be able to append to a range by position' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['A', ['d', 'e']], ['B',[4, 5]], ['C',[True, False]], ['D', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (Excel (Cell_Range "Another!A1:D6")) on_existing_file=Existing_File_Behavior.Append match_columns=Match_Columns.By_Position on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "Another")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists . should_succeed

        Test.specify 'should be able to append to a range by name not in top left' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['AA', ['d', 'e']], ['BB',[4, 5]], ['CC',[True, False]], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['f', 'g', 'h', 'd', 'e']], ['BB',[1, 2, 3, 4, 5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (Excel (Cell_Range "Random!K9")) on_existing_file=Existing_File_Behavior.Append on_problems=Report_Error . should_succeed
            written = out.read (Excel (Cell_Range "Random!K9")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists . should_succeed

        Test.specify 'should be able to append to a range by name after deduplication of names' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['AA', ['d', 'e']], ['BB',[4, 5]], ['AA 1',[True, False]], ['BB 1', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['f', 'g', 'h', 'd', 'e']], ['BB',[1, 2, 3, 4, 5]], ['AA 1',[True, False, False, True, False]]]
            extra_another.write out (Excel (Cell_Range "Random!S3")) on_existing_file=Existing_File_Behavior.Append on_problems=Report_Error . should_succeed
            written = out.read (Excel (Cell_Range "Random!S3")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists . should_succeed

        Test.specify 'should be able to append to a range by position not in top left' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['A', ['d', 'e']], ['B',[4, 5]], ['C',[True, False]], ['D', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['f', 'g', 'h', 'd', 'e']], ['BB',[1, 2, 3, 4, 5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (Excel (Cell_Range "Random!K9")) on_existing_file=Existing_File_Behavior.Append match_columns=Match_Columns.By_Position on_problems=Report_Error . should_succeed
            written = out.read (Excel (Cell_Range "Random!K9")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists . should_succeed

        Test.specify 'should be able to append to a range by name out of order' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']], ['DD', ['2022-01-20', '2022-01-21']]]
            expected = Table.new [['AA', ['a','b','c','d', 'e']], ['BB',[1,2,3,4,5]], ['CC',[True, False, False, True, False]]]
            extra_another.write out (Excel (Cell_Range "Another!A1:D6")) on_existing_file=Existing_File_Behavior.Append on_problems=Report_Error . should_succeed
            written = out.read (Excel (Worksheet "Another")) . select_columns [0, 1, 2]
            written.should_equal expected
            out.delete_if_exists . should_succeed

        Test.specify 'should be able to write to a new dry run file' <|
            out = create_out
            temp = Context.Output.with_disabled <|
                result = table.write out on_problems=Report_Error . should_succeed
                Problems.expect_only_warning Dry_Run_Operation result
                result.exists.should_be_true

                result.absolute.normalize.path . should_not_equal out.absolute.normalize.path

                written = result.read
                written.sheet_count . should_equal 1
                written.sheet_names . should_equal ['EnsoSheet']
                written.read 'EnsoSheet' . should_equal table
                written.close
                result
            temp.delete_if_exists

        Test.specify "should be able to write to a dry-run file, even if the dry-run workbook is open" <|
            out = create_out
            out.exists.should_be_false
            temp = Context.Output.with_disabled <|
                result = table.write out on_problems=Report_Error . should_succeed
                Problems.expect_only_warning Dry_Run_Operation result
                result.exists.should_be_true
                result
            temp.absolute.normalize.path . should_not_equal out.absolute.normalize.path
            out.exists.should_be_false

            opened_temp = temp.read
            opened_temp.sheet_names . should_equal ['EnsoSheet']

            temp2 = Context.Output.with_disabled <|
                result = table.write out (Excel (Worksheet "Another")) on_problems=Report_Error . should_succeed
                Problems.expect_only_warning Dry_Run_Operation result
                result.exists.should_be_true
                result

            # The result should be written to the same dry-run file on second attempt.
            temp2.absolute.normalize.path . should_equal temp.absolute.normalize.path

            ## The write operation replaces the dry run file, basing off of the _original_ out file
               (which was empty in this example), so we still only get one sheet.
               Different example is tested in the test below, if the subsequent file happens to the returned
               dry-run object - then both updates are visible - see below.
            opened_temp.sheet_names . should_equal ['Another']

            opened_temp.close
            temp.delete_if_exists

        Test.specify "should be able to write to a dry-run file multiple times if the dry-run file object is threaded through" <|
            out = create_out
            temp1 = Context.Output.with_disabled <|
                result = table.write out on_problems=Report_Error . should_succeed
                Problems.expect_only_warning Dry_Run_Operation result
                result.exists.should_be_true
                result
            temp1.absolute.normalize.path . should_not_equal out.absolute.normalize.path

            opened_temp = temp1.read
            opened_temp.sheet_names . should_equal ['EnsoSheet']

            temp2 = Context.Output.with_disabled <|
                result = table.write temp1 (Excel (Worksheet "Another")) on_problems=Report_Error . should_succeed
                Problems.expect_only_warning Dry_Run_Operation result
                result.exists.should_be_true
                result

            # The result should be written to the same file though.
            temp2.absolute.normalize.path . should_equal temp1.absolute.normalize.path

            # The write operation replaces the dry run file, basing off of the dry-run file itself - so both changes are visible.
            opened_temp.sheet_names . should_equal ['EnsoSheet', 'Another']

            opened_temp.close
            temp1.delete_if_exists

        Test.specify "should be able to create a backup, even if it is currently open" <|
            out = create_out
            bak = out.parent / (out.name+".bak")

            t1 = Table.new [["X", [1]]]
            t1.write out on_existing_file=Existing_File_Behavior.Backup on_problems=Report_Error . should_succeed
            bak.exists.should_be_false

            t2 = Table.new [["X", [2]]]
            t2.write out on_existing_file=Existing_File_Behavior.Backup on_problems=Report_Error . should_succeed
            bak.exists.should_be_true

            opened_out = out.read
            # We need to specify explicit format for the backup, because the extension is changed:
            opened_backup = bak.read (Excel xls_format=(suffix=="xls"))

            opened_out.read 'EnsoSheet' . should_equal t2
            opened_backup.read 'EnsoSheet' . should_equal t1

            t3 = Table.new [["X", [3]]]
            t3.write out on_existing_file=Existing_File_Behavior.Backup on_problems=Report_Error . should_succeed

            opened_out.read 'EnsoSheet' . should_equal t3
            # The backup should actually have been updated
            opened_backup.read 'EnsoSheet' . should_equal t2

            opened_out.close
            opened_backup.close

            out.delete_if_exists . should_succeed
            bak.delete_if_exists . should_succeed

        Test.specify 'should be able to write to an existing empty file' <|
            out = create_out
            [].write_bytes out

            out_bak = out.parent / (out.name+".bak")

            table.write out on_problems=Report_Error . should_succeed . should_equal out
            written = out.read
            written.sheet_count . should_equal 1
            written.sheet_names . should_equal ['EnsoSheet']
            written.read 'EnsoSheet' . should_equal table

            Test.with_clue "should have created a backup file: " <|
                out_bak.exists.should_be_true
                out_bak.size.should_equal 0

            written.close
            out.delete_if_exists . should_succeed
            out_bak.delete_if_exists . should_succeed

        Test.specify 'should fail to append to a sheet by name if missing columns' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']]]
            extra_another.write out (Excel (Worksheet "Another")) on_existing_file=Existing_File_Behavior.Append . should_fail_with Column_Name_Mismatch
            out.delete_if_exists . should_succeed

        Test.specify 'should fail to append to a sheet by name if extra columns' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']], ['DD', ['2022-01-20', '2022-01-21']], ['EE', ['2022-01-20', '2022-01-21']]]
            extra_another.write out (Excel (Worksheet "Another")) on_existing_file=Existing_File_Behavior.Append . should_fail_with Column_Name_Mismatch
            out.last_modified_time.should_equal lmd
            out.delete_if_exists . should_succeed

        Test.specify 'should fail to append to a sheet by name if no headers' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']], ['DD', ['2022-01-20', '2022-01-21']], ['EE', ['2022-01-20', '2022-01-21']]]
            extra_another.write out (Excel (Worksheet "NoHeaders")) on_existing_file=Existing_File_Behavior.Append . should_fail_with Illegal_Argument
            extra_another.write out (Excel (Worksheet "Another") headers=False) on_existing_file=Existing_File_Behavior.Append . should_fail_with Illegal_Argument
            out.last_modified_time.should_equal lmd
            out.delete_if_exists . should_succeed

        Test.specify 'should fail to append to a sheet by position if too few columns' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']]]
            extra_another.write out (Excel (Worksheet "Another")) on_existing_file=Existing_File_Behavior.Append match_columns=Match_Columns.By_Position . should_fail_with Column_Count_Mismatch
            out.last_modified_time.should_equal lmd
            out.delete_if_exists . should_succeed

        Test.specify 'should fail to append to a sheet by position if too many columns' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            extra_another = Table.new [['CC',[True, False]], ['BB',[4, 5]], ['AA', ['d', 'e']], ['DD', ['2022-01-20', '2022-01-21']], ['EE', ['2022-01-20', '2022-01-21']]]
            extra_another.write out (Excel (Worksheet "Another")) on_existing_file=Existing_File_Behavior.Append match_columns=Match_Columns.By_Position . should_fail_with Column_Count_Mismatch
            out.last_modified_time.should_equal lmd
            out.delete_if_exists . should_succeed

        Test.specify 'should fail to append to a range by name if not large enough' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            extra_another = Table.new [['AA', ['d', 'e']], ['BB',[4, 5]], ['CC',[True, False]], ['DD', ['2022-01-20', '2022-01-21']]]
            extra_another.write out (Excel (Cell_Range "Another!A1:D5")) on_existing_file=Existing_File_Behavior.Append . should_fail_with Range_Exceeded
            out.last_modified_time.should_equal lmd
            out.delete_if_exists . should_succeed

        Test.specify 'should fail to append to a range by name if it hits another table' <|
            out = create_out
            (enso_project.data / test_sheet_name) . copy_to out
            lmd = out.last_modified_time
            extra_another = Table.new [['AA', ['d', 'e']], ['BB',[4, 5]], ['CC',[True, False]], ['DD', ['2022-01-20', '2022-01-21']]]
            extra_another.write out (Excel (Cell_Range "Random!B3")) on_existing_file=Existing_File_Behavior.Append . should_fail_with Existing_Data
            out.last_modified_time.should_equal lmd
            out.delete_if_exists . should_succeed

        Test.specify "should fail if the target file is read-only" <|
            f = enso_project.data / "transient" / "permission."+suffix
            if f.exists then Util.set_writable f True
            f.delete_if_exists

            initial_data = Table.new [["Y", [10, 20, 30]]]
            initial_data.write f . should_succeed
            Util.set_writable f False . should_succeed

            t1 = Table.new [["X", [1, 2, 3]]]
            [Existing_File_Behavior.Backup, Existing_File_Behavior.Overwrite, Existing_File_Behavior.Append].each behavior-> Test.with_clue behavior.to_text+": " <|
                f.exists . should_be_true

                r1 = t1.write f (Excel (Worksheet "Another")) on_existing_file=behavior
                Test.with_clue "("+r1.catch.to_display_text+") " <|
                    r1.should_fail_with File_Error
                    r1.catch.should_be_a File_Error.Access_Denied

                read_table = Managed_Resource.bracket (f.read) (.close) workbook->
                    workbook.read "EnsoSheet"
                read_table.should_equal initial_data

            Util.set_writable f True
            f.delete

        Test.specify "should allow to write to a workbook that is open, and reflect that changes when the sheet is read again" <|
            out = create_out
            table.write out on_problems=Report_Error . should_succeed

            workbook = out.read (Excel headers=True)
            workbook.sheet_names.should_equal ["EnsoSheet"]
            workbook.to_text . should_equal "Excel_Workbook ("+out.name+")"

            # We can have the workbook open multiple times in parallel too.
            w2 = out.read (Excel headers=True)

            t1 = workbook.read "EnsoSheet"
            t1.should_equal table

            [Existing_File_Behavior.Backup, Existing_File_Behavior.Overwrite].each behavior-> Test.with_clue behavior.to_text+": " <|
                t2 = Table.new [["X", [behavior.to_text, "B", "C", behavior.to_text+"..."]]]
                t2.write out on_existing_file=behavior . should_succeed

                workbook.sheet_names.should_equal ["EnsoSheet"]

                # If we read the table again, it has the new values in it:
                t3 = workbook.read "EnsoSheet"
                t3.should_equal t2

                t4 = w2.read "EnsoSheet"
                t4.should_equal t2

            workbook.close
            w2.close
            out.delete_if_exists . should_succeed

        Test.specify "should fail if the parent directory does not exist" <|
            parent = enso_project.data / "transient" / "nonexistent"
            parent.exists.should_be_false

            f = parent / "foo."+suffix
            t1 = Table.new [["X", [1, 2, 3]]]
            r1 = t1.write f (Excel (Worksheet "Another"))
            Test.with_clue "("+r1.catch.to_display_text+") " <|
                r1.should_fail_with File_Error
                r1.catch.should_be_a File_Error.Not_Found

        Test.specify "should allow to write and read-back Unicode characters" <|
            encodings = enso_project.data / "transient" / "encodings."+suffix
            encodings.delete_if_exists . should_succeed

            t1 = Table.new [["A", ["A", "B", "😊", "D"]], ["B", [1, 2, 3, 4]]]
            t1.write encodings (Excel (Worksheet "Another")) . should_succeed
            t2 = encodings.read (Excel (Worksheet "Another"))
            t2.at "A" . to_vector . should_equal ["A", "B", "😊", "D"]
            encodings.delete

        Test.specify "should be able to overwrite a pre-existing empty file" <|
            empty = enso_project.data / "transient" / "empty."+suffix
            [Existing_File_Behavior.Backup, Existing_File_Behavior.Overwrite, Existing_File_Behavior.Append].each behavior-> Test.with_clue behavior.to_text+": " <|
                empty.delete_if_exists . should_succeed
                "".write empty
                empty.exists.should_be_true
                empty.size.should_equal 0

                t1 = Table.new [["A", [behavior.to_text, "B", "C", "D"]], ["B", [1, 2, 3, 4]]]
                t1.write empty on_existing_file=behavior . should_succeed
                empty.exists.should_be_true

                t2 = empty.read (Excel (Worksheet "EnsoSheet"))
                t2.should_equal t1

spec =
    Test.group 'Excel Range' <|
        check_range excel_range sheet_name tlbr_vector single_cell=False =
            excel_range.sheet_name . should_equal sheet_name
            excel_range.top_row . should_equal (tlbr_vector.at 0)
            excel_range.left_column . should_equal (tlbr_vector.at 1)
            excel_range.bottom_row . should_equal (tlbr_vector.at 2)
            excel_range.right_column . should_equal (tlbr_vector.at 3)
            excel_range.is_single_cell . should_equal single_cell

        Test.specify 'should be able to parse A1 format' <|
            check_range (Excel_Range.from_address "Test!EE4") 'Test' [4, 135, 4, 135] True
            check_range (Excel_Range.from_address "Test!EE4:EE4") 'Test' [4, 135, 4, 135]
            check_range (Excel_Range.from_address "Test!A1:D5") 'Test' [1, 1, 5, 4]
            check_range (Excel_Range.from_address "Test!1234") 'Test' [1234, Nothing, 1234, Nothing]
            check_range (Excel_Range.from_address "Test!1:4") 'Test' [1, Nothing, 4, Nothing]
            check_range (Excel_Range.from_address "Test!CB") 'Test' [Nothing, 80, Nothing, 80]
            check_range (Excel_Range.from_address "Test!DD:XAZ") 'Test' [Nothing, 108, Nothing, 16276]
            check_range (Excel_Range.from_address "'Hello World'!$EE4") 'Hello World' [4, 135, 4, 135] single_cell=True
            check_range (Excel_Range.from_address "Test!A1:$D$5") 'Test' [1, 1, 5, 4]
            check_range (Excel_Range.from_address "Test!1234") 'Test' [1234, Nothing, 1234, Nothing]
            check_range (Excel_Range.from_address "Test!$1:$4") 'Test' [1, Nothing, 4, Nothing]
            check_range (Excel_Range.from_address "Test!$CB") 'Test' [Nothing, 80, Nothing, 80]
            check_range (Excel_Range.from_address "Test!$DD:$XAZ") 'Test' [Nothing, 108, Nothing, 16276]

        Test.specify 'should be able to parse RC format' <|
            check_range (Excel_Range.from_address "Test!R1C1") 'Test' [1, 1, 1, 1] True
            check_range (Excel_Range.from_address "Test!R1C1:R5C3") 'Test' [1, 1, 5, 3]

        Test.specify 'should fail gracefully for invalid patterns' <|
            Excel_Range.from_address "Test!$$QA1" . should_fail_with Illegal_Argument
            Excel_Range.from_address "Test!BADADDRESS" . should_fail_with Illegal_Argument

        Test.specify 'should allow Range creation for a cell' <|
            check_range (Excel_Range.for_cell "Hello World" 123 14) 'Hello World' [14, 123, 14, 123] True
            check_range (Excel_Range.for_cell "Hello World" "DS" 14) 'Hello World' [14, 123, 14, 123] True
            Excel_Range.for_cell "Test" 123 14 . address . should_equal "Test!DS14"
            Excel_Range.for_cell "Hello World" 123 14 . address . should_equal "'Hello World'!DS14"
            Excel_Range.for_cell "Test" 20000 1 . should_fail_with Illegal_Argument
            Excel_Range.for_cell "Test" "ZZZ" 1 . should_fail_with Illegal_Argument
            Excel_Range.for_cell "Test" 0 1 . should_fail_with Illegal_Argument
            Excel_Range.for_cell "Test" 1 10000000 . should_fail_with Illegal_Argument
            Excel_Range.for_cell "Test" 1 0 . should_fail_with Illegal_Argument

        Test.specify 'should allow Range creation for a range' <|
            check_range (Excel_Range.for_range "Hello World" 55 120 123 14) 'Hello World' [14, 55, 120, 123]
            check_range (Excel_Range.for_range "Hello World" "BC" 120 "DS" 14) 'Hello World' [14, 55, 120, 123]
            Excel_Range.for_range "Test" 55 120 123 14 . address . should_equal "Test!BC14:DS120"
            Excel_Range.for_range "Hello World" 55 120 123 14 . address . should_equal "'Hello World'!BC14:DS120"
            Excel_Range.for_range "Test" 20000 1 123 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" "ZZZ" 1 123 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 0 1 123 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 5 1 20000 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 5 1 0 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 5 0 123 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 5 10000000 123 14 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 5 1 123 0 . should_fail_with Illegal_Argument
            Excel_Range.for_range "Test" 5 1 123 10000000 . should_fail_with Illegal_Argument

        Test.specify 'should allow Range creation for a column' <|
            check_range (Excel_Range.for_columns "Hello World" 123) 'Hello World' [Nothing, 123, Nothing, 123]
            check_range (Excel_Range.for_columns "Hello World" "DS") 'Hello World' [Nothing, 123, Nothing, 123]
            Excel_Range.for_columns "Test" 123 . address . should_equal "Test!DS"
            Excel_Range.for_columns "Hello World" 123 . address . should_equal "'Hello World'!DS"
            Excel_Range.for_columns "Test" 20000 . should_fail_with Illegal_Argument
            Excel_Range.for_columns "Test" "ZZZ" . should_fail_with Illegal_Argument
            Excel_Range.for_columns "Test" 0 . should_fail_with Illegal_Argument

        Test.specify 'should allow Range creation for columns' <|
            check_range (Excel_Range.for_columns "Hello World" "BC" 123) 'Hello World' [Nothing, 55, Nothing, 123]
            check_range (Excel_Range.for_columns "Hello World" 55 "DS") 'Hello World' [Nothing, 55, Nothing, 123]
            Excel_Range.for_columns "Test" 55 123 . address . should_equal "Test!BC:DS"
            Excel_Range.for_columns "Hello World" "BC" "DS" . address . should_equal "'Hello World'!BC:DS"
            Excel_Range.for_columns "Test" 55 20000 . should_fail_with Illegal_Argument
            Excel_Range.for_columns "Test" 55 "ZZZ" . should_fail_with Illegal_Argument
            Excel_Range.for_columns "Test" 55 0 . should_fail_with Illegal_Argument

        Test.specify 'should allow Range creation for a row' <|
            check_range (Excel_Range.for_rows "Hello World" 123) 'Hello World' [123, Nothing, 123, Nothing]
            Excel_Range.for_rows "Test" 123 . address . should_equal "Test!123"
            Excel_Range.for_rows "Hello World" 123 . address . should_equal "'Hello World'!123"
            Excel_Range.for_rows "Test" 20000000 . should_fail_with Illegal_Argument
            Excel_Range.for_rows "Test" 0 . should_fail_with Illegal_Argument

        Test.specify 'should allow Range creation for rows' <|
            check_range (Excel_Range.for_rows "Hello World" 55 123) 'Hello World' [55, Nothing, 123, Nothing]
            Excel_Range.for_rows "Test" 55 123 . address . should_equal "Test!55:123"
            Excel_Range.for_rows "Hello World" 55 123 . address . should_equal "'Hello World'!55:123"
            Excel_Range.for_rows "Test" 55 20000000 . should_fail_with Illegal_Argument
            Excel_Range.for_rows "Test" 55 0 . should_fail_with Illegal_Argument

    xlsx_sheet = enso_project.data / "TestSheet.xlsx"
    xlsx_path = xlsx_sheet.path

    xls_sheet = enso_project.data / "TestSheetOld.xls"
    xls_path = xls_sheet.path

    sheet_names = ["Sheet1", "Another", "NoHeaders", "Random"]
    range_names = ["myData"]

    col_a = ["Test", "Here", "Is", "Data"]
    col_b = [1, 2, 3, 4]
    col_c = [Date.new 2022 06 12, Date.new 2022 10 20, Date.new 2022 07 30, Date.new 2022 10 15]
    col_d = [Time_Of_Day.new 12 34 56, Time_Of_Day.new 1 23 45, Time_Of_Day.new 2 46, Time_Of_Day.new 9]
    col_e = [Date_Time.new 2022 06 12 12 34 56, Date_Time.new 2022 10 20 1 23 45, Date_Time.new 2022 07 30 2 46, Date_Time.new 2022 10 15 9]

    check_column col expected =
        start = col.length - expected.length
        0.up_to start . map i->(col.at i . should_equal Nothing)
        start.up_to col.length . map i->(col.at i . should_equal (expected.at (i - start)))

    check_table table count=5 =
        table.column_count . should_equal count
        if count > 0 then check_column (table.at "A") col_a
        if count > 1 then check_column (table.at "B") col_b
        if count > 2 then check_column (table.at "C") col_c
        if count > 3 then check_column (table.at "D") col_d
        if count > 4 then check_column (table.at "E") col_e

    check_workbook workbook sheets=sheet_names.length ranges=range_names.length =
        workbook.is_a Excel_Workbook . should_be_true
        workbook.sheet_count . should_equal sheets
        workbook.named_ranges_count . should_equal ranges

    Test.group "Read XLSX / XLS Files" <|
        Test.specify "should let you read the workbook with Auto_Detect" <|
            check_workbook <| xlsx_sheet.read
            check_workbook <| Data.read xlsx_sheet
            check_workbook <| Data.read xlsx_path

            check_workbook <| xls_sheet.read
            check_workbook <| Data.read xls_sheet
            check_workbook <| Data.read xls_path

        Test.specify "should let you read the workbook with Excel" <|
            check_workbook <| xlsx_sheet.read Excel
            check_workbook <| Data.read xlsx_sheet Excel
            check_workbook <| Data.read xlsx_path Excel

            check_workbook <| xls_sheet.read Excel
            check_workbook <| Data.read xls_sheet Excel
            check_workbook <| Data.read xls_path Excel

        Test.specify "workbook should look like a database connection" <|
            workbook = xlsx_sheet.read

            workbook.database . should_equal xlsx_sheet.normalize.path
            workbook.schema . should_equal Nothing

            workbook.table_types . should_equal ['Worksheet', 'Named Range']

            workbook.tables.row_count . should_equal (sheet_names.length + range_names.length)
            workbook.tables.at "Name" . to_vector . should_contain_the_same_elements_as (sheet_names + range_names)

            workbook.tables types=["Worksheet"] . row_count . should_equal sheet_names.length
            workbook.tables types=["Named Range"] . row_count . should_equal range_names.length
            workbook.tables types=["XXX"] . row_count . should_equal 0

            workbook.tables "%not%" . row_count . should_equal 1
            workbook.tables "%not%" . at 'Name' . to_vector . should_equal ["Another"]

        Test.specify "should let you read the sheet names" <|
            xlsx_sheet.read (Excel Sheet_Names) . should_equal sheet_names
            xls_sheet.read (Excel Sheet_Names) . should_equal sheet_names
            xlsx_sheet.read . sheet_names . should_equal sheet_names

        Test.specify "should let you read the range names" <|
            xlsx_sheet.read (Excel Range_Names) . should_equal range_names
            xls_sheet.read (Excel Range_Names) . should_equal range_names
            xlsx_sheet.read . named_ranges . should_equal range_names

        Test.specify "should let you read by sheet index" <|
            table = xlsx_sheet.read (Excel (Worksheet 1))
            check_table table

            table_2 = xlsx_sheet.read (Excel (Worksheet 1 (table.row_count - col_a.length)))
            table_2.row_count . should_equal col_a.length
            check_table table_2

        Test.specify "should let you read by sheet name" <|
            table = xlsx_sheet.read (Excel (Worksheet "Sheet1"))
            check_table table

            table_2 = xlsx_sheet.read (Excel (Worksheet "Sheet1" (table.row_count - col_a.length)))
            table_2.row_count . should_equal col_a.length
            check_table table_2

            table_3 = xlsx_sheet.read . read "Sheet1"
            check_table table_3

        Test.specify "should let you read XLS by sheet index" <|
            table = xls_sheet.read (Excel (Worksheet 1))
            check_table table

            table_2 = xls_sheet.read (Excel (Worksheet 1 (table.row_count - col_a.length)))
            table_2.row_count . should_equal col_a.length
            check_table table_2

        Test.specify "should let you read XLS by sheet name" <|
            table = xls_sheet.read (Excel (Worksheet "Sheet1"))
            check_table table

            table_2 = xls_sheet.read . read "Sheet1"
            check_table table_2

        Test.specify "should let you read by range" <|
            table = xlsx_sheet.read (Excel (Cell_Range "Sheet1!A:C"))
            check_table table 3

            table_2 = xlsx_sheet.read (Excel (Cell_Range "Sheet1!A:C" (table.row_count - col_a.length)))
            table_2.row_count . should_equal col_a.length
            check_table table_2 3

            check_table <| xlsx_sheet.read (Excel (Cell_Range "Sheet1!10:13"))
            check_table count=3 <| xlsx_sheet.read (Excel (Cell_Range "Sheet1!A10:C13"))

            check_table <| xlsx_sheet.read . read "Sheet1!10:13"
            check_table count=3 <| xlsx_sheet.read . read "Sheet1!A10:C13"

        Test.specify "should let you read by range name" <|
            table = xlsx_sheet.read (Excel (Cell_Range "myData"))
            table.row_count . should_equal col_a.length
            check_table table 3

            table_2 = xlsx_sheet.read . read "myData"
            table_2.row_count . should_equal col_a.length
            check_table table_2 3

        Test.specify "should let you restrict number of rows read and skip rows" <|
            table = xlsx_sheet.read (Excel (Worksheet "Sheet1"))
            check_table table

            table_2 = xlsx_sheet.read (Excel (Worksheet "Sheet1" (table.row_count - col_a.length)))
            table_2.row_count . should_equal col_a.length
            check_table table_2

            table_3 = xlsx_sheet.read (Excel (Worksheet "Sheet1" (table.row_count - col_a.length) 2))
            table_3.row_count . should_equal 2

            table_4 = xlsx_sheet.read (Excel (Worksheet "Sheet1" row_limit=6))
            table_4.row_count . should_equal 6

    Test.group "Problems" <|
        Test.specify "should handle non-existing file gracefully" <|
            bad_file = enso_project.data / "DoesNotExists.xlsx"
            result = bad_file.read (Excel (Cell_Range "Sheet1!A:C"))
            result.should_fail_with File_Error
            result.catch.should_be_a File_Error.Not_Found

        Test.specify "should handle wrong xls_format gracefully" <|
            xlsx_sheet_copy = enso_project.data / "transient" / "TestSheetCopy.xlsx"
            xlsx_sheet.copy_to xlsx_sheet_copy

            # At first, it fails with File_Error
            r1 = xlsx_sheet.read (Excel (Cell_Range "Sheet1!A:C") xls_format=True)
            r1.should_fail_with File_Error
            r1.catch.should_be_a File_Error.Corrupted_Format

            # If we now open it correctly
            r1_2 = xlsx_sheet.read
            r1_2.should_succeed

            # And then wrong again
            r1_3 = xlsx_sheet.read (Excel (Cell_Range "Sheet1!A:C") xls_format=True)
            # It should still fail the same:
            r1_3.should_fail_with File_Error
            r1_3.catch.should_be_a File_Error.Corrupted_Format

            r2 = xls_sheet.read (Excel (Cell_Range "Sheet1!A:C") xls_format=False)
            r2.should_fail_with File_Error
            r2.catch.should_be_a File_Error.Corrupted_Format

        Test.specify "should handle malformed XLS files gracefully" <|
            bad_file = enso_project.data / "transient" / "malformed.xls"
            "not really an XLS file contents...".write bad_file on_existing_file=Existing_File_Behavior.Overwrite

            r1 = bad_file.read
            r1.should_fail_with File_Error
            r1.catch.should_be_a File_Error.Corrupted_Format
            r1.catch.to_display_text.should_contain "is corrupted"

            r1a = bad_file.read Excel
            r1a.should_fail_with File_Error
            r1a.catch.should_be_a File_Error.Corrupted_Format

            r1b = bad_file.read (Excel Sheet_Names)
            r1b.should_fail_with File_Error
            r1b.catch.should_be_a File_Error.Corrupted_Format

            r2 = bad_file.read (Excel (Cell_Range "Sheet1!A:C"))
            r2.should_fail_with File_Error
            r2.catch.should_be_a File_Error.Corrupted_Format
            r2.catch.to_display_text.should_contain "is corrupted"

            bad_file.delete

        Test.specify "will fail if an operation is performed on a closed workbook" <|
            workbook = xlsx_sheet.read
            workbook.sheet_count . should_equal 4

            workbook.close . should_equal Nothing

            workbook.sheet_count . should_fail_with Illegal_State
            workbook.close . should_equal Nothing
            workbook.read "Sheet1" . should_fail_with Illegal_State

        ci_pending = if Environment.get "CI" != Nothing then "This test takes a lot of time so it is disabled on CI."
        Test.specify "should be able to write and read a big XLSX file (>110MB)" pending=ci_pending <|
            n = 10^6
            IO.println "Generating big XLSX file "+Time_Of_Day.now.to_text
            rng = RandomHelpers.new 123
            v = Vector.new n _->
                rng.makeRandomString 190
            table = Table.new [["X", v]]
            big_file = enso_project.data / "transient" / "big.xlsx"
            big_file.delete_if_exists

            table.write big_file on_existing_file=Existing_File_Behavior.Overwrite on_problems=Report_Error . should_succeed
            IO.println "Done                     "+Time_Of_Day.now.to_text

            # Verify that the file is as big as we expected.
            size = big_file.size / (1024*1024)
            Test.with_clue "size="+size.to_text+"MB " <|
                (size > 110).should_be_true

            workbook = big_file.read
            sheets = workbook.sheet_names
            sheets.length . should_equal 1
            read_table = workbook.read (sheets.at 0)
            read_table.row_count . should_equal n+1
            read_table.column_names.length . should_equal 1
            read_table.at 0 . at 0 . should_equal "X"
            read_table.at 0 . at 1 . should_equal (v.at 0)

            workbook.close
            big_file.delete_if_exists . should_succeed

        Test.specify "should be able to write and read a big XLS file (>110MB)" pending=ci_pending <|
            IO.println "Generating big XLS file "+Time_Of_Day.now.to_text
            rng = RandomHelpers.new 123
            # Here we instead create a 2D table, because XLS has a limit of 65536 rows and 16k columns.
            rows = 65000
            cols = 20
            table = Table.new <| Vector.new cols i->
                v = Vector.new rows _-> rng.makeRandomString 100
                ["col" + i.to_text, v]
            big_file = enso_project.data / "transient" / "big.xls"
            big_file.delete_if_exists

            table.write big_file on_existing_file=Existing_File_Behavior.Overwrite on_problems=Report_Error . should_succeed
            IO.println "Done                    "+Time_Of_Day.now.to_text

            # Verify that the file is as big as we expected.
            size = big_file.size / (1024*1024)
            Test.with_clue "size="+size.to_text+"MB " <|
                (size > 110).should_be_true

            workbook = big_file.read
            sheets = workbook.sheet_names
            sheets.length . should_equal 1
            read_table = workbook.read (sheets.at 0)
            read_table.row_count . should_equal rows+1
            read_table.column_names.length . should_equal cols

            workbook.close
            big_file.delete_if_exists . should_succeed

    spec_fmt 'XLSX reading' Examples.xlsx .read

    spec_fmt 'XLS reading' Examples.xls .read

    Test.group "Reading single cells correctly" <|
        file = enso_project.data / "RangeTests.xlsx"

        check_table table col_names data =
            table.column_count . should_equal col_names.length
            table.columns.map .name . should_equal col_names
            data.each_with_index idx->values->
                table.at (col_names.at idx) . to_vector . should_equal values

        Test.specify "Simple table" <|
            check_table (file.read (Excel (Cell_Range "Sheet1!A1"))) ["AA", "BB"] [[1,2,3,4,5,6], ["A","B","C","D","E","F"]]
            check_table (file.read (Excel (Cell_Range "Sheet1!A2"))) ["A", "B"] [[1,2,3,4,5,6], ["A","B","C","D","E","F"]]
            check_table (file.read (Excel (Cell_Range "Sheet1!A1:A1"))) ["A"] [["AA"]]
            check_table (file.read (Excel (Cell_Range "Sheet1!B1"))) ["B"] [["BB", "A","B","C","D","E","F"]]
            check_table (file.read (Excel (Cell_Range "Sheet1!B1") headers=True)) ["BB"] [["A","B","C","D","E","F"]]
            check_table (file.read (Excel (Cell_Range "Sheet1!B2"))) ["B"] [["A","B","C","D","E","F"]]

        Test.specify "Patchy table" <|
            check_table (file.read (Excel (Cell_Range "Sheet1!D1"))) ["A", "B", "F"] [[1,2,4], [4,4,Nothing], [6,Nothing,6]]
            check_table (file.read (Excel (Cell_Range "Sheet1!D2"))) ["D", "E", "F"] [[1,2,4], [4,4,Nothing], [6,Nothing,6]]
            check_table (file.read (Excel (Cell_Range "Sheet1!E"))) ["B"] [[4,4,Nothing,Nothing,Nothing,Nothing]]
            check_table (file.read (Excel (Cell_Range "Sheet1!E1"))) ["B", "F"] [[4,4,Nothing], [6,Nothing,6]]
            check_table (file.read (Excel (Cell_Range "Sheet1!E2"))) ["E", "F"] [[4,4,Nothing], [6,Nothing,6]]

        Test.specify "Single cell" <|
            check_table (file.read (Excel (Cell_Range "Sheet1!H1"))) ["H"] [["Single Cell"]]
            check_table (file.read (Excel (Cell_Range "Sheet1!H2"))) ["H"] [[]]

        Test.specify "Single line" <|
            check_table (file.read (Excel (Cell_Range "Sheet1!J1"))) ["J", "K", "L"] [["Just"],["Some"],["Headers"]]

        Test.specify "Growing table" <|
            check_table (file.read (Excel (Cell_Range "Sheet1!N1"))) ["A", "Full", "Table", "Q"] [["Hello","World",Nothing,"Extend"],[1,Nothing,"Gap",3],[2,2,"Here",5],[Nothing,Nothing,"To","Hello"]]
            check_table (file.read (Excel (Cell_Range "Sheet1!O1"))) ["Full", "Table", "Q"] [[1,Nothing,"Gap",3],[2,2,"Here",5],[Nothing,Nothing,"To","Hello"]]
            check_table (file.read (Excel (Cell_Range "Sheet1!O2"))) ["O", "P", "Q"] [[1,Nothing,"Gap",3],[2,2,"Here",5],[Nothing,Nothing,"To","Hello"]]

        Test.specify "Should handle blank headers without warnings" <|
            check_table (file.read (Excel (Cell_Range "Sheet1!D1"))) ["A", "B", "F"] [[1,2,4], [4,4,Nothing], [6,Nothing,6]]

        Test.specify "Should handle duplicate headers with warnings" <|
            action = file.read (Excel (Cell_Range "Sheet1!S1")) on_problems=_
            tester = check_table _ ["DD", "DD 1"] [[1,3], [2,4]]
            problems = [Duplicate_Output_Column_Names.Error ["DD"]]
            Problems.test_problem_handling action problems tester

    # Cleanup any leftovers from previous runs
    enso_project.data/"transient" . list "out*" . each .delete
    spec_write "xlsx" 'TestSheet.xlsx'
    spec_write "xls" 'TestSheetOld.xls'

main = Test_Suite.run_main spec
