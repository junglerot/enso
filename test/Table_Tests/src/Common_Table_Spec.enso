from Standard.Base import all
from Standard.Base.Data.Index_Sub_Range import While, Sample, Every
import Standard.Base.Data.Index_Sub_Range
from Standard.Base.Error.Problem_Behavior import Report_Error

from Standard.Table import Column_Name_Mapping, Sort_Column, Sort_Column_Selector
from Standard.Table.Data.Value_Type import Value_Type
from Standard.Table.Errors import all
from Standard.Table.Data.Column_Selector import all
from Standard.Table.Data.Position import all
from Standard.Table.Data.Filter_Condition import Filter_Condition

from Standard.Database.Errors import SQL_Error_Data

import Standard.Test
import Standard.Test.Problems

from project.Util import all

# TODO Dubious constructor export
from project.Common_Table_Spec.Test_Selection import all
from project.Common_Table_Spec.Test_Selection export all

type Test_Selection
    Test_Selection_Data supports_case_sensitive_columns=True order_by=True natural_ordering=False case_insensitive_ordering=True order_by_unicode_normalization_by_default=False case_insensitive_ascii_only=False take_drop=True allows_mixed_type_comparisons=True

## A common test suite for shared operations on the Table API.

   It is meant to be able to be re-used by tests for the in-memory and various
   database backends.

   Arguments:
   - prefix: A prefix to attach to the names of test groups, for easier
     identification.
   - table_builder: A function which takes a list of column descriptions and
     builds a Table using the backend that is meant to be tested. Each column
     description is a triple of column name, column type and a vector containing
     column elements.
   - test_selection: A selection of which suites should be run. Can be used to
     skip checks for backends which do not support particular features.
   - pending: An optional mark to disable all test groups. Can be used to
     indicate that some tests are disabled due to missing test setup.

   TODO [RW] the Any in return type of the builder should ideally be replaced with the Table interface, once that is supported.
spec prefix table_builder test_selection pending=Nothing =
    table =
        col1 = ["foo", [1,2,3]]
        col2 = ["bar", [4,5,6]]
        col3 = ["Baz", [7,8,9]]
        col4 = ["foo_1", [10,11,12]]
        col5 = ["foo_2", [13,14,15]]
        col6 = ["ab.+123", [16,17,18]]
        col7 = ["abcd123", [19,20,21]]
        table_builder [col1, col2, col3, col4, col5, col6, col7]

    expect_column_names names table =
        table.columns . map .name . should_equal names frames_to_skip=2

    Test.group prefix+"Table.at" pending=pending <|
        Test.specify "should allow selecting columns by name" <|
            column_1 = table.at "bar"
            column_1.name . should_equal "bar"
            column_1.to_vector . should_equal [4, 5, 6]

            table.at "nonexistent column name" . should_fail_with No_Such_Column_Error_Data
        Test.specify "should allow selecting columns by index" <|
            column_1 = table.at
            column_1.name . should_equal "foo"
            column_1.to_vector . should_equal [1, 2, 3]

            column_2 = table.at 2
            column_2.name . should_equal "Baz"
            column_2.to_vector . should_equal [7, 8, 9]

            column_3 = table.at -1
            column_3.name . should_equal "abcd123"
            column_3.to_vector . should_equal [19, 20, 21]

            table.at 100 . should_fail_with Index_Out_Of_Bounds_Error_Data

    Test.group prefix+"Table.column_count" pending=pending <|
        Test.specify "should allow getting the column count" <|
            table.column_count . should_equal 7

    Test.group prefix+"Table.select_columns" pending=pending <|
        Test.specify "should work as shown in the doc examples" <|
            expect_column_names ["foo", "bar"] <| table.select_columns (By_Name ["bar", "foo"])
            expect_column_names ["foo", "bar"] <| table.select_columns (["bar", "foo"])
            expect_column_names ["bar", "Baz", "foo_1", "foo_2"] <| table.select_columns (By_Name ["foo.+", "b.*"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Insensitive))
            expect_column_names ["abcd123", "foo", "bar"] <| table.select_columns (By_Index [-1, 0, 1]) reorder=True

            column1 = table.at "foo_1"
            column2 = table.at "Baz"
            expect_column_names ["Baz", "foo_1"] <| table.select_columns (By_Column [column1, column2])

        Test.specify "should allow to reorder columns if asked to" <|
            table_2 = table.select_columns (By_Name ["bar", "foo"]) reorder=True
            expect_column_names ["bar", "foo"] table_2
            table_2 . at "bar" . to_vector . should_equal [4,5,6]
            table_2 . at "foo" . to_vector . should_equal [1,2,3]

        Test.specify "should correctly handle regex matching" <|
            expect_column_names ["foo"] <| table.select_columns (By_Name ["foo"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))
            expect_column_names ["ab.+123", "abcd123"] <| table.select_columns (By_Name ["a.*"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))
            expect_column_names ["ab.+123", "abcd123"] <| table.select_columns (By_Name ["ab.+123"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))
            expect_column_names ["ab.+123"] <| table.select_columns (By_Name ["ab.+123"])
            expect_column_names ["abcd123"] <| table.select_columns (By_Name ["abcd123"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))

        Test.specify "should allow negative indices" <|
            expect_column_names ["foo", "bar", "foo_2"] <| table.select_columns (By_Index [-3, 0, 1])

        if test_selection.supports_case_sensitive_columns then
            Test.specify "should correctly handle exact matches matching multiple names due to case insensitivity" <|
                table =
                    col1 = ["foo", [1,2,3]]
                    col2 = ["bar", [4,5,6]]
                    col3 = ["Bar", [7,8,9]]
                    table_builder [col1, col2, col3]
                expect_column_names ["bar", "Bar"] <| table.select_columns (By_Name ["bar"] Text_Matcher.Case_Insensitive)

        Test.specify "should correctly handle regexes matching multiple names" <|
            expect_column_names ["foo", "bar", "foo_1", "foo_2"] <| table.select_columns (By_Name ["b.*", "f.+"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))
            expect_column_names ["bar", "foo", "foo_1", "foo_2"] <| table.select_columns (By_Name ["b.*", "f.+"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive)) reorder=True

        Test.specify "should correctly handle problems: out of bounds indices" <|
            selector = By_Index [1, 0, 100, -200, 300]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo", "bar"]
            problems = [Column_Indexes_Out_Of_Range_Data [100, -200, 300]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate indices" <|
            selector = By_Index [0, 0, 0]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo"]
            problems = [Duplicate_Column_Selectors_Data [0, 0]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: aliased indices" <|
            selector = By_Index [0, -7, -6, 1]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo", "bar"]
            problems = [Input_Indices_Already_Matched_Data [-7, 1]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate names" <|
            selector = By_Name ["foo", "foo"]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo"]
            problems = [Duplicate_Column_Selectors_Data ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate matches due to case insensitivity" pending="TODO needs fixing" <|
            selector = By_Name ["FOO", "foo"] Text_Matcher.Case_Insensitive
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo"]
            problems = [Duplicate_Column_Selectors_Data ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate matches due to case insensitivity" pending="TODO needs fixing" <|
            selector = By_Name.new ["FOO", "foo"] Text_Matcher.Case_Insensitive
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo"]
            problems = [Duplicate_Column_Selectors_Data ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched names" <|
            weird_name = '.*?-!@#!"'
            selector = By_Name ["foo", "hmm", weird_name]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo"]
            problems = [Missing_Input_Columns_Data ["hmm", weird_name]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate columns" <|
            foo = table.at "foo"
            selector = By_Column [foo, foo]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo"]
            problems = [Duplicate_Column_Selectors_Data ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched columns" <|
            table_2 = table_builder [["foo", [0,0,0]], ["weird_column", [0,0,0]]]
            foo = table_2.at "foo"
            weird_column = table_2.at "weird_column"
            bar = table.at "bar"

            selector = By_Column [bar, weird_column, foo]
            action = table.select_columns selector reorder=True on_problems=_
            tester = expect_column_names ["bar", "foo"]
            problems = [Missing_Input_Columns_Data ["weird_column"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: no columns in the output" <|
            selector = By_Name []
            action = table.select_columns selector on_problems=_
            tester = expect_column_names []
            problems = [No_Output_Columns]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle multiple problems" <|
            selector = By_Name ["hmmm"]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names []
            problems = [Missing_Input_Columns_Data ["hmmm"], No_Output_Columns]
            Problems.test_problem_handling action problems tester

            action_2 = table.select_columns (By_Index [0, -7, 0, 100]) on_problems=_
            problems_2 = [Column_Indexes_Out_Of_Range_Data [100], Duplicate_Column_Selectors_Data [0], Input_Indices_Already_Matched_Data [-7]]
            tester_2 = expect_column_names ["foo"]
            Problems.test_problem_handling action_2 problems_2 tester_2

    Test.group prefix+"Table.remove_columns" pending=pending <|
        Test.specify "should work as shown in the doc examples" <|
            expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123"] <| table.remove_columns (By_Name ["bar", "foo"])
            expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123"] <| table.remove_columns ["bar", "foo"]
            expect_column_names ["foo", "ab.+123", "abcd123"] <| table.remove_columns (By_Name ["foo.+", "b.*"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Insensitive))
            expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123"] <| table.remove_columns (By_Index [-1, 0, 1])

            column1 = table.at "foo_1"
            column2 = table.at "Baz"
            expect_column_names ["foo", "bar", "foo_2", "ab.+123", "abcd123"] <| table.remove_columns (By_Column [column1, column2])

        Test.specify "should correctly handle regex matching" <|
            last_ones = table.columns.tail.map .name
            expect_column_names last_ones <| table.remove_columns (By_Name ["foo"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))
            first_ones = ["foo", "bar", "Baz", "foo_1", "foo_2"]
            expect_column_names first_ones <| table.remove_columns (By_Name ["a.*"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))
            expect_column_names first_ones <| table.remove_columns (By_Name ["ab.+123"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))
            expect_column_names first_ones+["abcd123"] <| table.remove_columns (By_Name ["ab.+123"])
            expect_column_names first_ones+["ab.+123"] <| table.remove_columns (By_Name ["abcd123"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))

        Test.specify "should allow negative indices" <|
            expect_column_names ["Baz", "foo_1", "ab.+123"] <| table.remove_columns (By_Index [-1, -3, 0, 1])

        if test_selection.supports_case_sensitive_columns then
            Test.specify "should correctly handle exact matches matching multiple names due to case insensitivity" <|
                table =
                    col1 = ["foo", [1,2,3]]
                    col2 = ["bar", [4,5,6]]
                    col3 = ["Bar", [7,8,9]]
                    table_builder [col1, col2, col3]
                expect_column_names ["foo"] <| table.remove_columns (By_Name ["bar"] Text_Matcher.Case_Insensitive)

        Test.specify "should correctly handle regexes matching multiple names" <|
            expect_column_names ["Baz", "ab.+123", "abcd123"] <| table.remove_columns (By_Name ["b.*", "f.+"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))

        Test.specify "should correctly handle problems: out of bounds indices" <|
            selector = By_Index [1, 0, 100, -200, 300]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Column_Indexes_Out_Of_Range_Data [100, -200, 300]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate indices" <|
            selector = By_Index [0, 0, 0]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Duplicate_Column_Selectors_Data [0, 0]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: aliased indices" <|
            selector = By_Index [0, -7, -6, 1]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Input_Indices_Already_Matched_Data [-7, 1]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate names" <|
            selector = By_Name ["foo", "foo"]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Duplicate_Column_Selectors_Data ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate matches due to case insensitivity" pending="TODO needs fixing" <|
            selector = By_Name ["FOO", "foo"] Text_Matcher.Case_Insensitive
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Duplicate_Column_Selectors_Data ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate matches due to case insensitivity" pending="TODO needs fixing" <|
            selector = By_Name.new ["FOO", "foo"] Text_Matcher.Case_Insensitive
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Duplicate_Column_Selectors_Data ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched names" <|
            weird_name = '.*?-!@#!"'
            selector = By_Name ["foo", "hmm", weird_name]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Missing_Input_Columns_Data ["hmm", weird_name]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate columns" <|
            foo = table.at "foo"
            selector = By_Column [foo, foo]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Duplicate_Column_Selectors_Data ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched columns" <|
            table_2 = table_builder [["foo", [0,0,0]], ["weird_column", [0,0,0]]]
            foo = table_2.at "foo"
            weird_column = table_2.at "weird_column"
            bar = table.at "bar"

            selector = By_Column [bar, weird_column, foo]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Missing_Input_Columns_Data ["weird_column"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: no columns in the output" <|
            selector = By_Name [".*"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive)
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names []
            problems = [No_Output_Columns]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle multiple problems" <|
            selector = By_Name [".*", "hmmm"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive)
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names []
            problems = [Missing_Input_Columns_Data ["hmmm"], No_Output_Columns]
            Problems.test_problem_handling action problems tester

            action_2 = table.remove_columns (By_Index [0, -7, 0, 100]) on_problems=_
            problems_2 = [Column_Indexes_Out_Of_Range_Data [100], Duplicate_Column_Selectors_Data [0], Input_Indices_Already_Matched_Data [-7]]
            tester_2 = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            Problems.test_problem_handling action_2 problems_2 tester_2

    Test.group prefix+"Table.reorder_columns" pending=pending <|
        Test.specify "should work as shown in the doc examples" <|
            expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"] <| table.reorder_columns (By_Name ["foo"]) position=After_Other_Columns
            expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo", "bar"] <| table.reorder_columns ["foo", "bar"] position=After_Other_Columns
            expect_column_names ["foo_1", "foo_2", "bar", "Baz", "foo", "ab.+123", "abcd123"] <| table.reorder_columns (By_Name ["foo.+", "b.*"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Insensitive))
            expect_column_names ["bar", "foo", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"] <| table.reorder_columns (By_Index [1, 0]) position=Before_Other_Columns
            expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"] <| table.reorder_columns (By_Index [0]) position=After_Other_Columns

            column1 = table.at "foo_1"
            column2 = table.at "Baz"
            expect_column_names ["foo_1", "Baz", "foo", "bar", "foo_2", "ab.+123", "abcd123"] <| table.reorder_columns (By_Column [column1, column2])

        Test.specify "should correctly handle regex matching" <|
            expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"] <| table.reorder_columns (By_Name ["foo"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive)) position=After_Other_Columns
            rest = ["foo", "bar", "Baz", "foo_1", "foo_2"]
            expect_column_names ["ab.+123", "abcd123"]+rest <| table.reorder_columns (By_Name ["a.*"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))
            expect_column_names ["ab.+123", "abcd123"]+rest <| table.reorder_columns (By_Name ["ab.+123"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))
            expect_column_names ["ab.+123"]+rest+["abcd123"] <| table.reorder_columns (By_Name ["ab.+123"])
            expect_column_names ["abcd123"]+rest+["ab.+123"] <| table.reorder_columns (By_Name ["abcd123"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))

        Test.specify "should allow negative indices" <|
            expect_column_names ["abcd123", "foo_2", "foo", "bar", "Baz", "foo_1", "ab.+123"] <| table.reorder_columns (By_Index [-1, -3, 0, 1])

        if test_selection.supports_case_sensitive_columns then
            Test.specify "should correctly handle exact matches matching multiple names due to case insensitivity" <|
                table =
                    col1 = ["foo", [1,2,3]]
                    col2 = ["bar", [4,5,6]]
                    col3 = ["Bar", [7,8,9]]
                    table_builder [col1, col2, col3]
                expect_column_names ["bar", "Bar", "foo"] <| table.reorder_columns (By_Name ["bar"] Text_Matcher.Case_Insensitive)

        Test.specify "should correctly handle regexes matching multiple names" <|
            expect_column_names ["bar", "foo", "foo_1", "foo_2", "Baz", "ab.+123", "abcd123"] <| table.reorder_columns (By_Name ["b.*", "f.+"] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))

        Test.specify "should correctly handle problems: out of bounds indices" <|
            selector = By_Index [1, 0, 100, -200, 300]
            action = table.reorder_columns selector on_problems=_
            tester = expect_column_names ["bar", "foo", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Column_Indexes_Out_Of_Range_Data [100, -200, 300]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate indices" <|
            selector = By_Index [0, 0, 0]
            action = table.reorder_columns selector position=After_Other_Columns on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"]
            problems = [Duplicate_Column_Selectors_Data [0, 0]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: aliased indices" <|
            selector = By_Index [0, -7, -6, 1]
            action = table.reorder_columns selector position=After_Other_Columns on_problems=_
            tester = expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo", "bar"]
            problems = [Input_Indices_Already_Matched_Data [-7, 1]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate names" <|
            selector = By_Name ["foo", "foo"]
            action = table.reorder_columns selector position=After_Other_Columns on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"]
            problems = [Duplicate_Column_Selectors_Data ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched names" <|
            weird_name = '.*?-!@#!"'
            selector = By_Name ["foo", "hmm", weird_name]
            action = table.reorder_columns selector position=After_Other_Columns on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"]
            problems = [Missing_Input_Columns_Data ["hmm", weird_name]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate columns" <|
            foo = table.at "foo"
            selector = By_Column [foo, foo]
            action = table.reorder_columns selector position=After_Other_Columns on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"]
            problems = [Duplicate_Column_Selectors_Data ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched columns" <|
            table_2 = table_builder [["foo", [0,0,0]], ["weird_column", [0,0,0]]]
            foo = table_2.at "foo"
            weird_column = table_2.at "weird_column"
            bar = table.at "bar"

            selector = By_Column [bar, weird_column, foo]
            action = table.reorder_columns selector position=After_Other_Columns on_problems=_
            tester = expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "bar", "foo"]
            problems = [Missing_Input_Columns_Data ["weird_column"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle multiple problems" <|
            action = table.reorder_columns (By_Index [0, -7, 0, 100]) position=After_Other_Columns on_problems=_
            problems = [Column_Indexes_Out_Of_Range_Data [100], Duplicate_Column_Selectors_Data [0], Input_Indices_Already_Matched_Data [-7]]
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"]
            Problems.test_problem_handling action problems tester

    Test.group prefix+"Table.sort_columns" pending=pending <|
        table =
            col1 = ["foo_21", [1,2,3]]
            col2 = ["foo_100", [4,5,6]]
            col3 = ["foo_1", [7,8,9]]
            col4 = ["Foo_2", [10,11,12]]
            col5 = ["foo_3", [13,14,15]]
            col6 = ["foo_001", [16,17,18]]
            col7 = ["bar", [19,20,21]]
            table_builder [col1, col2, col3, col4, col5, col6, col7]

        Test.specify "should work as shown in the doc examples" <|
            sorted = table.sort_columns
            expect_column_names ["Foo_2", "bar", "foo_001", "foo_1", "foo_100", "foo_21", "foo_3"] sorted
            sorted.columns.first.to_vector . should_equal [10,11,12]

            expect_column_names ["bar", "foo_001", "foo_1", "Foo_2", "foo_3", "foo_21", "foo_100"] <| table.sort_columns text_ordering=(Text_Ordering.Case_Insensitive sort_digits_as_numbers=True)
            expect_column_names ["foo_3", "foo_21", "foo_100", "foo_1", "foo_001", "bar", "Foo_2"] <| table.sort_columns Sort_Direction.Descending

        Test.specify "should correctly handle case-insensitive sorting" <|
            expect_column_names ["bar", "foo_001", "foo_1", "foo_100", "Foo_2", "foo_21", "foo_3"] <| table.sort_columns text_ordering=(Text_Ordering.Case_Insensitive)

        Test.specify "should correctly handle natural order sorting" <|
            expect_column_names ["Foo_2", "bar", "foo_001", "foo_1", "foo_3", "foo_21", "foo_100"] <| table.sort_columns text_ordering=(Text_Ordering.Default sort_digits_as_numbers=True)

        Test.specify "should correctly handle various combinations of options" <|
            expect_column_names ["foo_100", "foo_21", "foo_3", "Foo_2", "foo_1", "foo_001", "bar"] <| table.sort_columns direction=Sort_Direction.Descending text_ordering=(Text_Ordering.Case_Insensitive sort_digits_as_numbers=True)

    Test.group prefix+"Table.rename_columns" pending=pending <|
        table =
            col1 = ["alpha", [1,2,3]]
            col2 = ["beta", [4,5,6]]
            col3 = ["gamma", [16,17,18]]
            col4 = ["delta", [19,20,21]]
            table_builder [col1, col2, col3, col4]

        Test.specify "should work as shown in the doc examples" <|
            expect_column_names ["FirstColumn", "beta", "gamma", "delta"] <|
                table.rename_columns (Column_Name_Mapping.By_Position ["FirstColumn"])

        Test.specify "should work by index" <|
            map = Map.from_vector [[0, "FirstColumn"], [-2, "Another"]]
            expect_column_names ["FirstColumn", "beta", "Another", "delta"] <|
                table.rename_columns (Column_Name_Mapping.By_Index map)

        Test.specify "should work by position" <|
            vec = ["one", "two", "three"]
            expect_column_names ["one", "two", "three", "delta"] <|
                table.rename_columns (Column_Name_Mapping.By_Position vec)

        Test.specify "should work by Vector" <|
            vec = ["one", "two", "three"]
            expect_column_names ["one", "two", "three", "delta"] <|
                table.rename_columns vec

        Test.specify "should work by name" <|
            map = Map.from_vector [["alpha", "FirstColumn"], ["delta", "Another"]]
            expect_column_names ["FirstColumn", "beta", "gamma", "Another"] <|
                table.rename_columns (Column_Name_Mapping.By_Name map (Text_Matcher.Case_Sensitive))

        Test.specify "should work by name case-insensitively" <|
            map = Map.from_vector [["ALPHA", "FirstColumn"], ["DELTA", "Another"]]
            expect_column_names ["FirstColumn", "beta", "gamma", "Another"] <|
                table.rename_columns (Column_Name_Mapping.By_Name map Text_Matcher.Case_Insensitive)

        Test.specify "should work by name using regex" <|
            map = Map.from_vector [["a.*", "FirstColumn"]]
            expect_column_names ["FirstColumn", "beta", "gamma", "delta"] <|
                table.rename_columns (Column_Name_Mapping.By_Name map (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))

        Test.specify "should work by name using regex substitution" <|
            map = Map.from_vector [["a(.*)", "$1"]]
            expect_column_names ["lpha", "beta", "gamma", "delta"] <|
                table.rename_columns (Column_Name_Mapping.By_Name map (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))

        Test.specify "should work by column" <|
            vec = [[table.at "alpha", "FirstColumn"], [table.at "delta", "Another"]]
            expect_column_names ["FirstColumn", "beta", "gamma", "Another"] <|
                table.rename_columns (Column_Name_Mapping.By_Column vec)

        Test.specify "should correctly handle problems: duplicate columns" <|
            map = Column_Name_Mapping.By_Column [[table.at "alpha", "FirstColumn"], [table.at "alpha", "Another"]]
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["FirstColumn", "beta", "gamma", "delta"]
            problems = [Duplicate_Column_Selectors_Data ["alpha"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched names" <|
            weird_name = '.*?-!@#!"'
            map = Column_Name_Mapping.By_Name (Map.from_vector [["alpha", "FirstColumn"], ["omicron", "Another"], [weird_name, "Fixed"]])
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["FirstColumn", "beta", "gamma", "delta"]
            problems = [Missing_Input_Columns_Data [weird_name, "omicron"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: out of bounds indices" <|
            map = Column_Name_Mapping.By_Index (Map.from_vector [[0, "FirstColumn"], [-1, "Another"], [100, "Boo"], [-200, "Nothing"], [300, "Here"]])
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["FirstColumn", "beta", "gamma", "Another"]
            problems = [Column_Indexes_Out_Of_Range_Data [-200, 100, 300]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: aliased indices" <|
            map = Column_Name_Mapping.By_Index (Map.from_vector [[1, "FirstColumn"], [-3, "Another"]])
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["alpha", "Another", "gamma", "delta"]
            problems = [Input_Indices_Already_Matched_Data [1]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: invalid names ''" <|
            map = Column_Name_Mapping.By_Index (Map.from_vector [[1, ""]])
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["alpha", "Column_1", "gamma", "delta"]
            problems = [Invalid_Output_Column_Names_Data [""]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: invalid names Nothing" <|
            map = Column_Name_Mapping.By_Position ["alpha", Nothing]
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["alpha", "Column_1", "gamma", "delta"]
            problems = [Invalid_Output_Column_Names_Data [Nothing]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate names" <|
            map = Column_Name_Mapping.By_Position ["Test", "Test", "Test", "Test"]
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["Test", "Test_1", "Test_2", "Test_3"]
            problems = [Duplicate_Output_Column_Names_Data ["Test", "Test", "Test"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: too many input names" <|
            map = Column_Name_Mapping.By_Position ["A", "B", "C", "D", "E", "F"]
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["A", "B", "C", "D"]
            problems = [Too_Many_Column_Names_Provided_Data ["E", "F"]]
            Problems.test_problem_handling action problems tester

    order_by_pending = if pending.is_nothing.not then pending else
        if test_selection.order_by.not then "TODO: order_by is not yet supported by this backend." else
            Nothing
    Test.group prefix+"Table.order_by" pending=order_by_pending <|
        table =
            col1 = ["alpha", [3, 2, 1, 0]]
            col2 = ["beta", ["a", "b", "a", "b"]]
            col3 = ["gamma", [1, 2, 3, 4]]
            col4 = ["delta", ["a10", "a1", "a2", "a03"]]
            col5 = ["eta", ["Beta", "alpha", "bądź", "Aleph"]]
            col6 = ["xi", [1.0, 1.5, Nothing, 0.5]]
            col7 = ["psi", [Nothing, "c01", "c10", "C2"]]
            col8 = ["phi", ["śc", Nothing, 's\u0301b', "śa"]]
            col9 = ["tau", [32.0, 0.5, -0.1, 1.6]]
            col10 = ["rho", ["BB", Nothing, Nothing, "B"]]
            table_builder [col1, col2, col3, col4, col5, col6, col7, col8, col9, col10]

        Test.specify "should work as shown in the doc examples" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name ["alpha"])
            t1.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
            t1.at "gamma" . to_vector . should_equal [4, 3, 2, 1]

            t2 = table.order_by (Sort_Column_Selector.By_Index [1, Sort_Column.Index -8 Sort_Direction.Descending])
            t2.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t2.at "gamma" . to_vector . should_equal [3, 1, 4, 2]
            t2.at "alpha" . to_vector . should_equal [1, 3, 0, 2]

        Test.specify "should correctly handle regexes matching multiple names" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name ".*ta"  Sort_Direction.Descending] (Regex_Matcher.Regex_Matcher_Data case_sensitivity=Case_Sensitivity.Sensitive))
            t1.at "beta" . to_vector . should_equal ["b", "b", "a", "a"]
            t1.at "delta" . to_vector . should_equal ["a1", "a03", "a2", "a10"]
            t1.at "gamma" . to_vector . should_equal [2, 4, 3, 1]

        Test.specify "should correctly handle problems: out of bounds indices" <|
            selector = Sort_Column_Selector.By_Index [0, 100, Sort_Column.Index -200, Sort_Column.Index 300]
            action = table.order_by selector on_problems=_
            tester table =
                table.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
                table.at "gamma" . to_vector . should_equal [4, 3, 2, 1]
            problems = [Column_Indexes_Out_Of_Range_Data [100, -200, 300]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate indices" <|
            selector = Sort_Column_Selector.By_Index [0, Sort_Column.Index 0, Sort_Column.Index 0 Sort_Direction.Descending]
            action = table.order_by selector on_problems=_
            tester table =
                table.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
                table.at "gamma" . to_vector . should_equal [4, 3, 2, 1]
            problems = [Duplicate_Column_Selectors_Data [Sort_Column.Index 0, Sort_Column.Index 0 Sort_Direction.Descending]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: aliased indices" <|
            selector = Sort_Column_Selector.By_Index [1, Sort_Column.Index -9 Sort_Direction.Descending, Sort_Column.Index -8 Sort_Direction.Descending, Sort_Column.Index 2 Sort_Direction.Ascending]
            action = table.order_by selector on_problems=_
            tester table =
                table.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
                table.at "gamma" . to_vector . should_equal [3, 1, 4, 2]
                table.at "alpha" . to_vector . should_equal [1, 3, 0, 2]
            problems = [Input_Indices_Already_Matched_Data [Sort_Column.Index -9 Sort_Direction.Descending, Sort_Column.Index 2]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate names" <|
            selector = Sort_Column_Selector.By_Name ["alpha", Sort_Column.Name "alpha" Sort_Direction.Descending]
            action = table.order_by selector on_problems=_
            tester table =
                table.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
                table.at "gamma" . to_vector . should_equal [4, 3, 2, 1]
            problems = [Column_Matched_By_Multiple_Selectors_Data "alpha" [Sort_Column.Name "alpha", Sort_Column.Name "alpha" Sort_Direction.Descending]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate matches due to case insensitivity" <|
            selector = Sort_Column_Selector.By_Name [Sort_Column.Name "ALPHA", Sort_Column.Name "alpha" Sort_Direction.Descending] Text_Matcher.Case_Insensitive
            action = table.order_by selector on_problems=_
            tester table =
                table.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
                table.at "gamma" . to_vector . should_equal [4, 3, 2, 1]
            problems = [Column_Matched_By_Multiple_Selectors_Data "alpha" [Sort_Column.Name "ALPHA", Sort_Column.Name "alpha" Sort_Direction.Descending]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched names" <|
            weird_name = '.*?-!@#!"'
            selector = Sort_Column_Selector.By_Name [Sort_Column.Name "alpha", "hmm", Sort_Column.Name weird_name]
            action = table.order_by selector on_problems=_
            tester table =
                table.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
                table.at "gamma" . to_vector . should_equal [4, 3, 2, 1]
            problems = [Missing_Input_Columns_Data [Sort_Column.Name "hmm", Sort_Column.Name weird_name]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched columns" <|
            table_2 = table_builder [["alpha", [0,0,0]], ["weird_column", [0,0,0]]]
            foo = table_2.at "alpha"
            weird_column = table_2.at "weird_column"
            bar = table.at "beta"

            selector = Sort_Column_Selector.By_Column [bar, weird_column, Sort_Column.Column foo]
            problem = table.order_by selector on_problems=Problem_Behavior.Report_Error . catch
            problem.should_be_a Missing_Input_Columns_Data
            problem.criteria.map (selector-> selector.column.name) . should_equal ["weird_column"]

            t2 = table.order_by selector on_problems=Problem_Behavior.Ignore
            t2.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t2.at "alpha" . to_vector . should_equal [1, 3, 0, 2]
            t2.at "gamma" . to_vector . should_equal [3, 1, 4, 2]

        Test.specify "should report a problem if no columns are selected for ordering" <|
            action = table.order_by (Sort_Column_Selector.By_Name []) on_problems=_
            tester t2 =
                t2.at "alpha" . to_vector . should_equal (table.at "alpha" . to_vector)
            problems = [No_Input_Columns_Selected]
            Problems.test_problem_handling action problems tester

        Test.specify "should stack consecutive ordering operations" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "alpha"])
            t1.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
            t1.at "beta" . to_vector . should_equal ["b", "a", "b", "a"]

            # Now we reverse the order
            t2 = t1.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "alpha" Sort_Direction.Descending])
            t2.at "alpha" . to_vector . should_equal [3, 2, 1, 0]
            t2.at "beta" . to_vector . should_equal ["a", "b", "a", "b"]

            # Now we add another primary ordering, but the order from t1/t2 is kept for tie breaking.
            t3 = t1.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "beta"])
            t3.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t3.at "alpha" . to_vector . should_equal [1, 3, 0, 2]

            t4 = t2.order_by (Sort_Column_Selector.By_Name ["beta"])
            t4.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t4.at "alpha" . to_vector . should_equal [3, 1, 2, 0]

        Test.specify "should give priority to the first selected column and use the next ones for breaking ties" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name ["beta", Sort_Column.Name "alpha" Sort_Direction.Ascending])
            t1.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t1.at "alpha" . to_vector . should_equal [1, 3, 0, 2]
            t1.at "gamma" . to_vector . should_equal [3, 1, 4, 2]

            t2 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "beta", Sort_Column.Name "alpha" Sort_Direction.Descending])
            t2.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t2.at "alpha" . to_vector . should_equal [3, 1, 2, 0]
            t2.at "gamma" . to_vector . should_equal [1, 3, 2, 4]

            t3 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "alpha", Sort_Column.Name "beta"])
            t3.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
            t3.at "beta" . to_vector . should_equal ["b", "a", "b", "a"]
            t3.at "gamma" . to_vector . should_equal [4, 3, 2, 1]

            t4 = table.order_by (Sort_Column_Selector.By_Index [1, Sort_Column.Index 0 Sort_Direction.Ascending])
            t4.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t4.at "alpha" . to_vector . should_equal [1, 3, 0, 2]
            t4.at "gamma" . to_vector . should_equal [3, 1, 4, 2]

            t5 = table.order_by (Sort_Column_Selector.By_Column [table.at "beta", Sort_Column.Column (table.at "alpha") Sort_Direction.Ascending])
            t5.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t5.at "alpha" . to_vector . should_equal [1, 3, 0, 2]
            t5.at "gamma" . to_vector . should_equal [3, 1, 4, 2]

        Test.specify "should deal with real numbers" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name ["tau"])
            t1.at "tau" . to_vector . should_equal [-0.1, 0.5, 1.6, 32.0]
            t1.at "alpha" . to_vector . should_equal [1, 2, 0, 3]

        Test.specify "should deal with nulls" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name ["xi"])
            t1.at "xi" . to_vector . should_equal [Nothing, 0.5, 1.0, 1.5]
            t1.at "alpha" . to_vector . should_equal [1, 0, 3, 2]

            t2 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "rho"])
            t2.at "rho" . to_vector . should_equal [Nothing, Nothing, "B", "BB"]

            t3 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "rho" Sort_Direction.Descending])
            t3.at "rho" . to_vector . should_equal ["BB", "B", Nothing, Nothing]

        Test.specify "should behave as expected with Unicode normalization, depending on the defaults settings" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "phi"])
            case test_selection.order_by_unicode_normalization_by_default of
                True ->
                    t1.at "phi" . to_vector . should_equal [Nothing, "śa", 's\u0301b', "śc"]
                    t1.at "alpha" . to_vector . should_equal [2, 0, 1, 3]
                False ->
                    t1.at "phi" . to_vector . should_equal [Nothing, 's\u0301b', "śa", "śc"]
                    t1.at "alpha" . to_vector . should_equal [2, 1, 0, 3]

        Test.specify "should support natural ordering" pending=(if test_selection.natural_ordering.not then "Natural ordering is not supported.") <|
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "delta"]) text_ordering=(Text_Ordering.Default sort_digits_as_numbers=True)
            t1.at "delta" . to_vector . should_equal ["a1", "a2", "a03", "a10"]
            t1.at "alpha" . to_vector . should_equal [2, 1, 0, 3]

            t2 = table.order_by (Sort_Column_Selector.By_Name ["delta"]) text_ordering=(Text_Ordering.Default sort_digits_as_numbers=False)
            t2.at "delta" . to_vector . should_equal ["a03", "a1", "a10", "a2"]
            t2.at "alpha" . to_vector . should_equal [0, 2, 3, 1]

        Test.specify "should support case insensitive ordering" pending=(if test_selection.case_insensitive_ordering.not then "Case insensitive ordering is not supported.") <|
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "eta"]) text_ordering=(Text_Ordering.Case_Insensitive)
            expected = case test_selection.case_insensitive_ascii_only of
                True -> ["Aleph", "alpha", "Beta", "bądź"]
                False -> ["Aleph", "alpha", "bądź", "Beta"]
            t1.at "eta" . to_vector . should_equal expected

            t2 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "eta"]) text_ordering=(Text_Ordering.Case_Sensitive)
            t2.at "eta" . to_vector . should_equal ["Aleph", "Beta", "alpha", "bądź"]

            t3 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "psi"]) text_ordering=(Text_Ordering.Case_Insensitive)
            t3.at "psi" . to_vector . should_equal [Nothing, "c01", "c10", "C2"]

            t4 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "psi" Sort_Direction.Descending]) text_ordering=(Text_Ordering.Case_Sensitive)
            t4.at "psi" . to_vector . should_equal ["c10", "c01", "C2", Nothing]

        Test.specify "should support natural and case insensitive ordering at the same time" pending=(if (test_selection.natural_ordering.not || test_selection.case_insensitive_ordering.not) then "Natural ordering or case sensitive ordering is not supported.") <|
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "psi"]) text_ordering=(Text_Ordering.Case_Insensitive sort_digits_as_numbers=True)
            t1.at "psi" . to_vector . should_equal [Nothing, "c01", "C2", "c10"]

            t2 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "psi"]) text_ordering=(Text_Ordering.Default sort_digits_as_numbers=True)
            t2.at "psi" . to_vector . should_equal [Nothing, "C2", "c01", "c10"]

            t3 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "psi"]) text_ordering=(Text_Ordering.Case_Insensitive)
            t3.at "psi" . to_vector . should_equal [Nothing, "c01", "c10", "C2"]

            t4 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "psi"])
            t4.at "psi" . to_vector . should_equal [Nothing, "C2", "c01", "c10"]

        Test.specify "text ordering settings should not affect numeric columns" <|
            ordering = Text_Ordering.Case_Insensitive sort_digits_as_numbers=True
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "alpha"]) text_ordering=ordering
            t1.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
            t1.at "gamma" . to_vector . should_equal [4, 3, 2, 1]

    take_drop_by_pending = if pending.is_nothing.not then pending else
        if test_selection.take_drop.not then "TODO: take/drop are not yet supported by this backend." else
            Nothing
    Test.group prefix+"Table.take/drop" pending=take_drop_by_pending <|
        table =
            col1 = ["alpha", [1,2,3,4,5,6,7,8]]
            col2 = ["beta", ["A","B","C","D","E","F","G","H"]]
            table_builder [col1, col2]
        empty = table_builder [["alpha", []], ["beta", []]]

        Test.specify "should allow selecting first or last N rows" <|
            table.take.at "alpha" . to_vector . should_equal [1]
            table.take.at "beta" . to_vector . should_equal ["A"]
            table.drop.at "alpha" . to_vector . should_equal [2,3,4,5,6,7,8]

            table.take (First 4) . at "alpha" . to_vector . should_equal [1,2,3,4]
            table.take (First 0) . at "alpha" . to_vector . should_equal []
            table.take (First -1) . at "alpha" . to_vector . should_equal []
            table.take (First 100) . should_equal table

            table.drop (First 2) . at "beta" . to_vector . should_equal ["C","D","E","F","G","H"]
            table.drop (First 0) . should_equal table
            table.drop (First -1) . should_equal table
            table.drop (First 100) . should_equal empty

            table.take (Last 4) . at "beta" . to_vector . should_equal ["E","F","G","H"]
            table.take (Last 0) . should_equal empty
            table.take (Last -1) . should_equal empty
            table.take (Last 100) . should_equal table

            table.drop (Last 2) . at "alpha" . to_vector . should_equal [1,2,3,4,5,6]
            table.drop (Last 0) . should_equal table
            table.drop (Last -1) . should_equal table
            table.drop (Last 100) . should_equal empty

        Test.specify "should allow selecting rows by ranges or indices" <|
            table.take (Range_Data 2 4) . at "beta" . to_vector . should_equal ["C", "D"]
            table.take (Range_Data 0 0) . should_equal empty
            table.take (Range_Data 100 100) . should_fail_with Index_Out_Of_Bounds_Error_Data
            table.take (Range_Data 100 100) . catch . should_equal (Index_Out_Of_Bounds_Error_Data 100 8)
            table.take (Range_Data 0 100) . should_equal table
            table.take (Range_Data 0 table.row_count) . should_equal table
            empty.take (Range_Data 0 0) . should_fail_with Index_Out_Of_Bounds_Error_Data
            empty.take (Range_Data 0 0) . catch . should_equal (Index_Out_Of_Bounds_Error_Data 0 0)
            table.take (Range_Data 100 99) . should_fail_with Index_Out_Of_Bounds_Error_Data

            table.drop (Range_Data 2 4) . at "alpha" . to_vector . should_equal [1, 2, 5, 6, 7, 8]
            table.drop (Range_Data 0 0) . should_equal table
            table.drop (Range_Data 100 100) . should_fail_with Index_Out_Of_Bounds_Error_Data
            table.drop (Range_Data 100 100) . catch . should_equal (Index_Out_Of_Bounds_Error_Data 100 8)
            table.drop (Range_Data 0 100) . should_equal empty
            table.drop (Range_Data 0 table.row_count) . should_equal empty
            empty.drop (Range_Data 0 0) . should_fail_with Index_Out_Of_Bounds_Error_Data
            empty.drop (Range_Data 0 0) . catch . should_equal (Index_Out_Of_Bounds_Error_Data 0 0)
            table.drop (Range_Data 100 99) . should_fail_with Index_Out_Of_Bounds_Error_Data

            table.take (Index_Sub_Range.By_Index 0) . at "beta" . to_vector . should_equal ["A"]
            empty.take (Index_Sub_Range.By_Index 0) . should_fail_with Index_Out_Of_Bounds_Error_Data
            table.take (Index_Sub_Range.By_Index []) . should_equal empty
            table.take (Index_Sub_Range.By_Index [-1, -1]) . at "beta" . to_vector . should_equal ["H", "H"]
            table.take (Index_Sub_Range.By_Index [0, 0, Range_Data 3 100]) . at "alpha" . to_vector . should_equal [1, 1, 4, 5, 6, 7, 8]
            table.take (Range_Data 0 100 2) . at "alpha" . to_vector . should_equal [1, 3, 5, 7]
            table.take (Index_Sub_Range.By_Index [Range_Data 0 100 2, Range_Data 1 6 2]) . at "alpha" . to_vector . should_equal [1, 3, 5, 7, 2, 4, 6]
            table.take (Index_Sub_Range.By_Index [Range_Data 1 3, Range_Data 2 5]) . at "alpha" . to_vector . should_equal [2, 3, 3, 4, 5]
            table.take (Index_Sub_Range.By_Index [Range_Data 2 5, Range_Data 1 3]) . at "alpha" . to_vector . should_equal [3, 4, 5, 2, 3]
            table.take (Index_Sub_Range.By_Index [0, 1, Range_Data 100 200]) . should_fail_with Index_Out_Of_Bounds_Error_Data
            table.take (Index_Sub_Range.By_Index 100) . should_fail_with Index_Out_Of_Bounds_Error_Data

            table.drop (Index_Sub_Range.By_Index 0) . at "alpha" . to_vector . should_equal [2, 3, 4, 5, 6, 7, 8]
            table.drop (Index_Sub_Range.By_Index []) . should_equal table
            table.drop (Index_Sub_Range.By_Index [-1, -1]) . at "alpha" . to_vector . should_equal [1, 2, 3, 4, 5, 6, 7]
            table.drop (Index_Sub_Range.By_Index [0, 0, Range_Data 3 100]) . at "alpha" . to_vector . should_equal [2, 3]
            table.drop (Range_Data 0 100 2) . at "alpha" . to_vector . should_equal [2, 4, 6, 8]
            table.drop (Index_Sub_Range.By_Index [Range_Data 0 100 2, Range_Data 1 6 2]) . at "alpha" . to_vector . should_equal [8]
            table.drop (Index_Sub_Range.By_Index [Range_Data 1 3, Range_Data 2 5]) . at "alpha" . to_vector . should_equal [1, 6, 7, 8]
            table.drop (Index_Sub_Range.By_Index [Range_Data 2 5, Range_Data 1 3]) . at "alpha" . to_vector . should_equal [1, 6, 7, 8]
            table.drop (Index_Sub_Range.By_Index [0, 1, Range_Data 100 200]) . should_fail_with Index_Out_Of_Bounds_Error_Data
            table.drop (Index_Sub_Range.By_Index 100) . should_fail_with Index_Out_Of_Bounds_Error_Data

        Test.specify "should allow selecting every Nth row" <|
            table.take (Every 1) . should_equal table
            table.take (Every 3) . at "alpha" . to_vector . should_equal [1, 4, 7]
            table.take (Every 3 first=1) . at "alpha" . to_vector . should_equal [2, 5, 8]
            table.take (Every 2 first=1) . at "beta" . to_vector . should_equal ["B", "D", "F", "H"]
            table.take (Every 2 first=100) . at "alpha" . to_vector . should_equal []
            table.take (Every 200) . at "alpha" . to_vector . should_equal [1]
            empty.take (Every 2) . should_equal empty
            table.take (Every 0) . should_fail_with Illegal_Argument_Error_Data
            empty.take (Every 0) . should_fail_with Illegal_Argument_Error_Data

            table.drop (Every 1) . should_equal empty
            table.drop (Every 3) . at "alpha" . to_vector . should_equal [2, 3, 5, 6, 8]
            table.drop (Every 3 first=1) . at "alpha" . to_vector . should_equal [1, 3, 4, 6, 7]
            table.drop (Every 2 first=1) . at "alpha" . to_vector . should_equal [1, 3, 5, 7]
            table.drop (Every 2 first=100) . should_equal table
            table.drop (Every 200) . at "beta" . to_vector . should_equal ["B", "C", "D", "E", "F", "G", "H"]
            empty.drop (Every 2) . should_equal empty
            table.drop (Every 0) . should_fail_with Illegal_Argument_Error_Data
            empty.drop (Every 0) . should_fail_with Illegal_Argument_Error_Data

        Test.specify "should allow sampling rows" <|
            empty = table_builder [["X", []]]
            one = table_builder [["X", ["a"]]]
            two = table_builder [["X", ["a", "a"]]]
            three = table_builder [["X", ["a", "a", "a"]]]
            three.take (Sample 0) . should_equal empty
            empty.take (Sample 0) . should_equal empty
            empty.take (Sample 1) . should_equal empty
            three.take (Sample 1) . should_equal one
            three.take (Sample 100) . should_equal three

            three.drop (Sample 0) . should_equal three
            empty.drop (Sample 0) . should_equal empty
            empty.drop (Sample 1) . should_equal empty
            one.drop (Sample 1) . should_equal empty
            three.drop (Sample 1) . should_equal two
            three.drop (Sample 100) . should_equal empty

            rnd = table.take (Sample 3 seed=42)
            random_indices = [5, 6, 2]
            alpha_sample = random_indices.map (table.at "alpha" . to_vector . at)
            beta_sample = random_indices.map (table.at "beta" . to_vector . at)
            rnd.at "alpha" . to_vector . should_equal alpha_sample
            rnd.at "beta" . to_vector . should_equal beta_sample

        Test.specify "should allow selecting rows as long as they satisfy a predicate" pending="While is not implemented for Table until the Row type is implemented." <|
            Nothing

    Test.group prefix+"Column.take/drop" pending=take_drop_by_pending <|
        table =
            col1 = ["alpha", [1,2,3,4,5,6,7,8]]
            col2 = ["beta", ["A","B","C","D","E","F","G","H"]]
            table_builder [col1, col2]
        alpha = table.at "alpha"
        beta = table.at "beta"

        empty_table = table_builder [["alpha", []], ["beta", []]]
        empty_alpha = empty_table.at "alpha"
        empty_beta = empty_table.at "beta"

        Test.specify "should allow selecting first or last N rows" <|
            alpha.take.to_vector . should_equal [1]
            beta.take.to_vector . should_equal ["A"]
            alpha.drop.to_vector . should_equal [2,3,4,5,6,7,8]

            alpha.take (First 4) . to_vector . should_equal [1,2,3,4]
            alpha.take (First 0) . should_equal empty_alpha
            alpha.take (First -1) . should_equal empty_alpha
            alpha.take (First 100) . should_equal alpha

            beta.drop (First 2) . to_vector . should_equal ["C","D","E","F","G","H"]
            alpha.drop (First 0) . should_equal alpha
            alpha.drop (First -1) . should_equal alpha
            alpha.drop (First 100) . should_equal empty_alpha

            beta.take (Last 4) . to_vector . should_equal ["E","F","G","H"]
            beta.take (Last 0) . should_equal empty_beta
            beta.take (Last -1) . should_equal empty_beta
            beta.take (Last 100) . should_equal beta

            alpha.drop (Last 2) . to_vector . should_equal [1,2,3,4,5,6]
            alpha.drop (Last 0) . should_equal alpha
            alpha.drop (Last -1) . should_equal alpha
            alpha.drop (Last 100) . should_equal empty_alpha

        Test.specify "should allow selecting rows by ranges or indices" <|
            beta.take (Range_Data 2 4) . to_vector . should_equal ["C", "D"]
            beta.take (Range_Data 0 0) . should_equal empty_beta
            beta.take (Range_Data 100 100) . should_fail_with Index_Out_Of_Bounds_Error_Data
            beta.take (Range_Data 100 100) . catch . should_equal (Index_Out_Of_Bounds_Error_Data 100 8)
            beta.take (Range_Data 0 100) . should_equal beta
            beta.take (Range_Data 0 table.row_count) . should_equal beta
            empty_beta.take (Range_Data 0 0) . should_fail_with Index_Out_Of_Bounds_Error_Data
            empty_beta.take (Range_Data 0 0) . catch . should_equal (Index_Out_Of_Bounds_Error_Data 0 0)
            beta.take (Range_Data 100 99) . should_fail_with Index_Out_Of_Bounds_Error_Data

            alpha.drop (Range_Data 2 4) . to_vector . should_equal [1, 2, 5, 6, 7, 8]
            alpha.drop (Range_Data 0 0) . should_equal alpha
            alpha.drop (Range_Data 100 100) . should_fail_with Index_Out_Of_Bounds_Error_Data
            alpha.drop (Range_Data 100 100) . catch . should_equal (Index_Out_Of_Bounds_Error_Data 100 8)
            alpha.drop (Range_Data 0 100) . should_equal empty_alpha
            alpha.drop (Range_Data 0 table.row_count) . should_equal empty_alpha
            empty_alpha.drop (Range_Data 0 0) . should_fail_with Index_Out_Of_Bounds_Error_Data
            empty_alpha.drop (Range_Data 0 0) . catch . should_equal (Index_Out_Of_Bounds_Error_Data 0 0)
            alpha.drop (Range_Data 100 99) . should_fail_with Index_Out_Of_Bounds_Error_Data

            beta.take (Index_Sub_Range.By_Index 0) . to_vector . should_equal ["A"]
            empty_beta.take (Index_Sub_Range.By_Index 0) . should_fail_with Index_Out_Of_Bounds_Error_Data
            beta.take (Index_Sub_Range.By_Index []) . should_equal empty_beta
            beta.take (Index_Sub_Range.By_Index [-1, -1]) . to_vector . should_equal ["H", "H"]
            alpha.take (Index_Sub_Range.By_Index [0, 0, Range_Data 3 100]) . to_vector . should_equal [1, 1, 4, 5, 6, 7, 8]
            alpha.take (Range_Data 0 100 2) . to_vector . should_equal [1, 3, 5, 7]
            alpha.take (Index_Sub_Range.By_Index [Range_Data 0 100 2, Range_Data 1 6 2]) . to_vector . should_equal [1, 3, 5, 7, 2, 4, 6]
            alpha.take (Index_Sub_Range.By_Index [Range_Data 1 3, Range_Data 2 5]) . to_vector . should_equal [2, 3, 3, 4, 5]
            alpha.take (Index_Sub_Range.By_Index [Range_Data 2 5, Range_Data 1 3]) . to_vector . should_equal [3, 4, 5, 2, 3]
            alpha.take (Index_Sub_Range.By_Index [0, 1, Range_Data 100 200]) . should_fail_with Index_Out_Of_Bounds_Error_Data
            alpha.take (Index_Sub_Range.By_Index 100) . should_fail_with Index_Out_Of_Bounds_Error_Data

            alpha.drop (Index_Sub_Range.By_Index 0) . to_vector . should_equal [2, 3, 4, 5, 6, 7, 8]
            alpha.drop (Index_Sub_Range.By_Index []) . should_equal alpha
            alpha.drop (Index_Sub_Range.By_Index [-1, -1]) . to_vector . should_equal [1, 2, 3, 4, 5, 6, 7]
            alpha.drop (Index_Sub_Range.By_Index [0, 0, Range_Data 3 100]) . to_vector . should_equal [2, 3]
            alpha.drop (Range_Data 0 100 2) . to_vector . should_equal [2, 4, 6, 8]
            alpha.drop (Index_Sub_Range.By_Index [Range_Data 0 100 2, Range_Data 1 6 2]) . to_vector . should_equal [8]
            alpha.drop (Index_Sub_Range.By_Index [Range_Data 1 3, Range_Data 2 5]) . to_vector . should_equal [1, 6, 7, 8]
            alpha.drop (Index_Sub_Range.By_Index [Range_Data 2 5, Range_Data 1 3]) . to_vector . should_equal [1, 6, 7, 8]
            alpha.drop (Index_Sub_Range.By_Index [0, 1, Range_Data 100 200]) . should_fail_with Index_Out_Of_Bounds_Error_Data
            alpha.drop (Index_Sub_Range.By_Index 100) . should_fail_with Index_Out_Of_Bounds_Error_Data

        Test.specify "should allow selecting every Nth row" <|
            alpha.take (Every 1) . should_equal alpha
            alpha.take (Every 3) . to_vector . should_equal [1, 4, 7]
            alpha.take (Every 3 first=1) . to_vector . should_equal [2, 5, 8]
            beta.take (Every 2 first=1) . to_vector . should_equal ["B", "D", "F", "H"]
            alpha.take (Every 2 first=100) . to_vector . should_equal []
            alpha.take (Every 200) . to_vector . should_equal [1]
            empty_beta.take (Every 2) . should_equal empty_beta
            beta.take (Every 0) . should_fail_with Illegal_Argument_Error_Data
            empty_beta.take (Every 0) . should_fail_with Illegal_Argument_Error_Data

            alpha.drop (Every 1) . should_equal empty_alpha
            alpha.drop (Every 3) . to_vector . should_equal [2, 3, 5, 6, 8]
            alpha.drop (Every 3 first=1) . to_vector . should_equal [1, 3, 4, 6, 7]
            alpha.drop (Every 2 first=1) . to_vector . should_equal [1, 3, 5, 7]
            alpha.drop (Every 2 first=100) . should_equal alpha
            beta.drop (Every 200) . to_vector . should_equal ["B", "C", "D", "E", "F", "G", "H"]
            empty_beta.drop (Every 2) . should_equal empty_beta
            beta.drop (Every 0) . should_fail_with Illegal_Argument_Error_Data
            empty_beta.drop (Every 0) . should_fail_with Illegal_Argument_Error_Data

        Test.specify "should allow sampling rows" <|
            three = table_builder [["X", ["a", "a", "a"]]] . at "X"
            two = three.take (First 2)
            one = three.take First
            empty = three.take (First 0)

            [three, two, one, empty].map .to_vector . should_equal [["a", "a", "a"], ["a", "a"], ["a"], []]

            three.take (Sample 0) . should_equal empty
            empty.take (Sample 0) . should_equal empty
            empty.take (Sample 1) . should_equal empty
            three.take (Sample 1) . should_equal one
            three.take (Sample 100) . should_equal three

            three.drop (Sample 0) . should_equal three
            empty.drop (Sample 0) . should_equal empty
            empty.drop (Sample 1) . should_equal empty
            one.drop (Sample 1) . should_equal empty
            three.drop (Sample 1) . should_equal two
            three.drop (Sample 100) . should_equal empty

            rnd = alpha.take (Sample 3 seed=42)
            random_indices = [5, 6, 2]
            sample = alpha.take (Index_Sub_Range.By_Index random_indices)
            rnd.should_equal sample

        Test.specify "should allow selecting rows as long as they satisfy a predicate" <|
            col = table_builder [["X", [1, 3, 5, 6, 8, 9, 10, 11, 13]]] . at "X"
            col.take (While (x-> x%2 == 1)) . to_vector . should_equal [1, 3, 5]
            col.drop (While (x-> x%2 == 1)) . to_vector . should_equal [6, 8, 9, 10, 11, 13]

            three = table_builder [["X", [1, 2, 3]]] . at "X"
            empty = table_builder [["X", []]] . at "X"
            three.take (While (_ > 10)) . should_equal empty
            three.take (While (_ < 10)) . should_equal three

            three.drop (While (_ > 10)) . should_equal three
            three.drop (While (_ < 10)) . should_equal empty

    check_empty expected_column_names table =
        table.columns.map .name . should_equal expected_column_names
        expected_column_names.each x->
            table.at x . to_vector . should_equal []
        table.row_count . should_equal 0

    ## Currently these tests rely on filtering preserving the insertion ordering
       within tables. This is not necessarily guaranteed by RDBMS, so we may
       adapt this in the future. For now we implicitly assume the ordering is
       preserved, as that seems to be the case.
    Test.group prefix+"Table.filter" pending=pending <|
        Test.specify "by integer comparisons" <|
            t = table_builder [["ix", [1, 2, 3, 4, 5]], ["X", [100, 3, Nothing, 4, 12]], ["Y", [100, 4, 2, Nothing, 11]]]
            t1 = t.filter "X" (Filter_Condition.Less than=10)
            t1.at "ix" . to_vector . should_equal [2, 4]
            t1.at "X" . to_vector . should_equal [3, 4]
            t.filter "X" (Filter_Condition.Less than=4) . at "X" . to_vector . should_equal [3]
            t.filter "X" (Filter_Condition.Equal_Or_Less than=4) . at "X" . to_vector . should_equal [3, 4]
            t.filter "X" (Filter_Condition.Greater than=4) . at "X" . to_vector . should_equal [100, 12]
            t.filter "X" (Filter_Condition.Equal_Or_Greater than=4) . at "X" . to_vector . should_equal [100, 4, 12]
            t.filter "X" (Filter_Condition.Between 4 100) . at "X" . to_vector . should_equal [100, 4, 12]
            t2 = t.filter "X" (Filter_Condition.Equal to=100)
            t2 . at "X" . to_vector . should_equal [100]
            t2 . at "ix" . to_vector . should_equal [1]
            t.filter "X" (Filter_Condition.Equal to=123) . at "X" . to_vector . should_equal []
            v = t.filter "X" (Filter_Condition.Equal to="SOME TEXT :)") . at "X" . to_vector
            case test_selection.allows_mixed_type_comparisons of
                True -> v.should_equal []
                False -> v.should_fail_with SQL_Error_Data

            t.filter "X" (Filter_Condition.Equal to=(t.at "Y")) . at "X" . to_vector . should_equal [100]
            t.filter "X" (Filter_Condition.Less than=(t.at "Y")) . at "X" . to_vector . should_equal [3]
            t.filter "X" (Filter_Condition.Equal_Or_Less than=(t.at "Y")) . at "X" . to_vector . should_equal [100, 3]
            t.filter "X" (Filter_Condition.Equal_Or_Greater than=(t.at "Y")) . at "X" . to_vector . should_equal [100, 12]
            t.filter "X" (Filter_Condition.Greater than=(t.at "Y")) . at "X" . to_vector . should_equal [12]
            t.filter "Y" (Filter_Condition.Between (t.at "ix") 100) . at "Y" . to_vector . should_equal [100, 4, 11]

        Test.specify "by text comparisons" <|
            t = table_builder [["ix", [1, 2, 3, 4, 5]], ["X", ["abb", "baca", "b", Nothing, "c"]], ["Y", ["a", "b", "b", "c", "c"]]]
            t1 = t.filter "X" (Filter_Condition.Less than="c")
            t1.at "ix" . to_vector . should_equal [1, 2, 3]
            t1.at "X" . to_vector . should_equal ["abb", "baca", "b"]
            t.filter "X" (Filter_Condition.Equal_Or_Less than="b") . at "X" . to_vector . should_equal ["abb", "b"]
            t.filter "X" (Filter_Condition.Greater than="b") . at "X" . to_vector . should_equal ["baca", "c"]
            t.filter "X" (Filter_Condition.Equal_Or_Greater than="b") . at "X" . to_vector . should_equal ["baca", "b", "c"]
            t.filter "X" (Filter_Condition.Between "b" "c") . at "X" . to_vector . should_equal ["baca", "b", "c"]
            t.filter "X" (Filter_Condition.Equal to="baca") . at "X" . to_vector . should_equal ["baca"]
            v = t.filter "X" (Filter_Condition.Equal to=52) . at "X" . to_vector
            case test_selection.allows_mixed_type_comparisons of
                True -> v.should_equal []
                False -> v.should_fail_with SQL_Error_Data

            t.filter "X" (Filter_Condition.Greater than=(t.at "Y")) . at "X" . to_vector . should_equal ["abb", "baca"]
            t.filter "X" (Filter_Condition.Equal_Or_Greater than=(t.at "Y")) . at "X" . to_vector . should_equal ["abb", "baca", "b", "c"]
            t.filter "X" (Filter_Condition.Equal_Or_Less than=(t.at "Y")) . at "X" . to_vector . should_equal ["b", "c"]
            t.filter "X" (Filter_Condition.Less than=(t.at "Y")) . at "X" . to_vector . should_equal []
            t.filter "X" (Filter_Condition.Equal to=(t.at "Y")) . at "X" . to_vector . should_equal ["b", "c"]
            t.filter "X" (Filter_Condition.Between (t.at "Y") "bzzzz") . at "X" . to_vector . should_equal ["abb", "baca", "b"]

        Test.specify "by text search (contains, starts_with, ends_with)" <|
            t = table_builder [["ix", [1, 2, 3, 4, 5]], ["X", ["abb", "baca", "banana", Nothing, "nana"]], ["Y", ["a", "b", "b", "c", "a"]]]

            t.filter "X" (Filter_Condition.Starts_With "ba") on_problems=Report_Error . at "X" . to_vector . should_equal ["baca", "banana"]
            t.filter "X" (Filter_Condition.Ends_With "na") on_problems=Report_Error . at "X" . to_vector . should_equal ["banana", "nana"]
            t.filter "X" (Filter_Condition.Contains "ac") on_problems=Report_Error . at "X" . to_vector . should_equal ["baca"]

            t.filter "X" (Filter_Condition.Starts_With (t.at "Y")) on_problems=Report_Error . at "X" . to_vector . should_equal ["abb", "baca", "banana"]
            t.filter "X" (Filter_Condition.Ends_With (t.at "Y")) on_problems=Report_Error . at "X" . to_vector . should_equal ["nana"]
            t.filter "X" (Filter_Condition.Contains (t.at "Y")) on_problems=Report_Error . at "X" . to_vector . should_equal ["abb", "baca", "banana", "nana"]

            check_column_type_error_handling action =
                tester = check_empty ["ix", "X", "Y"]
                check_problem problem =
                    problem.should_be_a Invalid_Value_Type.Invalid_Value_Type_Data
                    problem.expected . should_equal Value_Type.Char
                warnings_tester warnings =
                    (warnings.length >= 1).should_be_true
                    check_problem warnings.first
                error_tester result = check_problem result.catch
                Problems.test_advanced_problem_handling action error_tester warnings_tester tester
            check_column_type_error_handling (t.filter "X" (Filter_Condition.Starts_With (t.at "ix")) on_problems=_)
            check_column_type_error_handling (t.filter "X" (Filter_Condition.Ends_With (t.at "ix")) on_problems=_)
            check_column_type_error_handling (t.filter "X" (Filter_Condition.Contains (t.at "ix")) on_problems=_)
            check_column_type_error_handling (t.filter "ix" (Filter_Condition.Starts_With "A") on_problems=_)
            check_column_type_error_handling (t.filter "ix" (Filter_Condition.Ends_With "A") on_problems=_)
            check_column_type_error_handling (t.filter "ix" (Filter_Condition.Contains "A") on_problems=_)

            check_scalar_type_error_handling name action =
                tester = check_empty ["ix", "X", "Y"]
                problems = [Type_Error_Data Text Integer name]
                Problems.test_problem_handling action problems tester
            check_scalar_type_error_handling "prefix" (t.filter "X" (Filter_Condition.Starts_With 42) on_problems=_)
            check_scalar_type_error_handling "suffix" (t.filter "X" (Filter_Condition.Ends_With 42) on_problems=_)
            check_scalar_type_error_handling "substring" (t.filter "X" (Filter_Condition.Contains 42) on_problems=_)

        Test.specify "by nulls" <|
            t = table_builder [["ix", [1, 2, 3, 4]], ["X", [Nothing, 1, Nothing, 4]]]
            t1 = t.filter "X" (Filter_Condition.Is_Nothing) on_problems=Report_Error
            t1.at "ix" . to_vector . should_equal [1, 3]
            t1.at "X" . to_vector . should_equal [Nothing, Nothing]

            t2 = t.filter "X" (Filter_Condition.Not_Nothing) on_problems=Report_Error
            t2.at "ix" . to_vector . should_equal [2, 4]
            t2.at "X" . to_vector . should_equal [1, 4]

        Test.specify "by a boolean mask" <|
            t = table_builder [["ix", [1, 2, 3, 4, 5]], ["b", [True, False, Nothing, True, True]]]
            t.filter "b" on_problems=Report_Error . at "ix" . to_vector . should_equal [1, 4, 5]
            t.filter "b" Filter_Condition.Is_False on_problems=Report_Error . at "ix" . to_vector . should_equal [2]

            tester = check_empty ["ix", "b"]
            check_problem problem =
                problem.should_be_a Invalid_Value_Type.Invalid_Value_Type_Data
                problem.expected . should_equal Value_Type.Boolean
            warnings_tester warnings =
                (warnings.length >= 1).should_be_true
                check_problem warnings.first
            error_tester result = check_problem result.catch
            Problems.test_advanced_problem_handling (t.filter "ix" Filter_Condition.Is_True on_problems=_) error_tester warnings_tester tester
            Problems.test_advanced_problem_handling (t.filter "ix" Filter_Condition.Is_False on_problems=_) error_tester warnings_tester tester

        Test.specify "by a custom expression built from table's columns" <|
            t = table_builder [["ix", [1, 2, 3, 4, 5]], ["X", [10, 20, 13, 4, 5]], ["Y", [0, -100, 8, 2, 5]]]
            t.filter (t.at "X" + t.at "Y" > 9) on_problems=Report_Error . at "ix" . to_vector . should_equal [1, 3, 5]

        Test.specify "should handle selection errors: unknown column name" <|
            t = table_builder [["X", [10, 20, 13, 4, 5]]]
            action = t.filter "unknown column" on_problems=_
            tester table =
                table.at "X" . to_vector . should_equal (t.at "X" . to_vector)
            problems = [No_Such_Column_Error_Data "unknown column"]
            Problems.test_problem_handling action problems tester

        Test.specify "should handle selection errors: out of bounds index" <|
            t = table_builder [["X", [10, 20, 13, 4, 5]]]
            action = t.filter 4 on_problems=_
            tester table =
                table.at "X" . to_vector . should_equal (t.at "X" . to_vector)
            problems = [Index_Out_Of_Bounds_Error_Data 4 1]
            Problems.test_problem_handling action problems tester
