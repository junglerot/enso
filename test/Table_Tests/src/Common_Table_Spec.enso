from Standard.Base import all
from Standard.Base.Data.Index_Sub_Range import While, Sample, Every
import Standard.Base.Data.Index_Sub_Range

from Standard.Table import Column_Name_Mapping, Sort_Column, Sort_Column_Selector
from Standard.Table.Errors as Table_Errors import all
from Standard.Table.Data.Column_Selector import all
from Standard.Table.Data.Position import all

import Standard.Test
import Standard.Test.Problems

from project.Util import all

type Test_Selection supports_case_sensitive_columns=True order_by=True natural_ordering=False case_insensitive_ordering=True order_by_unicode_normalization_by_default=False case_insensitive_ascii_only=False take_drop=True

## A common test suite for shared operations on the Table API.

   It is meant to be able to be re-used by tests for the in-memory and various
   database backends.

   Arguments:
   - prefix: A prefix to attach to the names of test groups, for easier
     identification.
   - table_builder: A function which takes a list of column descriptions and
     builds a Table using the backend that is meant to be tested. Each column
     description is a triple of column name, column type and a vector containing
     column elements.
   - test_selection: A selection of which suites should be run. Can be used to
     skip checks for backends which do not support particular features.
   - pending: An optional mark to disable all test groups. Can be used to
     indicate that some tests are disabled due to missing test setup.

   TODO [RW] the Any in return type of the builder should ideally be replaced with the Table interface, once that is supported.
spec prefix table_builder test_selection pending=Nothing =
    table =
        col1 = ["foo", [1,2,3]]
        col2 = ["bar", [4,5,6]]
        col3 = ["Baz", [7,8,9]]
        col4 = ["foo_1", [10,11,12]]
        col5 = ["foo_2", [13,14,15]]
        col6 = ["ab.+123", [16,17,18]]
        col7 = ["abcd123", [19,20,21]]
        table_builder [col1, col2, col3, col4, col5, col6, col7]

    expect_column_names names table =
        table.columns . map .name . should_equal names frames_to_skip=2

    Test.group prefix+"Table.at" pending=pending <|
        Test.specify "should allow selecting columns by name" <|
            column_1 = table.at "bar"
            column_1.name . should_equal "bar"
            column_1.to_vector . should_equal [4, 5, 6]

            table.at "nonexistent column name" . should_fail_with No_Such_Column_Error
        Test.specify "should allow selecting columns by index" <|
            column_1 = table.at
            column_1.name . should_equal "foo"
            column_1.to_vector . should_equal [1, 2, 3]

            column_2 = table.at 2
            column_2.name . should_equal "Baz"
            column_2.to_vector . should_equal [7, 8, 9]

            column_3 = table.at -1
            column_3.name . should_equal "abcd123"
            column_3.to_vector . should_equal [19, 20, 21]

            table.at 100 . should_fail_with Index_Out_Of_Bounds_Error

    Test.group prefix+"Table.column_count" pending=pending <|
        Test.specify "should allow getting the column count" <|
            table.column_count . should_equal 7

    Test.group prefix+"Table.select_columns" pending=pending <|
        Test.specify "should work as shown in the doc examples" <|
            expect_column_names ["foo", "bar"] <| table.select_columns (By_Name ["bar", "foo"])
            expect_column_names ["bar", "Baz", "foo_1", "foo_2"] <| table.select_columns (By_Name ["foo.+", "b.*"] (Regex_Matcher case_sensitive=Case_Insensitive))
            expect_column_names ["abcd123", "foo", "bar"] <| table.select_columns (By_Index [-1, 0, 1]) reorder=True

            column1 = table.at "foo_1"
            column2 = table.at "Baz"
            expect_column_names ["Baz", "foo_1"] <| table.select_columns (By_Column [column1, column2])

        Test.specify "should allow to reorder columns if asked to" <|
            table_2 = table.select_columns (By_Name ["bar", "foo"]) reorder=True
            expect_column_names ["bar", "foo"] table_2
            table_2 . at "bar" . to_vector . should_equal [4,5,6]
            table_2 . at "foo" . to_vector . should_equal [1,2,3]

        Test.specify "should correctly handle regex matching" <|
            expect_column_names ["foo"] <| table.select_columns (By_Name ["foo"] Regex_Matcher)
            expect_column_names ["ab.+123", "abcd123"] <| table.select_columns (By_Name ["a.*"] Regex_Matcher)
            expect_column_names ["ab.+123", "abcd123"] <| table.select_columns (By_Name ["ab.+123"] Regex_Matcher)
            expect_column_names ["ab.+123"] <| table.select_columns (By_Name ["ab.+123"])
            expect_column_names ["abcd123"] <| table.select_columns (By_Name ["abcd123"] Regex_Matcher)

        Test.specify "should allow negative indices" <|
            expect_column_names ["foo", "bar", "foo_2"] <| table.select_columns (By_Index [-3, 0, 1])

        if test_selection.supports_case_sensitive_columns then
            Test.specify "should correctly handle exact matches matching multiple names due to case insensitivity" <|
                table =
                    col1 = ["foo", [1,2,3]]
                    col2 = ["bar", [4,5,6]]
                    col3 = ["Bar", [7,8,9]]
                    table_builder [col1, col2, col3]
                expect_column_names ["bar", "Bar"] <| table.select_columns (By_Name ["bar"] (Text_Matcher Case_Insensitive))

        Test.specify "should correctly handle regexes matching multiple names" <|
            expect_column_names ["foo", "bar", "foo_1", "foo_2"] <| table.select_columns (By_Name ["b.*", "f.+"] Regex_Matcher)
            expect_column_names ["bar", "foo", "foo_1", "foo_2"] <| table.select_columns (By_Name ["b.*", "f.+"] Regex_Matcher) reorder=True

        Test.specify "should correctly handle problems: out of bounds indices" <|
            selector = By_Index [1, 0, 100, -200, 300]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo", "bar"]
            problems = [Column_Indexes_Out_Of_Range [100, -200, 300]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate indices" <|
            selector = By_Index [0, 0, 0]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo"]
            problems = [Duplicate_Column_Selectors [0, 0]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: aliased indices" <|
            selector = By_Index [0, -7, -6, 1]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo", "bar"]
            problems = [Input_Indices_Already_Matched [-7, 1]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate names" <|
            selector = By_Name ["foo", "foo"]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo"]
            problems = [Duplicate_Column_Selectors ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate matches due to case insensitivity" pending="TODO needs fixing" <|
            selector = By_Name ["FOO", "foo"] (Text_Matcher case_sensitive=Case_Insensitive)
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo"]
            problems = [Duplicate_Column_Selectors ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate matches due to case insensitivity" pending="TODO needs fixing" <|
            selector = By_Name.new ["FOO", "foo"] (Text_Matcher case_sensitive=Case_Insensitive)
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo"]
            problems = [Duplicate_Column_Selectors ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched names" <|
            weird_name = '.*?-!@#!"'
            selector = By_Name ["foo", "hmm", weird_name]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo"]
            problems = [Missing_Input_Columns ["hmm", weird_name]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate columns" <|
            foo = table.at "foo"
            selector = By_Column [foo, foo]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names ["foo"]
            problems = [Duplicate_Column_Selectors ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched columns" <|
            table_2 = table_builder [["foo", [0,0,0]], ["weird_column", [0,0,0]]]
            foo = table_2.at "foo"
            weird_column = table_2.at "weird_column"
            bar = table.at "bar"

            selector = By_Column [bar, weird_column, foo]
            action = table.select_columns selector reorder=True on_problems=_
            tester = expect_column_names ["bar", "foo"]
            problems = [Missing_Input_Columns ["weird_column"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: no columns in the output" <|
            selector = By_Name []
            action = table.select_columns selector on_problems=_
            tester = expect_column_names []
            problems = [No_Output_Columns]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle multiple problems" <|
            selector = By_Name ["hmmm"]
            action = table.select_columns selector on_problems=_
            tester = expect_column_names []
            problems = [Missing_Input_Columns ["hmmm"], No_Output_Columns]
            Problems.test_problem_handling action problems tester

            action_2 = table.select_columns (By_Index [0, -7, 0, 100]) on_problems=_
            problems_2 = [Column_Indexes_Out_Of_Range [100], Duplicate_Column_Selectors [0], Input_Indices_Already_Matched [-7]]
            tester_2 = expect_column_names ["foo"]
            Problems.test_problem_handling action_2 problems_2 tester_2

    Test.group prefix+"Table.remove_columns" pending=pending <|
        Test.specify "should work as shown in the doc examples" <|
            expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123"] <| table.remove_columns (By_Name ["bar", "foo"])
            expect_column_names ["foo", "ab.+123", "abcd123"] <| table.remove_columns (By_Name ["foo.+", "b.*"] (Regex_Matcher case_sensitive=Case_Insensitive))
            expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123"] <| table.remove_columns (By_Index [-1, 0, 1])

            column1 = table.at "foo_1"
            column2 = table.at "Baz"
            expect_column_names ["foo", "bar", "foo_2", "ab.+123", "abcd123"] <| table.remove_columns (By_Column [column1, column2])

        Test.specify "should correctly handle regex matching" <|
            last_ones = table.columns.tail.map .name
            expect_column_names last_ones <| table.remove_columns (By_Name ["foo"] Regex_Matcher)
            first_ones = ["foo", "bar", "Baz", "foo_1", "foo_2"]
            expect_column_names first_ones <| table.remove_columns (By_Name ["a.*"] Regex_Matcher)
            expect_column_names first_ones <| table.remove_columns (By_Name ["ab.+123"] Regex_Matcher)
            expect_column_names first_ones+["abcd123"] <| table.remove_columns (By_Name ["ab.+123"])
            expect_column_names first_ones+["ab.+123"] <| table.remove_columns (By_Name ["abcd123"] Regex_Matcher)

        Test.specify "should allow negative indices" <|
            expect_column_names ["Baz", "foo_1", "ab.+123"] <| table.remove_columns (By_Index [-1, -3, 0, 1])

        if test_selection.supports_case_sensitive_columns then
            Test.specify "should correctly handle exact matches matching multiple names due to case insensitivity" <|
                table =
                    col1 = ["foo", [1,2,3]]
                    col2 = ["bar", [4,5,6]]
                    col3 = ["Bar", [7,8,9]]
                    table_builder [col1, col2, col3]
                expect_column_names ["foo"] <| table.remove_columns (By_Name ["bar"] (Text_Matcher Case_Insensitive))

        Test.specify "should correctly handle regexes matching multiple names" <|
            expect_column_names ["Baz", "ab.+123", "abcd123"] <| table.remove_columns (By_Name ["b.*", "f.+"] Regex_Matcher)

        Test.specify "should correctly handle problems: out of bounds indices" <|
            selector = By_Index [1, 0, 100, -200, 300]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Column_Indexes_Out_Of_Range [100, -200, 300]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate indices" <|
            selector = By_Index [0, 0, 0]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Duplicate_Column_Selectors [0, 0]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: aliased indices" <|
            selector = By_Index [0, -7, -6, 1]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Input_Indices_Already_Matched [-7, 1]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate names" <|
            selector = By_Name ["foo", "foo"]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Duplicate_Column_Selectors ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate matches due to case insensitivity" pending="TODO needs fixing" <|
            selector = By_Name ["FOO", "foo"] (Text_Matcher case_sensitive=Case_Insensitive)
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Duplicate_Column_Selectors ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate matches due to case insensitivity" pending="TODO needs fixing" <|
            selector = By_Name.new ["FOO", "foo"] (Text_Matcher case_sensitive=Case_Insensitive)
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Duplicate_Column_Selectors ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched names" <|
            weird_name = '.*?-!@#!"'
            selector = By_Name ["foo", "hmm", weird_name]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Missing_Input_Columns ["hmm", weird_name]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate columns" <|
            foo = table.at "foo"
            selector = By_Column [foo, foo]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Duplicate_Column_Selectors ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched columns" <|
            table_2 = table_builder [["foo", [0,0,0]], ["weird_column", [0,0,0]]]
            foo = table_2.at "foo"
            weird_column = table_2.at "weird_column"
            bar = table.at "bar"

            selector = By_Column [bar, weird_column, foo]
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Missing_Input_Columns ["weird_column"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: no columns in the output" <|
            selector = By_Name [".*"] Regex_Matcher
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names []
            problems = [No_Output_Columns]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle multiple problems" <|
            selector = By_Name [".*", "hmmm"] Regex_Matcher
            action = table.remove_columns selector on_problems=_
            tester = expect_column_names []
            problems = [Missing_Input_Columns ["hmmm"], No_Output_Columns]
            Problems.test_problem_handling action problems tester

            action_2 = table.remove_columns (By_Index [0, -7, 0, 100]) on_problems=_
            problems_2 = [Column_Indexes_Out_Of_Range [100], Duplicate_Column_Selectors [0], Input_Indices_Already_Matched [-7]]
            tester_2 = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            Problems.test_problem_handling action_2 problems_2 tester_2

    Test.group prefix+"Table.reorder_columns" pending=pending <|
        Test.specify "should work as shown in the doc examples" <|
            expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"] <| table.reorder_columns (By_Name ["foo"]) position=After_Other_Columns
            expect_column_names ["foo_1", "foo_2", "bar", "Baz", "foo", "ab.+123", "abcd123"] <| table.reorder_columns (By_Name ["foo.+", "b.*"] (Regex_Matcher case_sensitive=Case_Insensitive))
            expect_column_names ["bar", "foo", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"] <| table.reorder_columns (By_Index [1, 0]) position=Before_Other_Columns
            expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"] <| table.reorder_columns (By_Index [0]) position=After_Other_Columns

            column1 = table.at "foo_1"
            column2 = table.at "Baz"
            expect_column_names ["foo_1", "Baz", "foo", "bar", "foo_2", "ab.+123", "abcd123"] <| table.reorder_columns (By_Column [column1, column2])

        Test.specify "should correctly handle regex matching" <|
            expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"] <| table.reorder_columns (By_Name ["foo"] Regex_Matcher) position=After_Other_Columns
            rest = ["foo", "bar", "Baz", "foo_1", "foo_2"]
            expect_column_names ["ab.+123", "abcd123"]+rest <| table.reorder_columns (By_Name ["a.*"] Regex_Matcher)
            expect_column_names ["ab.+123", "abcd123"]+rest <| table.reorder_columns (By_Name ["ab.+123"] Regex_Matcher)
            expect_column_names ["ab.+123"]+rest+["abcd123"] <| table.reorder_columns (By_Name ["ab.+123"])
            expect_column_names ["abcd123"]+rest+["ab.+123"] <| table.reorder_columns (By_Name ["abcd123"] Regex_Matcher)

        Test.specify "should allow negative indices" <|
            expect_column_names ["abcd123", "foo_2", "foo", "bar", "Baz", "foo_1", "ab.+123"] <| table.reorder_columns (By_Index [-1, -3, 0, 1])

        if test_selection.supports_case_sensitive_columns then
            Test.specify "should correctly handle exact matches matching multiple names due to case insensitivity" <|
                table =
                    col1 = ["foo", [1,2,3]]
                    col2 = ["bar", [4,5,6]]
                    col3 = ["Bar", [7,8,9]]
                    table_builder [col1, col2, col3]
                expect_column_names ["bar", "Bar", "foo"] <| table.reorder_columns (By_Name ["bar"] (Text_Matcher Case_Insensitive))

        Test.specify "should correctly handle regexes matching multiple names" <|
            expect_column_names ["bar", "foo", "foo_1", "foo_2", "Baz", "ab.+123", "abcd123"] <| table.reorder_columns (By_Name ["b.*", "f.+"] Regex_Matcher)

        Test.specify "should correctly handle problems: out of bounds indices" <|
            selector = By_Index [1, 0, 100, -200, 300]
            action = table.reorder_columns selector on_problems=_
            tester = expect_column_names ["bar", "foo", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123"]
            problems = [Column_Indexes_Out_Of_Range [100, -200, 300]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate indices" <|
            selector = By_Index [0, 0, 0]
            action = table.reorder_columns selector position=After_Other_Columns on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"]
            problems = [Duplicate_Column_Selectors [0, 0]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: aliased indices" <|
            selector = By_Index [0, -7, -6, 1]
            action = table.reorder_columns selector position=After_Other_Columns on_problems=_
            tester = expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo", "bar"]
            problems = [Input_Indices_Already_Matched [-7, 1]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate names" <|
            selector = By_Name ["foo", "foo"]
            action = table.reorder_columns selector position=After_Other_Columns on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"]
            problems = [Duplicate_Column_Selectors ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched names" <|
            weird_name = '.*?-!@#!"'
            selector = By_Name ["foo", "hmm", weird_name]
            action = table.reorder_columns selector position=After_Other_Columns on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"]
            problems = [Missing_Input_Columns ["hmm", weird_name]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate columns" <|
            foo = table.at "foo"
            selector = By_Column [foo, foo]
            action = table.reorder_columns selector position=After_Other_Columns on_problems=_
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"]
            problems = [Duplicate_Column_Selectors ["foo"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched columns" <|
            table_2 = table_builder [["foo", [0,0,0]], ["weird_column", [0,0,0]]]
            foo = table_2.at "foo"
            weird_column = table_2.at "weird_column"
            bar = table.at "bar"

            selector = By_Column [bar, weird_column, foo]
            action = table.reorder_columns selector position=After_Other_Columns on_problems=_
            tester = expect_column_names ["Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "bar", "foo"]
            problems = [Missing_Input_Columns ["weird_column"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle multiple problems" <|
            action = table.reorder_columns (By_Index [0, -7, 0, 100]) position=After_Other_Columns on_problems=_
            problems = [Column_Indexes_Out_Of_Range [100], Duplicate_Column_Selectors [0], Input_Indices_Already_Matched [-7]]
            tester = expect_column_names ["bar", "Baz", "foo_1", "foo_2", "ab.+123", "abcd123", "foo"]
            Problems.test_problem_handling action problems tester

    Test.group prefix+"Table.sort_columns" pending=pending <|
        table =
            col1 = ["foo_21", [1,2,3]]
            col2 = ["foo_100", [4,5,6]]
            col3 = ["foo_1", [7,8,9]]
            col4 = ["Foo_2", [10,11,12]]
            col5 = ["foo_3", [13,14,15]]
            col6 = ["foo_001", [16,17,18]]
            col7 = ["bar", [19,20,21]]
            table_builder [col1, col2, col3, col4, col5, col6, col7]

        Test.specify "should work as shown in the doc examples" <|
            sorted = table.sort_columns
            expect_column_names ["Foo_2", "bar", "foo_001", "foo_1", "foo_100", "foo_21", "foo_3"] sorted
            sorted.columns.first.to_vector . should_equal [10,11,12]

            expect_column_names ["bar", "foo_001", "foo_1", "Foo_2", "foo_3", "foo_21", "foo_100"] <| table.sort_columns text_ordering=(Text_Ordering sort_digits_as_numbers=True case_sensitive=Case_Insensitive)
            expect_column_names ["foo_3", "foo_21", "foo_100", "foo_1", "foo_001", "bar", "Foo_2"] <| table.sort_columns Sort_Direction.Descending

        Test.specify "should correctly handle case-insensitive sorting" <|
            expect_column_names ["bar", "foo_001", "foo_1", "foo_100", "Foo_2", "foo_21", "foo_3"] <| table.sort_columns text_ordering=(Text_Ordering case_sensitive=Case_Insensitive)

        Test.specify "should correctly handle natural order sorting" <|
            expect_column_names ["Foo_2", "bar", "foo_001", "foo_1", "foo_3", "foo_21", "foo_100"] <| table.sort_columns text_ordering=(Text_Ordering sort_digits_as_numbers=True)

        Test.specify "should correctly handle various combinations of options" <|
            expect_column_names ["foo_100", "foo_21", "foo_3", "Foo_2", "foo_1", "foo_001", "bar"] <| table.sort_columns direction=Sort_Direction.Descending text_ordering=(Text_Ordering sort_digits_as_numbers=True case_sensitive=Case_Insensitive)

    Test.group prefix+"Table.rename_columns" pending=pending <|
        table =
            col1 = ["alpha", [1,2,3]]
            col2 = ["beta", [4,5,6]]
            col3 = ["gamma", [16,17,18]]
            col4 = ["delta", [19,20,21]]
            table_builder [col1, col2, col3, col4]

        Test.specify "should work as shown in the doc examples" <|
            expect_column_names ["FirstColumn", "beta", "gamma", "delta"] <|
                table.rename_columns (Column_Name_Mapping.By_Position ["FirstColumn"])

        Test.specify "should work by index" <|
            map = Map.from_vector [[0, "FirstColumn"], [-2, "Another"]]
            expect_column_names ["FirstColumn", "beta", "Another", "delta"] <|
                table.rename_columns (Column_Name_Mapping.By_Index map)

        Test.specify "should work by position" <|
            vec = ["one", "two", "three"]
            expect_column_names ["one", "two", "three", "delta"] <|
                table.rename_columns (Column_Name_Mapping.By_Position vec)

        Test.specify "should work by name" <|
            map = Map.from_vector [["alpha", "FirstColumn"], ["delta", "Another"]]
            expect_column_names ["FirstColumn", "beta", "gamma", "Another"] <|
                table.rename_columns (Column_Name_Mapping.By_Name map (Text_Matcher True))

        Test.specify "should work by name case-insensitively" <|
            map = Map.from_vector [["ALPHA", "FirstColumn"], ["DELTA", "Another"]]
            expect_column_names ["FirstColumn", "beta", "gamma", "Another"] <|
                table.rename_columns (Column_Name_Mapping.By_Name map (Text_Matcher Case_Insensitive))

        Test.specify "should work by name using regex" <|
            map = Map.from_vector [["a.*", "FirstColumn"]]
            expect_column_names ["FirstColumn", "beta", "gamma", "delta"] <|
                table.rename_columns (Column_Name_Mapping.By_Name map Regex_Matcher)

        Test.specify "should work by name using regex substitution" <|
            map = Map.from_vector [["a(.*)", "$1"]]
            expect_column_names ["lpha", "beta", "gamma", "delta"] <|
                table.rename_columns (Column_Name_Mapping.By_Name map Regex_Matcher)

        Test.specify "should work by column" <|
            vec = [[table.at "alpha", "FirstColumn"], [table.at "delta", "Another"]]
            expect_column_names ["FirstColumn", "beta", "gamma", "Another"] <|
                table.rename_columns (Column_Name_Mapping.By_Column vec)

        Test.specify "should correctly handle problems: duplicate columns" <|
            map = Column_Name_Mapping.By_Column [[table.at "alpha", "FirstColumn"], [table.at "alpha", "Another"]]
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["FirstColumn", "beta", "gamma", "delta"]
            problems = [Duplicate_Column_Selectors ["alpha"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched names" <|
            weird_name = '.*?-!@#!"'
            map = Column_Name_Mapping.By_Name (Map.from_vector [["alpha", "FirstColumn"], ["omicron", "Another"], [weird_name, "Fixed"]])
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["FirstColumn", "beta", "gamma", "delta"]
            problems = [Missing_Input_Columns [weird_name, "omicron"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: out of bounds indices" <|
            map = Column_Name_Mapping.By_Index (Map.from_vector [[0, "FirstColumn"], [-1, "Another"], [100, "Boo"], [-200, "Nothing"], [300, "Here"]])
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["FirstColumn", "beta", "gamma", "Another"]
            problems = [Column_Indexes_Out_Of_Range [-200, 100, 300]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: aliased indices" <|
            map = Column_Name_Mapping.By_Index (Map.from_vector [[1, "FirstColumn"], [-3, "Another"]])
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["alpha", "Another", "gamma", "delta"]
            problems = [Input_Indices_Already_Matched [1]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: invalid names ''" <|
            map = Column_Name_Mapping.By_Index (Map.from_vector [[1, ""]])
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["alpha", "Column_1", "gamma", "delta"]
            problems = [Invalid_Output_Column_Names [""]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: invalid names Nothing" <|
            map = Column_Name_Mapping.By_Position ["alpha", Nothing]
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["alpha", "Column_1", "gamma", "delta"]
            problems = [Invalid_Output_Column_Names [Nothing]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate names" <|
            map = Column_Name_Mapping.By_Position ["Test", "Test", "Test", "Test"]
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["Test", "Test_1", "Test_2", "Test_3"]
            problems = [Duplicate_Output_Column_Names ["Test", "Test", "Test"]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: too many input names" <|
            map = Column_Name_Mapping.By_Position ["A", "B", "C", "D", "E", "F"]
            action = table.rename_columns map on_problems=_
            tester = expect_column_names ["A", "B", "C", "D"]
            problems = [Too_Many_Column_Names_Provided ["E", "F"]]
            Problems.test_problem_handling action problems tester

    order_by_pending = if pending.is_nothing.not then pending else
        if test_selection.order_by.not then "TODO: order_by is not yet supported by this backend." else
            Nothing
    Test.group prefix+"Table.order_by" pending=order_by_pending <|
        table =
            col1 = ["alpha", [3, 2, 1, 0]]
            col2 = ["beta", ["a", "b", "a", "b"]]
            col3 = ["gamma", [1, 2, 3, 4]]
            col4 = ["delta", ["a10", "a1", "a2", "a03"]]
            col5 = ["eta", ["Beta", "alpha", "bądź", "Aleph"]]
            col6 = ["xi", [1.0, 1.5, Nothing, 0.5]]
            col7 = ["psi", [Nothing, "c01", "c10", "C2"]]
            col8 = ["phi", ["śc", Nothing, 's\u0301b', "śa"]]
            col9 = ["tau", [32.0, 0.5, -0.1, 1.6]]
            col10 = ["rho", ["BB", Nothing, Nothing, "B"]]
            table_builder [col1, col2, col3, col4, col5, col6, col7, col8, col9, col10]

        Test.specify "should work as shown in the doc examples" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name ["alpha"])
            t1.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
            t1.at "gamma" . to_vector . should_equal [4, 3, 2, 1]

            t2 = table.order_by (Sort_Column_Selector.By_Index [1, Sort_Column.Index -8 Sort_Direction.Descending])
            t2.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t2.at "gamma" . to_vector . should_equal [3, 1, 4, 2]
            t2.at "alpha" . to_vector . should_equal [1, 3, 0, 2]

        Test.specify "should correctly handle regexes matching multiple names" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name ".*ta"  Sort_Direction.Descending] Regex_Matcher)
            t1.at "beta" . to_vector . should_equal ["b", "b", "a", "a"]
            t1.at "delta" . to_vector . should_equal ["a1", "a03", "a2", "a10"]
            t1.at "gamma" . to_vector . should_equal [2, 4, 3, 1]

        Test.specify "should correctly handle problems: out of bounds indices" <|
            selector = Sort_Column_Selector.By_Index [0, 100, Sort_Column.Index -200, Sort_Column.Index 300]
            action = table.order_by selector on_problems=_
            tester table =
                table.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
                table.at "gamma" . to_vector . should_equal [4, 3, 2, 1]
            problems = [Column_Indexes_Out_Of_Range [100, -200, 300]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate indices" <|
            selector = Sort_Column_Selector.By_Index [0, Sort_Column.Index 0, Sort_Column.Index 0 Sort_Direction.Descending]
            action = table.order_by selector on_problems=_
            tester table =
                table.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
                table.at "gamma" . to_vector . should_equal [4, 3, 2, 1]
            problems = [Duplicate_Column_Selectors [Sort_Column.Index 0, Sort_Column.Index 0 Sort_Direction.Descending]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: aliased indices" <|
            selector = Sort_Column_Selector.By_Index [1, Sort_Column.Index -9 Sort_Direction.Descending, Sort_Column.Index -8 Sort_Direction.Descending, Sort_Column.Index 2 Sort_Direction.Ascending]
            action = table.order_by selector on_problems=_
            tester table =
                table.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
                table.at "gamma" . to_vector . should_equal [3, 1, 4, 2]
                table.at "alpha" . to_vector . should_equal [1, 3, 0, 2]
            problems = [Input_Indices_Already_Matched [Sort_Column.Index -9 Sort_Direction.Descending, Sort_Column.Index 2]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate names" <|
            selector = Sort_Column_Selector.By_Name ["alpha", Sort_Column.Name "alpha" Sort_Direction.Descending]
            action = table.order_by selector on_problems=_
            tester table =
                table.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
                table.at "gamma" . to_vector . should_equal [4, 3, 2, 1]
            problems = [Column_Matched_By_Multiple_Selectors "alpha" [Sort_Column.Name "alpha", Sort_Column.Name "alpha" Sort_Direction.Descending]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate matches due to case insensitivity" <|
            selector = Sort_Column_Selector.By_Name [Sort_Column.Name "ALPHA", Sort_Column.Name "alpha" Sort_Direction.Descending] (Text_Matcher case_sensitive=Case_Insensitive)
            action = table.order_by selector on_problems=_
            tester table =
                table.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
                table.at "gamma" . to_vector . should_equal [4, 3, 2, 1]
            problems = [Column_Matched_By_Multiple_Selectors "alpha" [Sort_Column.Name "ALPHA", Sort_Column.Name "alpha" Sort_Direction.Descending]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched names" <|
            weird_name = '.*?-!@#!"'
            selector = Sort_Column_Selector.By_Name [Sort_Column.Name "alpha", "hmm", Sort_Column.Name weird_name]
            action = table.order_by selector on_problems=_
            tester table =
                table.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
                table.at "gamma" . to_vector . should_equal [4, 3, 2, 1]
            problems = [Missing_Input_Columns [Sort_Column.Name "hmm", Sort_Column.Name weird_name]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: unmatched columns" <|
            table_2 = table_builder [["alpha", [0,0,0]], ["weird_column", [0,0,0]]]
            foo = table_2.at "alpha"
            weird_column = table_2.at "weird_column"
            bar = table.at "beta"

            selector = Sort_Column_Selector.By_Column [bar, weird_column, Sort_Column.Column foo]
            problem = table.order_by selector on_problems=Problem_Behavior.Report_Error . catch
            problem.should_be_a Missing_Input_Columns
            problem.criteria.map (selector-> selector.column.name) . should_equal ["weird_column"]

            t2 = table.order_by selector on_problems=Problem_Behavior.Ignore
            t2.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t2.at "alpha" . to_vector . should_equal [1, 3, 0, 2]
            t2.at "gamma" . to_vector . should_equal [3, 1, 4, 2]

        Test.specify "should report a problem if no columns are selected for ordering" <|
            action = table.order_by (Sort_Column_Selector.By_Name []) on_problems=_
            tester t2 =
                t2.at "alpha" . to_vector . should_equal (table.at "alpha" . to_vector)
            problems = [No_Input_Columns_Selected]
            Problems.test_problem_handling action problems tester

        Test.specify "should stack consecutive ordering operations" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "alpha"])
            t1.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
            t1.at "beta" . to_vector . should_equal ["b", "a", "b", "a"]

            # Now we reverse the order
            t2 = t1.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "alpha" Sort_Direction.Descending])
            t2.at "alpha" . to_vector . should_equal [3, 2, 1, 0]
            t2.at "beta" . to_vector . should_equal ["a", "b", "a", "b"]

            # Now we add another primary ordering, but the order from t1/t2 is kept for tie breaking.
            t3 = t1.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "beta"])
            t3.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t3.at "alpha" . to_vector . should_equal [1, 3, 0, 2]

            t4 = t2.order_by (Sort_Column_Selector.By_Name ["beta"])
            t4.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t4.at "alpha" . to_vector . should_equal [3, 1, 2, 0]

        Test.specify "should give priority to the first selected column and use the next ones for breaking ties" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name ["beta", Sort_Column.Name "alpha" Sort_Direction.Ascending])
            t1.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t1.at "alpha" . to_vector . should_equal [1, 3, 0, 2]
            t1.at "gamma" . to_vector . should_equal [3, 1, 4, 2]

            t2 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "beta", Sort_Column.Name "alpha" Sort_Direction.Descending])
            t2.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t2.at "alpha" . to_vector . should_equal [3, 1, 2, 0]
            t2.at "gamma" . to_vector . should_equal [1, 3, 2, 4]

            t3 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "alpha", Sort_Column.Name "beta"])
            t3.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
            t3.at "beta" . to_vector . should_equal ["b", "a", "b", "a"]
            t3.at "gamma" . to_vector . should_equal [4, 3, 2, 1]

            t4 = table.order_by (Sort_Column_Selector.By_Index [1, Sort_Column.Index 0 Sort_Direction.Ascending])
            t4.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t4.at "alpha" . to_vector . should_equal [1, 3, 0, 2]
            t4.at "gamma" . to_vector . should_equal [3, 1, 4, 2]

            t5 = table.order_by (Sort_Column_Selector.By_Column [table.at "beta", Sort_Column.Column (table.at "alpha") Sort_Direction.Ascending])
            t5.at "beta" . to_vector . should_equal ["a", "a", "b", "b"]
            t5.at "alpha" . to_vector . should_equal [1, 3, 0, 2]
            t5.at "gamma" . to_vector . should_equal [3, 1, 4, 2]

        Test.specify "should deal with real numbers" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name ["tau"])
            t1.at "tau" . to_vector . should_equal [-0.1, 0.5, 1.6, 32.0]
            t1.at "alpha" . to_vector . should_equal [1, 2, 0, 3]

        Test.specify "should deal with nulls" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name ["xi"])
            t1.at "xi" . to_vector . should_equal [Nothing, 0.5, 1.0, 1.5]
            t1.at "alpha" . to_vector . should_equal [1, 0, 3, 2]

            t2 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "rho"])
            t2.at "rho" . to_vector . should_equal [Nothing, Nothing, "B", "BB"]

            t3 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "rho" Sort_Direction.Descending])
            t3.at "rho" . to_vector . should_equal ["BB", "B", Nothing, Nothing]

        Test.specify "should behave as expected with Unicode normalization, depending on the defaults settings" <|
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "phi"])
            case test_selection.order_by_unicode_normalization_by_default of
                True ->
                    t1.at "phi" . to_vector . should_equal [Nothing, "śa", 's\u0301b', "śc"]
                    t1.at "alpha" . to_vector . should_equal [2, 0, 1, 3]
                False ->
                    t1.at "phi" . to_vector . should_equal [Nothing, 's\u0301b', "śa", "śc"]
                    t1.at "alpha" . to_vector . should_equal [2, 1, 0, 3]

        Test.specify "should support natural ordering" pending=(if test_selection.natural_ordering.not then "Natural ordering is not supported.") <|
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "delta"]) text_ordering=(Text_Ordering sort_digits_as_numbers=True)
            t1.at "delta" . to_vector . should_equal ["a1", "a2", "a03", "a10"]
            t1.at "alpha" . to_vector . should_equal [2, 1, 0, 3]

            t2 = table.order_by (Sort_Column_Selector.By_Name ["delta"]) text_ordering=(Text_Ordering sort_digits_as_numbers=False)
            t2.at "delta" . to_vector . should_equal ["a03", "a1", "a10", "a2"]
            t2.at "alpha" . to_vector . should_equal [0, 2, 3, 1]

        Test.specify "should support case insensitive ordering" pending=(if test_selection.case_insensitive_ordering.not then "Case insensitive ordering is not supported.") <|
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "eta"]) text_ordering=(Text_Ordering case_sensitive=Case_Insensitive)
            expected = case test_selection.case_insensitive_ascii_only of
                True -> ["Aleph", "alpha", "Beta", "bądź"]
                False -> ["Aleph", "alpha", "bądź", "Beta"]
            t1.at "eta" . to_vector . should_equal expected

            t2 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "eta"]) text_ordering=(Text_Ordering case_sensitive=True)
            t2.at "eta" . to_vector . should_equal ["Aleph", "Beta", "alpha", "bądź"]

            t3 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "psi"]) text_ordering=(Text_Ordering case_sensitive=Case_Insensitive)
            t3.at "psi" . to_vector . should_equal [Nothing, "c01", "c10", "C2"]

            t4 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "psi" Sort_Direction.Descending]) text_ordering=(Text_Ordering case_sensitive=True)
            t4.at "psi" . to_vector . should_equal ["c10", "c01", "C2", Nothing]

        Test.specify "should support natural and case insensitive ordering at the same time" pending=(if (test_selection.natural_ordering.not || test_selection.case_insensitive_ordering.not) then "Natural ordering or case sensitive ordering is not supported.") <|
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "psi"]) text_ordering=(Text_Ordering sort_digits_as_numbers=True case_sensitive=Case_Insensitive)
            t1.at "psi" . to_vector . should_equal [Nothing, "c01", "C2", "c10"]

            t2 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "psi"]) text_ordering=(Text_Ordering sort_digits_as_numbers=True)
            t2.at "psi" . to_vector . should_equal [Nothing, "C2", "c01", "c10"]

            t3 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "psi"]) text_ordering=(Text_Ordering case_sensitive=Case_Insensitive)
            t3.at "psi" . to_vector . should_equal [Nothing, "c01", "c10", "C2"]

            t4 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "psi"])
            t4.at "psi" . to_vector . should_equal [Nothing, "C2", "c01", "c10"]

        Test.specify "text ordering settings should not affect numeric columns" <|
            ordering = Text_Ordering sort_digits_as_numbers=True case_sensitive=Case_Insensitive
            t1 = table.order_by (Sort_Column_Selector.By_Name [Sort_Column.Name "alpha"]) text_ordering=ordering
            t1.at "alpha" . to_vector . should_equal [0, 1, 2, 3]
            t1.at "gamma" . to_vector . should_equal [4, 3, 2, 1]

    take_drop_by_pending = if pending.is_nothing.not then pending else
        if test_selection.take_drop.not then "TODO: take/drop are not yet supported by this backend." else
            Nothing
    Test.group prefix+"Table.take/drop" pending=take_drop_by_pending <|
        table =
            col1 = ["alpha", [1,2,3,4,5,6,7,8]]
            col2 = ["beta", ["A","B","C","D","E","F","G","H"]]
            table_builder [col1, col2]
        empty = table_builder [["alpha", []], ["beta", []]]

        Test.specify "should allow selecting first or last N rows" <|
            table.take.at "alpha" . to_vector . should_equal [1]
            table.take.at "beta" . to_vector . should_equal ["A"]
            table.drop.at "alpha" . to_vector . should_equal [2,3,4,5,6,7,8]

            table.take (First 4) . at "alpha" . to_vector . should_equal [1,2,3,4]
            table.take (First 0) . at "alpha" . to_vector . should_equal []
            table.take (First -1) . at "alpha" . to_vector . should_equal []
            table.take (First 100) . should_equal table

            table.drop (First 2) . at "beta" . to_vector . should_equal ["C","D","E","F","G","H"]
            table.drop (First 0) . should_equal table
            table.drop (First -1) . should_equal table
            table.drop (First 100) . should_equal empty

            table.take (Last 4) . at "beta" . to_vector . should_equal ["E","F","G","H"]
            table.take (Last 0) . should_equal empty
            table.take (Last -1) . should_equal empty
            table.take (Last 100) . should_equal table

            table.drop (Last 2) . at "alpha" . to_vector . should_equal [1,2,3,4,5,6]
            table.drop (Last 0) . should_equal table
            table.drop (Last -1) . should_equal table
            table.drop (Last 100) . should_equal empty

        Test.specify "should allow selecting rows by ranges or indices" <|
            table.take (Range 2 4) . at "beta" . to_vector . should_equal ["C", "D"]
            table.take (Range 0 0) . should_equal empty
            table.take (Range 100 100) . should_fail_with Index_Out_Of_Bounds_Error
            table.take (Range 100 100) . catch . should_equal (Index_Out_Of_Bounds_Error 100 8)
            table.take (Range 0 100) . should_equal table
            table.take (Range 0 table.row_count) . should_equal table
            empty.take (Range 0 0) . should_fail_with Index_Out_Of_Bounds_Error
            empty.take (Range 0 0) . catch . should_equal (Index_Out_Of_Bounds_Error 0 0)
            table.take (Range 100 99) . should_fail_with Index_Out_Of_Bounds_Error

            table.drop (Range 2 4) . at "alpha" . to_vector . should_equal [1, 2, 5, 6, 7, 8]
            table.drop (Range 0 0) . should_equal table
            table.drop (Range 100 100) . should_fail_with Index_Out_Of_Bounds_Error
            table.drop (Range 100 100) . catch . should_equal (Index_Out_Of_Bounds_Error 100 8)
            table.drop (Range 0 100) . should_equal empty
            table.drop (Range 0 table.row_count) . should_equal empty
            empty.drop (Range 0 0) . should_fail_with Index_Out_Of_Bounds_Error
            empty.drop (Range 0 0) . catch . should_equal (Index_Out_Of_Bounds_Error 0 0)
            table.drop (Range 100 99) . should_fail_with Index_Out_Of_Bounds_Error

            table.take (Index_Sub_Range.By_Index 0) . at "beta" . to_vector . should_equal ["A"]
            empty.take (Index_Sub_Range.By_Index 0) . should_fail_with Index_Out_Of_Bounds_Error
            table.take (Index_Sub_Range.By_Index []) . should_equal empty
            table.take (Index_Sub_Range.By_Index [-1, -1]) . at "beta" . to_vector . should_equal ["H", "H"]
            table.take (Index_Sub_Range.By_Index [0, 0, Range 3 100]) . at "alpha" . to_vector . should_equal [1, 1, 4, 5, 6, 7, 8]
            table.take (Range 0 100 2) . at "alpha" . to_vector . should_equal [1, 3, 5, 7]
            table.take (Index_Sub_Range.By_Index [Range 0 100 2, Range 1 6 2]) . at "alpha" . to_vector . should_equal [1, 3, 5, 7, 2, 4, 6]
            table.take (Index_Sub_Range.By_Index [Range 1 3, Range 2 5]) . at "alpha" . to_vector . should_equal [2, 3, 3, 4, 5]
            table.take (Index_Sub_Range.By_Index [Range 2 5, Range 1 3]) . at "alpha" . to_vector . should_equal [3, 4, 5, 2, 3]
            table.take (Index_Sub_Range.By_Index [0, 1, Range 100 200]) . should_fail_with Index_Out_Of_Bounds_Error
            table.take (Index_Sub_Range.By_Index 100) . should_fail_with Index_Out_Of_Bounds_Error

            table.drop (Index_Sub_Range.By_Index 0) . at "alpha" . to_vector . should_equal [2, 3, 4, 5, 6, 7, 8]
            table.drop (Index_Sub_Range.By_Index []) . should_equal table
            table.drop (Index_Sub_Range.By_Index [-1, -1]) . at "alpha" . to_vector . should_equal [1, 2, 3, 4, 5, 6, 7]
            table.drop (Index_Sub_Range.By_Index [0, 0, Range 3 100]) . at "alpha" . to_vector . should_equal [2, 3]
            table.drop (Range 0 100 2) . at "alpha" . to_vector . should_equal [2, 4, 6, 8]
            table.drop (Index_Sub_Range.By_Index [Range 0 100 2, Range 1 6 2]) . at "alpha" . to_vector . should_equal [8]
            table.drop (Index_Sub_Range.By_Index [Range 1 3, Range 2 5]) . at "alpha" . to_vector . should_equal [1, 6, 7, 8]
            table.drop (Index_Sub_Range.By_Index [Range 2 5, Range 1 3]) . at "alpha" . to_vector . should_equal [1, 6, 7, 8]
            table.drop (Index_Sub_Range.By_Index [0, 1, Range 100 200]) . should_fail_with Index_Out_Of_Bounds_Error
            table.drop (Index_Sub_Range.By_Index 100) . should_fail_with Index_Out_Of_Bounds_Error

        Test.specify "should allow selecting every Nth row" <|
            table.take (Every 1) . should_equal table
            table.take (Every 3) . at "alpha" . to_vector . should_equal [1, 4, 7]
            table.take (Every 3 first=1) . at "alpha" . to_vector . should_equal [2, 5, 8]
            table.take (Every 2 first=1) . at "beta" . to_vector . should_equal ["B", "D", "F", "H"]
            table.take (Every 2 first=100) . at "alpha" . to_vector . should_equal []
            table.take (Every 200) . at "alpha" . to_vector . should_equal [1]
            empty.take (Every 2) . should_equal empty
            table.take (Every 0) . should_fail_with Illegal_Argument_Error
            empty.take (Every 0) . should_fail_with Illegal_Argument_Error

            table.drop (Every 1) . should_equal empty
            table.drop (Every 3) . at "alpha" . to_vector . should_equal [2, 3, 5, 6, 8]
            table.drop (Every 3 first=1) . at "alpha" . to_vector . should_equal [1, 3, 4, 6, 7]
            table.drop (Every 2 first=1) . at "alpha" . to_vector . should_equal [1, 3, 5, 7]
            table.drop (Every 2 first=100) . should_equal table
            table.drop (Every 200) . at "beta" . to_vector . should_equal ["B", "C", "D", "E", "F", "G", "H"]
            empty.drop (Every 2) . should_equal empty
            table.drop (Every 0) . should_fail_with Illegal_Argument_Error
            empty.drop (Every 0) . should_fail_with Illegal_Argument_Error

        Test.specify "should allow sampling rows" <|
            empty = table_builder [["X", []]]
            one = table_builder [["X", ["a"]]]
            two = table_builder [["X", ["a", "a"]]]
            three = table_builder [["X", ["a", "a", "a"]]]
            three.take (Sample 0) . should_equal empty
            empty.take (Sample 0) . should_equal empty
            empty.take (Sample 1) . should_equal empty
            three.take (Sample 1) . should_equal one
            three.take (Sample 100) . should_equal three

            three.drop (Sample 0) . should_equal three
            empty.drop (Sample 0) . should_equal empty
            empty.drop (Sample 1) . should_equal empty
            one.drop (Sample 1) . should_equal empty
            three.drop (Sample 1) . should_equal two
            three.drop (Sample 100) . should_equal empty

            rnd = table.take (Sample 3 seed=42)
            random_indices = [5, 6, 2]
            alpha_sample = random_indices.map (table.at "alpha" . to_vector . at)
            beta_sample = random_indices.map (table.at "beta" . to_vector . at)
            rnd.at "alpha" . to_vector . should_equal alpha_sample
            rnd.at "beta" . to_vector . should_equal beta_sample

        Test.specify "should allow selecting rows as long as they satisfy a predicate" pending="While is not implemented for Table until the Row type is implemented." <|
            Nothing

    Test.group prefix+"Column.take/drop" pending=take_drop_by_pending <|
        table =
            col1 = ["alpha", [1,2,3,4,5,6,7,8]]
            col2 = ["beta", ["A","B","C","D","E","F","G","H"]]
            table_builder [col1, col2]
        alpha = table.at "alpha"
        beta = table.at "beta"

        empty_table = table_builder [["alpha", []], ["beta", []]]
        empty_alpha = empty_table.at "alpha"
        empty_beta = empty_table.at "beta"

        Test.specify "should allow selecting first or last N rows" <|
            alpha.take.to_vector . should_equal [1]
            beta.take.to_vector . should_equal ["A"]
            alpha.drop.to_vector . should_equal [2,3,4,5,6,7,8]

            alpha.take (First 4) . to_vector . should_equal [1,2,3,4]
            alpha.take (First 0) . should_equal empty_alpha
            alpha.take (First -1) . should_equal empty_alpha
            alpha.take (First 100) . should_equal alpha

            beta.drop (First 2) . to_vector . should_equal ["C","D","E","F","G","H"]
            alpha.drop (First 0) . should_equal alpha
            alpha.drop (First -1) . should_equal alpha
            alpha.drop (First 100) . should_equal empty_alpha

            beta.take (Last 4) . to_vector . should_equal ["E","F","G","H"]
            beta.take (Last 0) . should_equal empty_beta
            beta.take (Last -1) . should_equal empty_beta
            beta.take (Last 100) . should_equal beta

            alpha.drop (Last 2) . to_vector . should_equal [1,2,3,4,5,6]
            alpha.drop (Last 0) . should_equal alpha
            alpha.drop (Last -1) . should_equal alpha
            alpha.drop (Last 100) . should_equal empty_alpha

        Test.specify "should allow selecting rows by ranges or indices" <|
            beta.take (Range 2 4) . to_vector . should_equal ["C", "D"]
            beta.take (Range 0 0) . should_equal empty_beta
            beta.take (Range 100 100) . should_fail_with Index_Out_Of_Bounds_Error
            beta.take (Range 100 100) . catch . should_equal (Index_Out_Of_Bounds_Error 100 8)
            beta.take (Range 0 100) . should_equal beta
            beta.take (Range 0 table.row_count) . should_equal beta
            empty_beta.take (Range 0 0) . should_fail_with Index_Out_Of_Bounds_Error
            empty_beta.take (Range 0 0) . catch . should_equal (Index_Out_Of_Bounds_Error 0 0)
            beta.take (Range 100 99) . should_fail_with Index_Out_Of_Bounds_Error

            alpha.drop (Range 2 4) . to_vector . should_equal [1, 2, 5, 6, 7, 8]
            alpha.drop (Range 0 0) . should_equal alpha
            alpha.drop (Range 100 100) . should_fail_with Index_Out_Of_Bounds_Error
            alpha.drop (Range 100 100) . catch . should_equal (Index_Out_Of_Bounds_Error 100 8)
            alpha.drop (Range 0 100) . should_equal empty_alpha
            alpha.drop (Range 0 table.row_count) . should_equal empty_alpha
            empty_alpha.drop (Range 0 0) . should_fail_with Index_Out_Of_Bounds_Error
            empty_alpha.drop (Range 0 0) . catch . should_equal (Index_Out_Of_Bounds_Error 0 0)
            alpha.drop (Range 100 99) . should_fail_with Index_Out_Of_Bounds_Error

            beta.take (Index_Sub_Range.By_Index 0) . to_vector . should_equal ["A"]
            empty_beta.take (Index_Sub_Range.By_Index 0) . should_fail_with Index_Out_Of_Bounds_Error
            beta.take (Index_Sub_Range.By_Index []) . should_equal empty_beta
            beta.take (Index_Sub_Range.By_Index [-1, -1]) . to_vector . should_equal ["H", "H"]
            alpha.take (Index_Sub_Range.By_Index [0, 0, Range 3 100]) . to_vector . should_equal [1, 1, 4, 5, 6, 7, 8]
            alpha.take (Range 0 100 2) . to_vector . should_equal [1, 3, 5, 7]
            alpha.take (Index_Sub_Range.By_Index [Range 0 100 2, Range 1 6 2]) . to_vector . should_equal [1, 3, 5, 7, 2, 4, 6]
            alpha.take (Index_Sub_Range.By_Index [Range 1 3, Range 2 5]) . to_vector . should_equal [2, 3, 3, 4, 5]
            alpha.take (Index_Sub_Range.By_Index [Range 2 5, Range 1 3]) . to_vector . should_equal [3, 4, 5, 2, 3]
            alpha.take (Index_Sub_Range.By_Index [0, 1, Range 100 200]) . should_fail_with Index_Out_Of_Bounds_Error
            alpha.take (Index_Sub_Range.By_Index 100) . should_fail_with Index_Out_Of_Bounds_Error

            alpha.drop (Index_Sub_Range.By_Index 0) . to_vector . should_equal [2, 3, 4, 5, 6, 7, 8]
            alpha.drop (Index_Sub_Range.By_Index []) . should_equal alpha
            alpha.drop (Index_Sub_Range.By_Index [-1, -1]) . to_vector . should_equal [1, 2, 3, 4, 5, 6, 7]
            alpha.drop (Index_Sub_Range.By_Index [0, 0, Range 3 100]) . to_vector . should_equal [2, 3]
            alpha.drop (Range 0 100 2) . to_vector . should_equal [2, 4, 6, 8]
            alpha.drop (Index_Sub_Range.By_Index [Range 0 100 2, Range 1 6 2]) . to_vector . should_equal [8]
            alpha.drop (Index_Sub_Range.By_Index [Range 1 3, Range 2 5]) . to_vector . should_equal [1, 6, 7, 8]
            alpha.drop (Index_Sub_Range.By_Index [Range 2 5, Range 1 3]) . to_vector . should_equal [1, 6, 7, 8]
            alpha.drop (Index_Sub_Range.By_Index [0, 1, Range 100 200]) . should_fail_with Index_Out_Of_Bounds_Error
            alpha.drop (Index_Sub_Range.By_Index 100) . should_fail_with Index_Out_Of_Bounds_Error

        Test.specify "should allow selecting every Nth row" <|
            alpha.take (Every 1) . should_equal alpha
            alpha.take (Every 3) . to_vector . should_equal [1, 4, 7]
            alpha.take (Every 3 first=1) . to_vector . should_equal [2, 5, 8]
            beta.take (Every 2 first=1) . to_vector . should_equal ["B", "D", "F", "H"]
            alpha.take (Every 2 first=100) . to_vector . should_equal []
            alpha.take (Every 200) . to_vector . should_equal [1]
            empty_beta.take (Every 2) . should_equal empty_beta
            beta.take (Every 0) . should_fail_with Illegal_Argument_Error
            empty_beta.take (Every 0) . should_fail_with Illegal_Argument_Error

            alpha.drop (Every 1) . should_equal empty_alpha
            alpha.drop (Every 3) . to_vector . should_equal [2, 3, 5, 6, 8]
            alpha.drop (Every 3 first=1) . to_vector . should_equal [1, 3, 4, 6, 7]
            alpha.drop (Every 2 first=1) . to_vector . should_equal [1, 3, 5, 7]
            alpha.drop (Every 2 first=100) . should_equal alpha
            beta.drop (Every 200) . to_vector . should_equal ["B", "C", "D", "E", "F", "G", "H"]
            empty_beta.drop (Every 2) . should_equal empty_beta
            beta.drop (Every 0) . should_fail_with Illegal_Argument_Error
            empty_beta.drop (Every 0) . should_fail_with Illegal_Argument_Error

        Test.specify "should allow sampling rows" <|
            three = table_builder [["X", ["a", "a", "a"]]] . at "X"
            two = three.take (First 2)
            one = three.take First
            empty = three.take (First 0)

            [three, two, one, empty].map .to_vector . should_equal [["a", "a", "a"], ["a", "a"], ["a"], []]

            three.take (Sample 0) . should_equal empty
            empty.take (Sample 0) . should_equal empty
            empty.take (Sample 1) . should_equal empty
            three.take (Sample 1) . should_equal one
            three.take (Sample 100) . should_equal three

            three.drop (Sample 0) . should_equal three
            empty.drop (Sample 0) . should_equal empty
            empty.drop (Sample 1) . should_equal empty
            one.drop (Sample 1) . should_equal empty
            three.drop (Sample 1) . should_equal two
            three.drop (Sample 100) . should_equal empty

            rnd = alpha.take (Sample 3 seed=42)
            random_indices = [5, 6, 2]
            sample = alpha.take (Index_Sub_Range.By_Index random_indices)
            rnd.should_equal sample

        Test.specify "should allow selecting rows as long as they satisfy a predicate" <|
            col = table_builder [["X", [1, 3, 5, 6, 8, 9, 10, 11, 13]]] . at "X"
            col.take (While (x-> x%2 == 1)) . to_vector . should_equal [1, 3, 5]
            col.drop (While (x-> x%2 == 1)) . to_vector . should_equal [6, 8, 9, 10, 11, 13]

            three = table_builder [["X", [1, 2, 3]]] . at "X"
            empty = table_builder [["X", []]] . at "X"
            three.take (While (_ > 10)) . should_equal empty
            three.take (While (_ < 10)) . should_equal three

            three.drop (While (_ > 10)) . should_equal three
            three.drop (While (_ < 10)) . should_equal empty
