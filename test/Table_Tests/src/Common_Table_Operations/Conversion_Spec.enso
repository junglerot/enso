from Standard.Base import all
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument

import Standard.Table.Data.Type.Value_Type.Bits
from Standard.Table import Value_Type
from Standard.Table.Errors import Missing_Input_Columns, Conversion_Failure

from Standard.Database.Errors import Unsupported_Database_Operation

from Standard.Test import Test, Problems
import Standard.Test.Extensions

from project.Common_Table_Operations.Util import run_default_backend

polyglot java import java.lang.Long as Java_Long

main = run_default_backend spec

type My_Type
    Value x

    to_text : Text
    to_text self = "{{{MY Type [x="+self.x.to_text+"] }}}"

spec setup =
    prefix = setup.prefix
    table_builder = setup.table_builder
    materialize = setup.materialize
    supports_dates = setup.test_selection.date_time
    supports_conversion_failure_reporting = setup.is_database.not
    Test.group prefix+"Table/Column.cast - to text" <|
        Test.specify "should allow to cast columns of various basic types to text" <|
            t = table_builder [["X", [1, 2, 3000]], ["Y", [True, False, True]], ["Z", [1.5, 0.125, -2.5]], ["W", ["a", "DEF", "a slightly longer text"]]]
            t2 = t.cast t.column_names Value_Type.Char
            t2.at "X" . value_type . is_text . should_be_true
            t2.at "Y" . value_type . is_text . should_be_true
            t2.at "Z" . value_type . is_text . should_be_true
            t2.at "W" . value_type . is_text . should_be_true

            t2.at "X" . to_vector . should_equal ["1", "2", "3000"]
            # Depending on the backend, the case of True/False literals may differ.
            t2.at "Y" . to_vector . map (_.to_case Case.Lower) . should_equal ["true", "false", "true"]
            t2.at "Z" . to_vector . should_equal ["1.5", "0.125", "-2.5"]
            t2.at "W" . to_vector . should_equal ["a", "DEF", "a slightly longer text"]

        if supports_dates then
            Test.specify "should allow to cast date/time columns to text" <|
                t = table_builder [["X", [Date.new 2015 1 1, Date.new 2023 12 31]], ["Y", [Time_Of_Day.new 1 2 3, Time_Of_Day.new 23 57 59]], ["Z", [Date_Time.new 2015 1 1 1 2 3, Date_Time.new 2023 11 30 22 45 44]]]
                t2 = t.cast t.column_names Value_Type.Char
                t2.at "X" . value_type . is_text . should_be_true
                t2.at "Y" . value_type . is_text . should_be_true
                t2.at "Z" . value_type . is_text . should_be_true

                t2.at "X" . to_vector . should_equal ["2015-01-01", "2023-12-31"]
                t2.at "Y" . to_vector . should_equal ["01:02:03", "23:57:59"]
                # The particular format depends on the backend.
                vz = t2.at "Z" . to_vector
                vz.first . should_contain "2015-01-01"
                vz.first . should_contain "01:02:03"
                vz.second . should_contain "2023-11-30"
                vz.second . should_contain "22:45:44"

        if setup.is_database.not then
            Test.specify "should allow to cast a column of objects to text" <|
                t = table_builder [["X", [My_Type.Value 42, My_Type.Value "X"]]]
                c = t.at "X" . cast Value_Type.Char
                c.value_type.is_text . should_be_true
                c.to_vector . should_equal ["{{{MY Type [x=42] }}}", "{{{MY Type [x=X] }}}"]

            Test.specify "should allow to cast an integer column to a decimal type" <|
                t = table_builder [["X", [1, 2, 3]]]
                c = t.at "X" . cast Value_Type.Decimal
                c.value_type.is_decimal . should_be_true
                c.to_vector . should_equal [1, 2, 3]

        if setup.test_selection.fixed_length_text_columns then
            Test.specify "should allow to cast a text column to fixed-length"  <|
                t = table_builder [["X", ["a", "DEF", "a slightly longer text"]]]
                c = t.at "X" . cast (Value_Type.Char size=3 variable_length=False)
                c.value_type . should_equal (Value_Type.Char size=3 variable_length=False)
                c.to_vector . should_equal ["a  ", "DEF", "a s"]

                # No Conversion_Failure warning here, because we started with text, so it was expected we will trim it if needed.
                Problems.assume_no_problems c

            Test.specify "should allow to cast a text column to variable-length with a max size" <|
                t = table_builder [["X", ["a", "DEF", "a slightly longer text"]]]
                c = t.at "X" . cast (Value_Type.Char size=3 variable_length=True)
                c.value_type . should_equal (Value_Type.Char size=3 variable_length=True)
                c.to_vector . should_equal ["a", "DEF", "a s"]

                # No Conversion_Failure warning here, because we started with text, so it was expected we will trim it if needed.
                Problems.assume_no_problems c

            Test.specify "should allow casting a non-text column to fixed-length text" <|
                t = table_builder [["X", [1, 22, 333]]]
                c = t.at "X" . cast (Value_Type.Char size=3 variable_length=False)
                c.value_type . should_equal (Value_Type.Char size=3 variable_length=False)
                c.to_vector . should_equal ["1  ", "22 ", "333"]
                Problems.assume_no_problems c

            Test.specify "should warn when losing data if the fixed-length text length is too short to fit the data" pending=(if supports_conversion_failure_reporting.not then "Conversion_Failure is not supported in Database yet.") <|
                t = table_builder [["X", [15, 1000000, 123456, 1000, 1000]]]
                c1 = t.at "X" . cast (Value_Type.Char size=3 variable_length=False)
                c1.value_type . should_equal (Value_Type.Char size=3 variable_length=False)
                c1.to_vector . should_equal ["15 ", "100", "123", "100", "100"]
                w1 = Problems.expect_warning Conversion_Failure c1
                w1.affected_rows_count . should_equal 4
                w1.to_display_text . should_contain "['1000000', '123456', '1000' and 1 other case] have a text representation that does not fit the target type"

                c2 = t.at "X" . cast (Value_Type.Char size=3 variable_length=True)
                c2.value_type . should_equal (Value_Type.Char size=3 variable_length=True)
                # No padding in variable length, but also truncated.
                c2.to_vector . should_equal ["15", "100", "123", "100", "100"]
                w2 = Problems.expect_warning Conversion_Failure c2
                w2.affected_rows_count . should_equal 4

            Test.specify "should not allow 0-length Char type" <|
                c1 = table_builder [["X", ["a", "", "bcd"]]] . at "X"
                r1 = c1.cast (Value_Type.Char size=0 variable_length=False)
                r1.should_fail_with Illegal_Argument
                r1.catch.to_display_text . should_contain "positive"

                r2 = c1.cast (Value_Type.Char size=0 variable_length=True)
                r2.should_fail_with Illegal_Argument

    Test.group prefix+"Table/Column.cast - numeric" <|
        Test.specify "should allow to cast a boolean column to integer" <|
            t = table_builder [["X", [True, False, True]]]
            c = t.at "X" . cast Value_Type.Integer
            vt = c.value_type
            Test.with_clue "Expecting "+vt.to_display_text+" to be Integer. " <|
                vt.is_integer . should_be_true
            c.to_vector . should_equal [1, 0, 1]

        Test.specify "should allow to cast an integer column to floating point" <|
            t = table_builder [["X", [1, 2, 3]]]
            c = t.at "X" . cast Value_Type.Float
            c.value_type.is_floating_point . should_be_true
            c.to_vector . should_equal [1.0, 2.0, 3.0]

        if setup.test_selection.different_size_integer_types then
            Test.specify "should allow to cast an integer column to a smaller bit-width and larger bit-width" <|
                t = table_builder [["X", [1, 2, 3]]]
                c = t.at "X" . cast (Value_Type.Integer Bits.Bits_16)
                c.value_type . should_equal (Value_Type.Integer Bits.Bits_16)
                c.to_vector . should_equal [1, 2, 3]
                Problems.assume_no_problems c

                t2 = table_builder [["X", [1, 2, 12000000]]]
                c2 = t2.at "X" . cast (Value_Type.Integer Bits.Bits_16)
                if supports_conversion_failure_reporting then
                    c2.value_type . should_equal (Value_Type.Integer Bits.Bits_16)
                    c2.to_vector . should_equal [1, 2, Nothing]

                    w2 = Problems.expect_warning Conversion_Failure c2
                    w2.affected_rows_count . should_equal 1
                    w2.to_display_text . should_contain "out of the range of the target type"

                    r3 = t2.at "X" . cast (Value_Type.Integer Bits.Bits_16) on_problems=Problem_Behavior.Report_Error
                    r3.should_fail_with Conversion_Failure

                # Now converting the 16-bit column `c` into 32 bits.
                c3 = c.cast (Value_Type.Integer Bits.Bits_32)
                c3.value_type . should_equal (Value_Type.Integer Bits.Bits_32)
                c3.to_vector . should_equal [1, 2, 3]

        if setup.test_selection.supports_8bit_integer then
            Test.specify "should allow to cast an integer column to a byte and back" <|
                t = table_builder [["X", [1, 2, 3]]]
                c1 = t.at "X" . cast Value_Type.Byte
                c1.value_type . should_equal Value_Type.Byte
                c1.to_vector . should_equal [1, 2, 3]

                # And converting byte back to 64 bits.
                c2 = c1.cast (Value_Type.Integer Bits.Bits_64)
                c2.value_type . should_equal (Value_Type.Integer Bits.Bits_64)
                c2.to_vector . should_equal [1, 2, 3]

                if supports_conversion_failure_reporting then
                    t2 = table_builder [["X", [1, 2, 257, -300, 0]]]
                    c1 = t2.at "X" . cast Value_Type.Byte
                    c1.value_type . should_equal Value_Type.Byte
                    c1.to_vector . should_equal [1, 2, Nothing, Nothing, 0]
                    w1 = Problems.expect_warning Conversion_Failure c1
                    w1.affected_rows_count . should_equal 2
                    w1.to_display_text . should_contain "out of the range of the target type"

                    c2 = t2.at "X" . cast (Value_Type.Integer Bits.Bits_16)
                    c2.value_type . should_equal (Value_Type.Integer Bits.Bits_16)
                    c2.to_vector . should_equal [1, 2, 257, -300, 0]

                    c3 = c1.cast (Value_Type.Integer Bits.Bits_32)
                    c3.value_type . should_equal (Value_Type.Integer Bits.Bits_32)
                    c3.to_vector . should_equal [1, 2, Nothing, Nothing, 0]

        Test.specify "should allow to cast a floating point column to integer" <|
            t = table_builder [["X", [1.0001, 2.25, 4.0]]]
            c = t.at "X" . cast Value_Type.Integer
            vt = c.value_type
            Test.with_clue "Expecting "+vt.to_display_text+" to be Integer. " <|
                vt.is_integer . should_be_true
            c.to_vector . should_equal [1, 2, 4]
            # Not reporting Lossy Conversion as converting floats to integers obviously truncates the value.
            Problems.assume_no_problems c

            # The backend may either truncate or round.
            t2 = table_builder [["X", [1.1, 4.9]]]
            c2 = t2.at "X" . cast Value_Type.Integer
            v2 = c2.to_vector
            [[1, 4], [1, 5]] . should_contain v2

        if setup.is_database.not then
            Test.specify "should report Conversion_Failure if converting a huge float to an integer overflows it" <|
                max_long = Java_Long.MAX_VALUE
                too_big_double = (max_long + 1.0) * 1000.0
                (too_big_double > max_long) . should_be_true

                min_long = Java_Long.MIN_VALUE
                too_small_double = (min_long - 1.0) * 1000.0
                (too_small_double < min_long) . should_be_true

                v = [1.0, 2.1, max_long, too_big_double, min_long, too_small_double, 4.0]
                t = table_builder [["X", v]]
                t.at "X" . to_vector . should_equal v
                t.at "X" . value_type . should_equal Value_Type.Float

                c = t.at "X" . cast Value_Type.Integer
                c.value_type . should_equal Value_Type.Integer
                c.to_vector . should_equal [1, 2, max_long, Nothing, min_long, Nothing, 4]
                warning = Problems.expect_warning Conversion_Failure c
                warning.to_display_text . should_contain "could not be converted"
                warning.to_display_text . should_contain too_big_double.to_text

    if supports_dates then
        Test.group prefix+"Table/Column.cast - date/time" <|
            Test.specify "should allow to get the Date part from a Date_Time" <|
                t = table_builder [["X", [Date_Time.new 2015 1 2 3 4 5, Date_Time.new 2023 12 31 23 56 59]]]
                c = t.at "X" . cast Value_Type.Date
                c.value_type . should_equal Value_Type.Date
                c.to_vector . should_equal [Date.new 2015 1 2, Date.new 2023 12 31]

            Test.specify "should allow to get the Time_Of_Day part from a Date_Time" <|
                t = table_builder [["X", [Date_Time.new 2015 1 2 3 4 5, Date_Time.new 2023 12 31 23 56 59]]]
                c = t.at "X" . cast Value_Type.Time
                c.value_type . should_equal Value_Type.Time
                c.to_vector . should_equal [Time_Of_Day.new 3 4 5, Time_Of_Day.new 23 56 59]

            Test.specify "should allow to convert a Date into Date_Time" <|
                day1 = Date.new 2015 1 2
                day2 = Date.new 2023 12 31
                t = table_builder [["X", [day1, day2]]]
                c = t.at "X" . cast Value_Type.Date_Time
                c.value_type . should_equal Value_Type.Date_Time
                vz = c.to_vector
                # We cannot rely on what timezone the backend uses, so we just ensure that the time difference between the two results is consistent.
                diff = Duration.between vz.first vz.second
                expected_diff = Duration.between day1.to_date_time day2.to_date_time
                diff . should_equal expected_diff

    Test.group prefix+"Table/Column.cast - checking invariants" <|
        Test.specify "should report an error for unsupported conversions" <|
            t = table_builder [["X", [1, 2, 3]]]
            r1 = t.at "X" . cast Value_Type.Boolean
            r1.should_fail_with Illegal_Argument

        Test.specify "should report an error pointing to the Table.parse method where applicable" <|
            t = table_builder [["X", ["1", "2", "3"]]]
            r1 = t.at "X" . cast Value_Type.Integer
            r1.should_fail_with Illegal_Argument
            r1.to_display_text . should_contain "`parse` should be used instead"

        Test.specify "should report missing columns" <|
            t = table_builder [["X", [1, 2, 3]], ["Y", [4, 5, 6]]]

            r1 = t.cast ["X", "Z"] Value_Type.Char
            r1.should_fail_with Missing_Input_Columns
            r1.catch.criteria . should_equal ["Z"]

            t2 = t.cast ["X", "Z"] Value_Type.Char error_on_missing_columns=False
            warn = Problems.expect_warning Missing_Input_Columns t2
            warn.criteria . should_equal ["Z"]
            t2.at "X" . to_vector . should_equal ["1", "2", "3"]
            t2.at "Y" . to_vector . should_equal [4, 5, 6]

            t3 = t.cast ["Z"] Value_Type.Char error_on_missing_columns=False
            t3.at "X" . to_vector . should_equal [1, 2, 3]
            t3.at "Y" . to_vector . should_equal [4, 5, 6]

        Test.specify "should work if the first row is NULL" <|
            t = table_builder [["X", [Nothing, 1, 2, 3000]], ["Y", [Nothing, True, False, True]]]

            c1 = t.at "X" . cast Value_Type.Char
            c1.value_type.is_text . should_be_true
            c1.to_vector . should_equal [Nothing, "1", "2", "3000"]

            c2 = t.at "Y" . cast Value_Type.Integer
            c2.value_type . should_equal Value_Type.Integer
            c2.to_vector . should_equal [Nothing, 1, 0, 1]

        Test.specify "should not lose the type after further operations were performed on the result" <|
            t = table_builder [["X", [1, 2, 3000]], ["Y", [True, False, True]]]
            c1 = t.at "X" . cast Value_Type.Char
            c2 = t.at "Y" . cast Value_Type.Integer

            c3 = c1 + '_suffix'
            c3.value_type.is_text . should_be_true
            c3.to_vector . should_equal ["1_suffix", "2_suffix", "3000_suffix"]

            c4 = c2 + 1000
            vt4 = c4.value_type
            Test.with_clue "Expecting "+vt4.to_display_text+" to be Integer. " <|
                vt4.is_integer . should_be_true
            c4.to_vector . should_equal [1001, 1000, 1001]

        Test.specify "should not lose the type after further operations were performed on the result, even if the first row is NULL" <|
            t = table_builder [["X", [Nothing, 1, 2, 3000]], ["Y", [Nothing, True, False, True]]]
            c1 = t.at "X" . cast Value_Type.Char
            c2 = t.at "Y" . cast Value_Type.Integer

            c3 = c1 + '_suffix'
            c3.value_type.is_text . should_be_true
            c3.to_vector . should_equal [Nothing, "1_suffix", "2_suffix", "3000_suffix"]

            c4 = c2 + 1000
            vt4 = c4.value_type
            Test.with_clue "Expecting "+vt4.to_display_text+" to be Integer. " <|
                vt4.is_integer . should_be_true
            c4.to_vector . should_equal [Nothing, 1001, 1000, 1001]

        Test.specify 'Table.cast should cast the columns "in-place" and not reorder them' <|
            t = table_builder [["X", [1, 2, 3000]], ["Y", [4, 5, 6]], ["Z", [7, 8, 9]], ["A", [True, False, True]]]
            t2 = t.cast ["Z", "Y"] Value_Type.Char
            t2.column_names . should_equal ["X", "Y", "Z", "A"]

            t2.at "X" . value_type . is_integer . should_be_true
            t2.at "Y" . value_type . is_text . should_be_true
            t2.at "Z" . value_type . is_text . should_be_true
            t2.at "A" . value_type . is_boolean . should_be_true

            t2.at "X" . to_vector . should_equal [1, 2, 3000]
            t2.at "Y" . to_vector . should_equal ["4", "5", "6"]
            t2.at "Z" . to_vector . should_equal ["7", "8", "9"]
            t2.at "A" . to_vector . should_equal [True, False, True]

        if setup.test_selection.different_size_integer_types then
            Test.specify "should preserve the overridden types when materialized (Integer)" <|
                t = table_builder [["X", [1, 2, 100]]]
                t2 = t . cast "X" (Value_Type.Integer Bits.Bits_16)
                t3 = materialize t2
                t3.at "X" . value_type . should_equal (Value_Type.Integer Bits.Bits_16)

        if setup.test_selection.fixed_length_text_columns then
            Test.specify "should preserve the overridden types when materialized (Char)" <|
                t = table_builder [["Y", ["a", "abcdef", "abc"]]]
                t2 = t . cast "Y" (Value_Type.Char size=3 variable_length=False)
                t3 = materialize t2
                t3.at "Y" . value_type . should_equal (Value_Type.Char size=3 variable_length=False)
                t3.at "Y" . to_vector . should_equal ["a  ", "abc", "abc"]

        if setup.is_database.not then
            Test.specify "should allow converting a Mixed type back to a specific type" <|
                t1 = table_builder [["A", [1, Nothing, 2]], ["B", [1.5, Nothing, 2.5]], ["C", [Nothing, "x", "y"]], ["D", [Nothing, True, False]]]
                m1 = t1.cast t1.column_names Value_Type.Mixed
                ["A", "B", "C", "D"].each c->
                    m1.at c . value_type . should_equal Value_Type.Mixed
                m1.at "A" . to_vector . should_equal [1, Nothing, 2]
                c1 = m1.at "A" . cast Value_Type.Integer
                c1.value_type . should_equal Value_Type.Integer
                c1.to_vector . should_equal [1, Nothing, 2]

                m1.at "B" . cast Value_Type.Float . value_type . should_equal Value_Type.Float
                m1.at "C" . cast Value_Type.Char . value_type . should_equal Value_Type.Char
                m1.at "D" . cast Value_Type.Boolean . value_type . should_equal Value_Type.Boolean

                t2 = table_builder [["E", [Date.new 2020, Date.new 2023, Nothing]], ["F", [Time_Of_Day.new 10, Time_Of_Day.new 11, Nothing]], ["G", [Date_Time.new 2022 12 30 13 45, Nothing, Date_Time.new 2020]]]
                m2 = t2.cast t2.column_names Value_Type.Mixed
                ["E", "F", "G"].each c->
                    m2.at c . value_type . should_equal Value_Type.Mixed
                m2.at "E" . cast Value_Type.Date . value_type . should_equal Value_Type.Date
                m2.at "F" . cast Value_Type.Time . value_type . should_equal Value_Type.Time
                m2.at "G" . cast Value_Type.Date_Time . value_type . should_equal Value_Type.Date_Time

            Test.specify "will extract matching values from a mixed column and replace unconvertible ones with Nothing" <|
                t0 = table_builder [["X", ["a", "b", "c", My_Type.Value 42]]]
                t0.at "X" . value_type . should_equal Value_Type.Mixed
                r0 = t0.cast ["X"] Value_Type.Integer
                w0 = Problems.expect_warning Conversion_Failure r0
                w0.affected_rows_count . should_equal 4
                r0.at "X" . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]

                mixed_values = [1, 2.25, "3", "-45.25", "2.0", "X", Date.new 2020, Date_Time.new 2023 12 15 19 25, Time_Of_Day.new 12 30, My_Type.Value 42, True, Nothing, "True"]
                t2 = table_builder [["super-mix", mixed_values]]
                t2.at "super-mix" . value_type . should_equal Value_Type.Mixed

                nulls n = Vector.fill n Nothing

                c1 = t2.cast "super-mix" Value_Type.Integer . at "super-mix"
                c1.value_type . should_equal Value_Type.Integer
                # Texts are not parsed, since cast does not do Text->numeric.
                c1.to_vector . should_equal ([1, 2] + (nulls 8) + [1, Nothing, Nothing])
                w1 = Problems.expect_warning Conversion_Failure c1
                w1.affected_rows_count . should_equal 9

                # Also check that integer range is checked in Mixed conversions.
                t3 = table_builder [["numbermix", ["a", 34, 300, 10^12]]]
                c1_2 = t3.at "numbermix" . cast (Value_Type.Integer Bits.Bits_16)
                c1_2.value_type . should_equal (Value_Type.Integer Bits.Bits_16)
                c1_2.to_vector . should_equal [Nothing, 34, 300, Nothing]
                # We should have 2 separate warnings: for values of wrong type and for integers that just did not fit the range.
                w1_2 = Problems.get_attached_warnings c1_2
                w1_2.each w-> w.affected_rows_count . should_equal 1
                w1_2.find (w-> w.to_display_text . contains "out of the range") . should_not_equal Nothing
                w1_2.find (w-> w.to_display_text . contains "could not be converted") . should_not_equal Nothing
                w1_2.length . should_equal 2
                c1_3 = t3.at "numbermix" . cast Value_Type.Byte
                c1_3.value_type . should_equal Value_Type.Byte
                c1_3.to_vector . should_equal [Nothing, 34, Nothing, Nothing]

                c2 = t2.cast "super-mix" Value_Type.Float . at "super-mix"
                c2.value_type . should_equal Value_Type.Float
                c2.to_vector . should_equal ([1.0, 2.25] + (nulls 8) + [1.0, Nothing, Nothing])
                w2 = Problems.expect_warning Conversion_Failure c2
                w2.affected_rows_count . should_equal 9

                c3 = t2.cast "super-mix" Value_Type.Char . at "super-mix"
                c3.value_type . should_equal Value_Type.Char
                date_time_str = Date_Time.new 2023 12 15 19 25 . to_text
                c3.to_vector . should_equal ["1", "2.25", "3", "-45.25", "2.0", "X", "2020-01-01", date_time_str, "12:30:00", "{{{MY Type [x=42] }}}", "True", Nothing, "True"]
                Problems.assume_no_problems c3

                if setup.test_selection.fixed_length_text_columns then
                    c3_2 = t2.cast "super-mix" (Value_Type.Char size=2) . at "super-mix"
                    c3_2.value_type . should_equal (Value_Type.Char size=2)
                    c3_2.to_vector . should_equal ["1", "2.", "3", "-4", "2.", "X", "20", "20", "12", "{{", "Tr", Nothing, "Tr"]
                    w3_2 = Problems.expect_warning Conversion_Failure c3_2
                    w3_2.affected_rows_count . should_equal 9
                    w3_2.to_display_text . should_contain "have a text representation that does not fit the target type"

                c4 = t2.cast "super-mix" Value_Type.Boolean . at "super-mix"
                c4.value_type . should_equal Value_Type.Boolean
                c4.to_vector . should_equal ((nulls 10) + [True, Nothing, Nothing])
                w4 = Problems.expect_warning Conversion_Failure c4
                w4.affected_rows_count . should_equal 11

                c5 = t2.cast "super-mix" Value_Type.Date . at "super-mix"
                c5.to_vector . should_equal ((nulls 6) + [Date.new 2020, Date.new 2023 12 15, Nothing] + (nulls 4))
                w5 = Problems.expect_warning Conversion_Failure c5
                w5.affected_rows_count . should_equal 6+3+1

                c6 = t2.cast "super-mix" Value_Type.Time . at "super-mix"
                c6.to_vector . should_equal ((nulls 6) + [Nothing, Time_Of_Day.new 19 25, Time_Of_Day.new 12 30] + (nulls 4))
                w6 = Problems.expect_warning Conversion_Failure c6
                w6.affected_rows_count . should_equal 6+3+1

                c7 = t2.cast "super-mix" Value_Type.Date_Time . at "super-mix"
                c7.to_vector . should_equal ((nulls 6) + [Date_Time.new 2020, Date_Time.new 2023 12 15 19 25, Nothing] + (nulls 4))
                w7 = Problems.expect_warning Conversion_Failure c7
                w7.affected_rows_count . should_equal 6+3+1

        if setup.is_database.not then
            Test.specify "should fail if there is no conversion available for a given type" <|
                t = table_builder [["X", [1, 2, 3]]]

                # currently unsupported
                r2 = t.cast "X" Value_Type.Binary
                r2.should_fail_with Illegal_Argument

                # this is not supposed to be supported, but still needs a friendly message
                r3 = t.cast "X" (Value_Type.Unsupported_Data_Type "foobar" "foobar")
                r3.should_fail_with Illegal_Argument

    Test.group prefix+"Simple variant of Table/Column.parse in all backends" <|
        Test.specify "should be able to parse simple integers" <|
            t = table_builder [["X", ["42", "0", "-1"]]]

            c1 = t.at "X" . parse Value_Type.Integer
            c1.value_type.is_integer . should_be_true
            c1.to_vector . should_equal [42, 0, -1]

            c2 = t.parse ["X"] Value_Type.Integer . at "X"
            c2.value_type.is_integer . should_be_true
            c2.to_vector . should_equal [42, 0, -1]

        Test.specify "should be able to parse simple floats" <|
            t = table_builder [["X", ["42.5", "0.25", "-1.0"]]]

            c1 = t.at "X" . parse Value_Type.Float
            c1.value_type.is_floating_point . should_be_true
            c1.to_vector . should_equal [42.5, 0.25, -1.0]

            c2 = t.parse ["X"] Value_Type.Float . at "X"
            c2.value_type.is_floating_point . should_be_true
            c2.to_vector . should_equal [42.5, 0.25, -1.0]

        if supports_dates then
            Test.specify "should be able to parse dates using a default format" <|
                t = table_builder [["X", ["2018-01-01", "2023-12-31"]]]

                c1 = t.at "X" . parse Value_Type.Date
                c1.value_type.should_equal Value_Type.Date
                c1.to_vector . should_equal [Date.new 2018 1 1, Date.new 2023 12 31]

                c2 = t.parse ["X"] Value_Type.Date . at "X"
                c2.value_type.should_equal Value_Type.Date
                c2.to_vector . should_equal [Date.new 2018 1 1, Date.new 2023 12 31]
        if supports_dates.not then
            Test.specify "should report that date parsing is unsupported" <|
                t = table_builder [["X", ["2018-01-01", "2023-12-31"]]]

                r1 = t.at "X" . parse Value_Type.Date
                r1.should_fail_with Unsupported_Database_Operation

                r2 = t.parse ["X"] Value_Type.Date
                r2.should_fail_with Unsupported_Database_Operation

        Test.specify "should be able to parse booleans with default format" <|
            t = table_builder [["X", ["true", "false", "true"]]]

            c1 = t.at "X" . parse Value_Type.Boolean
            c1.value_type.should_equal Value_Type.Boolean
            c1.to_vector . should_equal [True, False, True]

            c2 = t.parse ["X"] Value_Type.Boolean . at "X"
            c2.value_type.should_equal Value_Type.Boolean
            c2.to_vector . should_equal [True, False, True]

        Test.specify "should report missing columns" <|
            t = table_builder [["X", ["42", "0", "-1"]]]

            t1 = t.parse ["X", "Y"] Value_Type.Integer error_on_missing_columns=False
            t1.at "X" . to_vector . should_equal [42, 0, -1]
            t1.at "X" . value_type . is_integer . should_be_true
            Problems.expect_warning Missing_Input_Columns t1

            t2 = t.parse ["Y"] Value_Type.Integer error_on_missing_columns=False
            Problems.expect_warning Missing_Input_Columns t2
            t2.at "X" . to_vector . should_equal ["42", "0", "-1"]

            r3 = t.parse ["X", "Y"] Value_Type.Integer
            r3.should_fail_with Missing_Input_Columns
            r3.catch.criteria . should_equal ["Y"]

    if setup.is_database then Test.group prefix+"Table/Column auto value type" <|
        Test.specify "should report unsupported" <|
            t = table_builder [["X", [1, 2, 3]]]
            t.auto_value_types . should_fail_with Unsupported_Database_Operation
            t.at "X" . auto_value_type . should_fail_with Unsupported_Database_Operation

    # The in-memory functionality of `expand_column` is tested in test/Table_Tests/src/In_Memory/Table_Conversion_Spec.enso
    if setup.is_database then Test.group prefix+"Table.expand_column" <|
        Test.specify "should report unsupported" <|
            table = table_builder [["aaa", [1, 2]], ["bbb", [3, 4]], ["ccc", [5, 6]]]
            table.expand_column "bbb" . should_fail_with Unsupported_Database_Operation

    # The in-memory functionality of `expand_to_rows` is tested in test/Table_Tests/src/In_Memory/Table_Conversion_Spec.enso
    if setup.is_database then Test.group prefix+"Table.expand_to_rows" <|
        Test.specify "should report unsupported" <|
            table = table_builder [["aaa", [1, 2]], ["bbb", [3, 4]], ["ccc", [5, 6]]]
            table.expand_to_rows "bbb" . should_fail_with Unsupported_Database_Operation

    if setup.is_database.not then Test.group prefix+"Table/Column auto value type" <|
        Test.specify "should allow to narrow down types of a Mixed column" <|
            [True, False].each shrink_types->
                mixer = My_Type.Value 1
                t0 = table_builder [["strs", [mixer, "a", "b"]], ["ints", [mixer, 2, 3]], ["floats", [mixer, 1.5, 2.5]], ["mix", [1, mixer, "a"]], ["dates", [mixer, Date.new 2022, Date.new 2020]], ["datetimes", [mixer, Date_Time.new 2022 12 30 13 45, Date_Time.new 2020]], ["times", [mixer, Time_Of_Day.new 12 30, Time_Of_Day.new 13 45]], ["mixed_time", [Date.new 2022, Time_Of_Day.new 12 30, Date_Time.new 2019]], ["bools", [mixer, True, False]]]
                t1 = t0.drop 1

                t1.at "strs" . value_type . should_equal Value_Type.Mixed
                t1.at "ints" . value_type . should_equal Value_Type.Mixed
                t1.at "floats" . value_type . should_equal Value_Type.Mixed
                t1.at "mix" . value_type . should_equal Value_Type.Mixed
                t1.at "dates" . value_type . should_equal Value_Type.Mixed
                t1.at "datetimes" . value_type . should_equal Value_Type.Mixed
                t1.at "times" . value_type . should_equal Value_Type.Mixed
                t1.at "mixed_time" . value_type . should_equal Value_Type.Mixed
                t1.at "bools" . value_type . should_equal Value_Type.Mixed

                t2 = t1.auto_value_types shrink_types=shrink_types
                # Depending on shrink_types value the size of the Char/Integer types may vary - exact details tested elsewhere.
                t2.at "strs" . value_type . should_be_a (Value_Type.Char ...)
                t2.at "ints" . value_type . should_be_a (Value_Type.Integer ...)
                t2.at "floats" . value_type . should_equal Value_Type.Float
                t2.at "mix" . value_type . should_equal Value_Type.Mixed
                t2.at "dates" . value_type . should_equal Value_Type.Date
                t2.at "datetimes" . value_type . should_equal Value_Type.Date_Time
                t2.at "times" . value_type . should_equal Value_Type.Time
                t2.at "mixed_time" . value_type . should_equal Value_Type.Mixed
                t2.at "bools" . value_type . should_equal Value_Type.Boolean

        Test.specify "will only modify selected columns" <|
            mixer = My_Type.Value 1
            t0 = table_builder [["strs", [mixer, "a", "b"]], ["ints", [mixer, 2, 3]], ["floats", [mixer, 1.5, 2.5]]]
            t1 = t0.drop 1

            t2 = t1.auto_value_types []
            t2.at "strs" . value_type . should_equal Value_Type.Mixed
            t2.at "ints" . value_type . should_equal Value_Type.Mixed
            t2.at "floats" . value_type . should_equal Value_Type.Mixed

            t3 = t1.auto_value_types ["strs"]
            t3.at "strs" . value_type . should_equal Value_Type.Char
            t3.at "ints" . value_type . should_equal Value_Type.Mixed
            t3.at "floats" . value_type . should_equal Value_Type.Mixed

            # should match ints and floats but not strs
            t4 = t1.auto_value_types "[if].*".to_regex
            t4.at "strs" . value_type . should_equal Value_Type.Mixed
            t4.at "ints" . value_type . should_equal Value_Type.Integer
            t4.at "floats" . value_type . should_equal Value_Type.Float

        Test.specify "will convert a Float column to Integer if all values can be represented as long" <|
            t1 = table_builder [["X", [1.0, 2.0, 3.0]], ["Y", [1.0, 2.5, 3.0]], ["Z", [1.0, 2.0, (2.0^100)]]]
            t1.at "X" . value_type . should_equal Value_Type.Float
            t1.at "Y" . value_type . should_equal Value_Type.Float
            t1.at "Z" . value_type . should_equal Value_Type.Float

            t2 = t1.auto_value_types shrink_types=False
            t2.at "X" . to_vector . should_equal [1, 2, 3]
            t2.at "X" . value_type . should_equal (Value_Type.Integer Bits.Bits_64)
            t2.at "Y" . value_type . should_equal Value_Type.Float
            ## Technically, Z could get converted to Decimal type. But IMO that
               is not desirable - at this scale the Float is no longer a
               precise type (as not even consecutive integers are exactly
               representable). And Decimal is expected to be precise. So such a
               conversion should only happen by explicit request, not
               automatically.
            t2.at "Z" . value_type . should_equal Value_Type.Float

        Test.specify "will not parse text columns" <|
            t1 = table_builder [["X", ["1", "2", "3"]]]
            c2 = t1.at "X" . auto_value_type
            c2.value_type . should_equal Value_Type.Char

        Test.specify "will 'undo' a cast to Mixed" <|
            t1 = table_builder [["X", [1, 2, 3]], ["Y", ["a", "b", "c"]]]
            t2 = t1.cast ["X", "Y"] Value_Type.Mixed
            t2.at "X" . value_type . should_equal Value_Type.Mixed
            t2.at "Y" . value_type . should_equal Value_Type.Mixed

            t3 = t2.auto_value_types
            t3.at "X" . value_type . should_equal Value_Type.Integer
            t3.at "Y" . value_type . should_equal Value_Type.Char

        Test.specify "will choose Decimal type if all values are integers but cannot fit long" <|
            c0 = table_builder [["X", [My_Type.Value 42, 1, 2, (2^100)+1]]] . at "X"
            c1 = c0.drop 1

            c1.value_type . should_equal Value_Type.Mixed
            c2 = c1.auto_value_type
            c2.value_type . should_be_a (Value_Type.Decimal ...)
            c2.to_vector . should_equal [1, 2, (2^100)+1]

        Test.specify "will try to find the smallest integer type to fit the value (if shrink_types=True)" <|
            [False, True].each is_mixed->
                prefix = if is_mixed then "mixed" else 0
                t0 = table_builder [["X", [prefix, 1, 2, 3]], ["Y", [prefix, 2^20, 2, 3]], ["Z", [prefix, 2^50, 2, 3]], ["F", [prefix, 1.0, 2.0, 3.0]]]
                t1 = t0.drop 1

                case is_mixed of
                    True  -> t1.at "Z" . value_type . should_equal Value_Type.Mixed
                    False -> t1.at "Z" . value_type . should_equal (Value_Type.Integer Bits.Bits_64)

                case is_mixed of
                    True  -> t1.at "F" . value_type . should_equal Value_Type.Mixed
                    False -> t1.at "F" . value_type . should_equal Value_Type.Float

                t2 = t1.auto_value_types shrink_types=False
                t2.at "X" . value_type . should_equal (Value_Type.Integer Bits.Bits_64)
                t2.at "Y" . value_type . should_equal (Value_Type.Integer Bits.Bits_64)
                t2.at "Z" . value_type . should_equal (Value_Type.Integer Bits.Bits_64)
                t2.at "F" . value_type . should_equal (Value_Type.Integer Bits.Bits_64)

                t3 = t1.auto_value_types shrink_types=True
                # Even though X's values are small enough to fit in a Byte, we stick to 16-bit Integers.
                t3.at "X" . value_type . should_equal (Value_Type.Integer Bits.Bits_16)
                t3.at "Y" . value_type . should_equal (Value_Type.Integer Bits.Bits_32)
                t3.at "Z" . value_type . should_equal (Value_Type.Integer Bits.Bits_64)
                # Shrinking Floats also finds the smallest type that fits.
                t3.at "F" . value_type . should_equal (Value_Type.Integer Bits.Bits_16)

        Test.specify "will not return Byte columns by default, but should leave existing Byte columns intact" <|
            c1 = table_builder [["X", [1, 2, 3]]] . at "X" . cast Value_Type.Byte
            c1.value_type . should_equal Value_Type.Byte

            [True, False].each shrink_types->
                c2 = c1.auto_value_type shrink_types=shrink_types
                c2.value_type . should_equal Value_Type.Byte

        Test.specify "Decimal (scale=0, i.e. integer) columns should also be shrinked if possible and shrink_types=True" <|
            t0 = table_builder [["X", [2^100, 1, 2, 3]], ["Y", [10, 20, 2^100, 30]], ["Z", [1, 2, 3, 4]]] . cast "Z" (Value_Type.Decimal scale=0)
            t1 = t0.drop 1

            t1.at "X" . value_type . should_equal (Value_Type.Decimal scale=0)
            t1.at "Y" . value_type . should_equal (Value_Type.Decimal scale=0)
            t1.at "Z" . value_type . should_equal (Value_Type.Decimal scale=0)

            t2 = t1.auto_value_types shrink_types=False

            # Without shrinking we get an integer type, but not the smallest one - just the default 64-bit.
            t2.at "X" . to_vector . should_equal [1, 2, 3]
            t2.at "X" . value_type . should_equal (Value_Type.Integer Bits.Bits_64)
            t2.at "Y" . value_type . should_equal (Value_Type.Decimal scale=0)
            t2.at "Z" . value_type . should_equal (Value_Type.Integer Bits.Bits_64)

            t3 = t1.auto_value_types shrink_types=True
            t3.at "X" . value_type . should_equal (Value_Type.Integer Bits.Bits_16)
            t3.at "Y" . value_type . should_equal (Value_Type.Decimal scale=0)
            t3.at "Z" . value_type . should_equal (Value_Type.Integer Bits.Bits_16)

        Test.specify "if all text values have the same length, will change the type to fixed-length string (if shrink_types=True)" <|
            [False, True].each is_mixed->
                prefix = if is_mixed then 42 else "FOOBARBAZ"
                c0 = table_builder [["X", [prefix, "aa", "bb", "cc"]]] . at "X"
                c1 = c0.drop 1
                c1.to_vector . should_equal ["aa", "bb", "cc"]

                case is_mixed of
                    True  -> c1.value_type . should_equal Value_Type.Mixed
                    False -> c1.value_type . should_equal (Value_Type.Char size=Nothing variable_length=True)

                c2 = c1.auto_value_type shrink_types=False
                c2.value_type . should_equal (Value_Type.Char size=Nothing variable_length=True)

                c3 = c1.auto_value_type shrink_types=True
                c3.value_type . should_equal (Value_Type.Char size=2 variable_length=False)

            c4 = table_builder [["X", ["a", "x", "y"]]] . at "X" . cast (Value_Type.Char size=100 variable_length=True)
            c4.to_vector . should_equal ["a", "x", "y"]
            c4.value_type . should_equal (Value_Type.Char size=100 variable_length=True)

            c5 = c4.auto_value_type shrink_types=False
            c5.value_type . should_equal (Value_Type.Char size=100 variable_length=True)

            c6 = c4.auto_value_type shrink_types=True
            c6.value_type . should_equal (Value_Type.Char size=1 variable_length=False)

        Test.specify "if all text values are empty string, the type will remain unchanged" <|
            c1 = table_builder [["X", ["", ""]]] . at "X"
            c2 = c1.cast (Value_Type.Char size=100 variable_length=True)

            c1.value_type . should_equal (Value_Type.Char size=Nothing variable_length=True)
            c2.value_type . should_equal (Value_Type.Char size=100 variable_length=True)

            [True, False].each shrink_types->
                c1_b = c1.auto_value_type shrink_types=shrink_types
                c1_b.value_type . should_equal (Value_Type.Char size=Nothing variable_length=True)

                c2_b = c2.auto_value_type shrink_types=shrink_types
                c2_b.value_type . should_equal (Value_Type.Char size=100 variable_length=True)

        Test.specify "if all text values fit under 255 characters, will add a 255 length limit (if shrink_types=True)" <|
            t1 = table_builder [["short_unbounded", ["a", "bb", "ccc"]], ["long_unbounded", ["a"*100, "b"*200, "c"*300]]]

            t2 = t1 . set (t1.at "short_unbounded" . cast (Value_Type.Char size=1000)) "short_1000" . set (t1.at "short_unbounded" . cast (Value_Type.Char size=10)) "short_10" . set (t1.at "long_unbounded" . cast (Value_Type.Char size=400)) "long_400" . set (t1.at "short_unbounded" . cast Value_Type.Mixed) "short_mixed"
            t2.at "short_mixed" . value_type . should_equal Value_Type.Mixed

            t3 = t2.auto_value_types shrink_types=False
            t3.at "short_unbounded" . value_type . should_equal (Value_Type.Char size=Nothing variable_length=True)
            t3.at "short_1000" . value_type . should_equal (Value_Type.Char size=1000 variable_length=True)
            t3.at "short_10" . value_type . should_equal (Value_Type.Char size=10 variable_length=True)
            # Mixed column gets to be text again.
            t3.at "short_mixed" . value_type . should_equal (Value_Type.Char size=Nothing variable_length=True)
            t3.at "long_unbounded" . value_type . should_equal (Value_Type.Char size=Nothing variable_length=True)
            t3.at "long_400" . value_type . should_equal (Value_Type.Char size=400 variable_length=True)

            t4 = t2.auto_value_types shrink_types=True
            # Short ones get shortened to 255 unless they were shorter already.
            t4.at "short_unbounded" . value_type . should_equal (Value_Type.Char size=255 variable_length=True)
            t4.at "short_1000" . value_type . should_equal (Value_Type.Char size=255 variable_length=True)
            t4.at "short_10" . value_type . should_equal (Value_Type.Char size=10 variable_length=True)
            t4.at "short_mixed" . value_type . should_equal (Value_Type.Char size=255 variable_length=True)
            # Long ones cannot fit in 255 so they are kept as-is.
            t4.at "long_unbounded" . value_type . should_equal (Value_Type.Char size=Nothing variable_length=True)
            t4.at "long_400" . value_type . should_equal (Value_Type.Char size=400 variable_length=True)

        Test.specify "can deal with all-null columns" <|
            t0 = table_builder [["mix", [My_Type.Value 1, Nothing, Nothing]], ["int", [42, Nothing, Nothing]], ["str", ["a", Nothing, Nothing]], ["float", [1.5, Nothing, Nothing]], ["decimal", [2^100, 2^10, 2]]]
            t1 = t0.drop 1

            t1.at "mix" . value_type . should_equal Value_Type.Mixed
            t1.at "int" . value_type . should_equal Value_Type.Integer
            t1.at "float" . value_type . should_equal Value_Type.Float
            t1.at "str" . value_type . should_equal Value_Type.Char
            t1.at "decimal" . value_type . should_equal (Value_Type.Decimal scale=0)

            t2 = t1.auto_value_types shrink_types=False
            t2.at "mix" . value_type . should_equal Value_Type.Mixed
            t2.at "int" . value_type . should_equal Value_Type.Integer
            ## Technically, if there are no elements, "all of elements" are
               whole integers (quantification over empty domain is trivially true).
               However, that would be rather not useful, so instead we keep the
               original type.
            t2.at "float" . value_type . should_equal Value_Type.Float
            t1.at "decimal" . value_type . should_equal (Value_Type.Decimal scale=0)
            t2.at "str" . value_type . should_equal Value_Type.Char

            t3 = t1.auto_value_types shrink_types=True
            t3.at "mix" . value_type . should_equal Value_Type.Mixed
            # Technically, if there are no elements, then they can be fit inside of the smallest types available:
            t3.at "int" . value_type . should_equal (Value_Type.Integer Bits.Bits_16)
            t3.at "float" . value_type . should_equal Value_Type.Float
            t1.at "decimal" . value_type . should_equal (Value_Type.Decimal scale=0)
            # But for Text we make an exception and keep the type unbounded: 0-length fixed length string simply would not make any sense.
            t3.at "str" . value_type . should_equal (Value_Type.Char size=Nothing variable_length=True)
