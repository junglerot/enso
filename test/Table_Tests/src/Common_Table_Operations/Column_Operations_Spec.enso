from Standard.Base import all

import Standard.Base.Errors.Common.Arithmetic_Error
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument
import Standard.Base.Meta.Type
import Standard.Database.Data.Column.Column
import Standard.Database.Internal.Replace_Params.Replace_Params

from Standard.Table import Value_Type
from Standard.Table.Data.Type.Value_Type import Bits
from Standard.Table.Errors import all

from Standard.Database.Errors import all

from Standard.Test import Test, Problems
import Standard.Test.Extensions

from project.Common_Table_Operations.Util import run_default_backend

main = run_default_backend spec

spec setup =
    prefix = setup.prefix
    table_builder = setup.table_builder

    do_op n op =
        table = table_builder [["x", [n]]]
        result = table.at "x" |> op
        result.to_vector.at 0
    do_round n dp=0 use_bankers=False = do_op n (_.round dp use_bankers)

    Test.group prefix+"Boolean Column Operations" <|
        Test.specify "iif" <|
            t = table_builder [["X", [True, False, Nothing, True]]]
            c1 = t.at "X" . iif 22 33
            c1.to_vector . should_equal [22, 33, Nothing, 22]
            c1.value_type . is_integer . should_be_true

            c2 = t.at "X" . iif 22 33.0
            c2.to_vector . should_equal [22, 33, Nothing, 22]
            c2.value_type . is_floating_point . should_be_true

            c3 = t.at "X" . iif "A" "B"
            c3.to_vector . should_equal ["A", "B", Nothing, "A"]
            c3.value_type . is_text . should_be_true

            c4 = t.at "X" . iif Nothing "B"
            c4.to_vector . should_equal [Nothing, "B", Nothing, Nothing]
            c4.value_type . is_text . should_be_true

            c5 = t.at "X" . iif 42 Nothing
            c5.to_vector . should_equal [42, Nothing, Nothing, 42]
            c5.value_type . is_integer . should_be_true

            c6 = t.at "X" . iif Nothing Nothing
            c6.to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]

            t.at "X" . iif 22.0 False . should_fail_with No_Common_Type
            t.at "X" . iif 22 "0" . should_fail_with No_Common_Type

        Test.specify "iif on Columns" <|
            t1 = table_builder [["X", [True, False, Nothing, False]], ["Y", [1, 2, 3, 4]], ["Z", [1.5, 2.0, 3.5, 4.0]]]
            c1 = t1.at "X" . iif (t1.at "Y") (t1.at "Z")
            c1.value_type . is_floating_point . should_be_true
            c1.to_vector . should_equal [1, 2.0, Nothing, 4.0]

            t2 = table_builder [["X", [True, False]], ["Y", [1, 2]], ["Z", [1.5, 3.0]]]
            c2 = t2.at "X" . iif (t2.at "Y") (t2.at "Z")
            c2.to_vector . should_equal [1, 3]
            c2.value_type . is_floating_point . should_be_true

            t3 = table_builder [["X", [True, False]], ["Y", [10, 20]], ["Z", [False, True]]]
            t3.at "X" . iif (t3.at "Y") (t3.at "Z") . should_fail_with No_Common_Type
            t3.at "X" . iif (t3.at "Y") "<NA>" . should_fail_with No_Common_Type

        Test.specify "iif should correctly unify text columns of various lengths" pending=(if setup.test_selection.fixed_length_text_columns.not then "Fixed-length Char columns are not supported by this backend.") <|
            t0 = table_builder [["x", [False, True, False]], ["A", ["a", "b", "c"]], ["B", ["xyz", "abc", "def"]]]
            t1 = t0 . cast "A" (Value_Type.Char size=1 variable_length=False) . cast "B" (Value_Type.Char size=3 variable_length=False)

            x = t1.at "x"
            a = t1.at "A"
            b = t1.at "B"
            a.value_type.should_equal (Value_Type.Char size=1 variable_length=False)
            b.value_type.should_equal (Value_Type.Char size=3 variable_length=False)

            c = x.iif a b
            c.to_vector.should_equal ["xyz", "b", "def"]
            Test.with_clue "c.value_type="+c.value_type.to_display_text+": " <|
                c.value_type.variable_length.should_be_true

            d = b.cast (Value_Type.Char size=1 variable_length=False)
            e = x.iif a d
            e.to_vector.should_equal ["x", "b", "d"]
            e.value_type.should_equal (Value_Type.Char size=1 variable_length=False)

            f = b.cast (Value_Type.Char size=1 variable_length=True)
            g = x.iif a f
            g.to_vector.should_equal ["x", "b", "d"]
            Test.with_clue "g.value_type="+g.value_type.to_display_text+": " <|
                g.value_type.variable_length.should_be_true

        Test.specify "should allow to compute &&, || and not" <|
            t = table_builder [["X", [True, False, True]], ["Y", [True, False, False]]]
            x = t.at "X"
            y = t.at "Y"
            (x || y.not).to_vector . should_equal [True, True, True]
            (x || False).to_vector . should_equal [True, False, True]
            (x || True).to_vector . should_equal [True, True, True]
            (x && False).to_vector . should_equal [False, False, False]

        Test.specify "should return null if one of arguments is missing" pending="TODO null handling" <|
            t = table_builder [["X", [True, False, True]]]
            x = t.at "X"
            nulls = [Nothing, Nothing, Nothing, Nothing]
            (x && Nothing).to_vector . should_equal nulls
            (x || Nothing).to_vector . should_equal nulls

        Test.specify "should check types" <|
            t = table_builder [["X", [1, 2, 3]], ["Y", ['a', 'b', 'c']], ["Z", [True, False, Nothing]]]

            ((t.at "X") && (t.at "Z")) . should_fail_with Invalid_Value_Type
            ((t.at "Z") && (t.at "X")) . should_fail_with Invalid_Value_Type
            ((t.at "Y") && True) . should_fail_with Invalid_Value_Type

            ((t.at "X") || (t.at "Z")) . should_fail_with Invalid_Value_Type
            ((t.at "Z") || (t.at "X")) . should_fail_with Invalid_Value_Type
            ((t.at "Y") || True) . should_fail_with Invalid_Value_Type

            ((t.at "X") . not) . should_fail_with Invalid_Value_Type
            ((t.at "Y") . iif 10 20) . should_fail_with Invalid_Value_Type

    t2 = table_builder [["x", [1, 4, 5, Nothing]], ["y", [2.0, 3.25, 5.0, Nothing]]]
    x = t2.at "x"
    y = t2.at "y"
    Test.group prefix+"Column Operations - Equality & Null Handling" <|
        Test.specify "should provide basic == and != comparisons" pending="TODO figure out proper null handling" <|
            (x == y).to_vector . should_equal [False, False, True, Nothing]
            (x != y).to_vector . should_equal [True, True, False, Nothing]
            (x == 4).to_vector . should_equal [False, True, False, Nothing]
            (x == Nothing).to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]

        Test.specify "should allow to check which values are null"
            x.is_nothing.to_vector . should_equal [False, False, False, True]
            (x + Nothing).is_nothing.to_vector . should_equal [True, True, True, True]
            x.is_present.to_vector . should_equal [True, True, True, False]
            (x + Nothing).is_present.to_vector . should_equal [False, False, False, False]

        Test.specify "Column equality should handle nulls correctly" pending="TODO" <|
            a = [2, 3, Nothing, Nothing]
            b = [2, 4, Nothing, 5]
            r = [True, False, True, False]
            a.zip b (==) . should_equal r

            t = table_builder [["A", a], ["B", b]]
            c = (t.at "A") == (t.at "B")
            c.to_vector . should_equal r
            c.value_type.should_equal Value_Type.Boolean

        Test.specify "equals_ignore_case for ASCII strings" <|
            x = ["a", "B", "c", "DEF"]
            y = ["aa", "b", "c", "dEf"]
            r = [False, True, True, True]

            x.zip y (.equals_ignore_case) . should_equal r

            t = table_builder [["X", x], ["Y", y]]
            c = (t.at "X") . equals_ignore_case (t.at "Y")
            c.to_vector . should_equal r
            c.value_type.should_equal Value_Type.Boolean
            (t.at "X") . equals_ignore_case "Def" . to_vector . should_equal [False, False, False, True]

        Test.specify "equals_ignore_case should check types" <|
            t = table_builder [["X", [1, 2, 3]], ["Y", ['a', 'b', 'c']]]

            r1 = (t.at "X") . equals_ignore_case (t.at "Y") . to_vector
            r1.should_fail_with Invalid_Value_Type

            r2 = (t.at "Y") . equals_ignore_case (t.at "X") . to_vector
            r2.should_fail_with Invalid_Value_Type

            r3 = (t.at "Y") . equals_ignore_case 42 . to_vector
            r3.should_fail_with Invalid_Value_Type

        Test.specify "Text Column equality (including case-insensitive) should handle nulls correctly" pending="TODO" <|
            a = ["Z", "a", "b", Nothing, Nothing]
            b = ["Z", "A", "C", Nothing, "d"]
            r_sensitive   = [True, False, False, True, False]
            r_insensitive = [True, True,  False, True, False]

            a.zip b (==) . should_equal r_sensitive
            a.zip b (x-> y-> if x.is_nothing || y.is_nothing then x == y else x.equals_ignore_case y) . should_equal r_insensitive

            t = table_builder [["A", a], ["B", b]]
            ((t.at "A") == (t.at "B")) . to_vector . should_equal r_sensitive
            ((t.at "A").equals_ignore_case (t.at "B")) . to_vector . should_equal r_insensitive

        Test.specify "should report a warning if checking equality on floating point columns" <|
            t = table_builder [["X", [1.0, 2.1, 3.2]], ["Y", [1.0, 2.0, 3.2]]]

            r1 = (t.at "X") == (t.at "Y")
            r1.to_vector . should_equal [True, False, True]
            Problems.expect_warning Floating_Point_Equality r1

            r2 = (t.at "X") != (t.at "Y")
            r2.to_vector . should_equal [False, True, False]
            Problems.expect_warning Floating_Point_Equality r2

    Test.group prefix+"Column.fill_nothing/empty" <|
        Test.specify "should allow to fill_nothing from a value" <|
            col = table_builder [["col", [0, Nothing, 4, 5, Nothing, Nothing]]] . at "col"
            default = 300
            r = col.fill_nothing default
            r.to_vector . should_equal [0, 300, 4, 5, 300, 300]
            r.name . should_equal "col"

        Test.specify "should allow to fill_nothing from another column" <|
            t = table_builder [["col", [0, Nothing, 4, 5, Nothing, Nothing]], ["def", [1, 2, 10, 20, Nothing, 30]]]
            r = t.at "col" . fill_nothing (t.at "def")
            r.to_vector . should_equal [0, 2, 4, 5, Nothing, 30]
            r.name . should_equal "col"

        Test.specify "should allow to fill_empty from a value" <|
            col = table_builder [["col", ["0", Nothing, "4", "5", Nothing, Nothing]]] . at "col"
            default = "default"
            r = col.fill_empty default
            r.to_vector . should_equal ["0", "default", "4", "5", "default", "default"]
            r.name . should_equal "col"

        Test.specify "should allow to fill_empty from another column" <|
            t = table_builder [["col", ["0", Nothing, "4", "5", Nothing, Nothing]], ["def", ["1", "2", "10", "20", Nothing, "30"]]]
            r = t.at "col" . fill_nothing (t.at "def")
            r.to_vector . should_equal ["0", "2", "4", "5", Nothing, "30"]
            r.name . should_equal "col"

    Test.group prefix+"Table.fill_nothing/empty" <|
        Test.specify "should allow to fill_nothing from a value" <|
            t = table_builder [["col0", [0, Nothing, 4, 5, Nothing, Nothing]], ["col1", [Nothing, 200, Nothing, 400, 500, Nothing]]]
            default = 1000
            actual = t.fill_nothing ["col0", "col1"] default
            actual.at "col0" . to_vector . should_equal [0, 1000, 4, 5, 1000, 1000]
            actual.at "col1" . to_vector . should_equal [1000, 200, 1000, 400, 500, 1000]

        Test.specify "should allow to fill_nothing from other columns" <|
            t = table_builder [["col0", [0, Nothing, 4, 5, Nothing, Nothing]], ["col1", [Nothing, 200, Nothing, 400, 500, Nothing]], ["def", [1, 2, 10, 20, Nothing, 30]]]
            actual = t.fill_nothing ["col0", "col1"] (t.at "def")
            actual.at "col0" . to_vector . should_equal [0, 2, 4, 5, Nothing, 30]
            actual.at "col1" . to_vector . should_equal [1, 200, 10, 400, 500, 30]

        Test.specify "should allow to fill_empty from a value" <|
            t = table_builder [["col0", ["0", Nothing, "4", "5", Nothing, Nothing]], ["col1", [Nothing, "200", Nothing, "400", "500", Nothing]]]
            default = "1000"
            actual = t.fill_empty ["col0", "col1"] default
            actual.at "col0" . to_vector . should_equal ["0", "1000", "4", "5", "1000", "1000"]
            actual.at "col1" . to_vector . should_equal ["1000", "200", "1000", "400", "500", "1000"]

        Test.specify "should allow to fill_empty from other columns" <|
            t = table_builder [["col0", ["0", Nothing, "4", "5", Nothing, Nothing]], ["col1", [Nothing, "200", Nothing, "400", "500", Nothing]], ["def", ["1", "2", "10", "20", Nothing, "30"]]]
            actual = t.fill_empty ["col0", "col1"] (t.at "def")
            actual.at "col0" . to_vector . should_equal ["0", "2", "4", "5", Nothing, "30"]
            actual.at "col1" . to_vector . should_equal ["1", "200", "10", "400", "500", "30"]

        Test.specify "fill_nothing should leave other columns alone" <|
            t = table_builder [["col0", [0, Nothing, 4, 5, Nothing, Nothing]], ["col_between", [3, 4, 5, 6, 7, 8]], ["col1", [Nothing, 200, Nothing, 400, 500, Nothing]], ["def", [1, 2, 10, 20, Nothing, 30]]]
            default = 1000
            actual = t.fill_nothing ["col0", "col1"] default
            actual.at "col0" . to_vector . should_equal [0, 1000, 4, 5, 1000, 1000]
            actual.at "col_between" . to_vector . should_equal [3, 4, 5, 6, 7, 8]
            actual.at "col1" . to_vector . should_equal [1000, 200, 1000, 400, 500, 1000]
            actual.column_names . should_equal ["col0", "col_between", "col1", "def"]

        Test.specify "fill_nothing should work with integer column selectors" <|
            t = table_builder [["col0", [0, Nothing, 4, 5, Nothing, Nothing]], ["col_between", [3, 4, 5, 6, 7, 8]], ["col1", [Nothing, 200, Nothing, 400, 500, Nothing]], ["def", [1, 2, 10, 20, Nothing, 30]]]
            default = 1000
            actual = t.fill_nothing [0, 2] default
            actual.at "col0" . to_vector . should_equal [0, 1000, 4, 5, 1000, 1000]
            actual.at "col_between" . to_vector . should_equal [3, 4, 5, 6, 7, 8]
            actual.at "col1" . to_vector . should_equal [1000, 200, 1000, 400, 500, 1000]
            actual.column_names . should_equal ["col0", "col_between", "col1", "def"]

    Test.group prefix+"Table.replace" <|
        if setup.is_database.not then
            Test.specify "should allow to replace values in a table" <|
                t = table_builder [["col0", ["abc", "def", "ghi"]], ["col1", ["nabc", "ndef", "asdf"]]]
                actual = t.replace ["col0", "col1"] "ab" "xy"
                actual.at "col0" . to_vector . should_equal ["xyc", "def", "ghi"]
                actual.at "col1" . to_vector . should_equal ["nxyc", "ndef", "asdf"]

            Test.specify "should allow to replace values in a table with a regex" <|
                t = table_builder [["col0", ["abc", "def", "ghi"]], ["col1", ["nabc", "ndef", "asdf"]]]
                actual = t.replace ["col0", "col1"] "[bdi]".to_regex "xy"
                actual.at "col0" . to_vector . should_equal ["axyc", "xyef", "ghxy"]
                actual.at "col1" . to_vector . should_equal ["naxyc", "nxyef", "asxyf"]

            Test.specify "should allow to replace values in a table with a column" <|
                t = table_builder [["col0", ["abc", "def", "ghi"]], ["col1", ["nabc", "ndef", "asdf"]], ["col2", ["xy", "yx", "zz"]]]
                actual = t.replace ["col0", "col1"] "[bdi]".to_regex (t.at "col2")
                actual.at "col0" . to_vector . should_equal ["axyc", "yxef", "ghzz"]
                actual.at "col1" . to_vector . should_equal ["naxyc", "nyxef", "aszzf"]
                actual.at "col2" . to_vector . should_equal ["xy", "yx", "zz"]

    Test.group prefix+"Column Comparisons" <|
        Test.specify "should allow to compare numbers" <|
            x.value_type . is_integer . should_be_true
            y.value_type . is_floating_point . should_be_true

            (x < y).to_vector . should_equal [True, False, False, Nothing]
            (x <= y).to_vector . should_equal [True, False, True, Nothing]
            (x > y).to_vector . should_equal (x <= y).not.to_vector
            (x >= y).to_vector . should_equal (x < y).not.to_vector

            (x < 1000).to_vector . should_equal [True, True, True, Nothing]

            [(<), (<=), (>), (>=)].each op->
                op x y . value_type . should_equal Value_Type.Boolean
                op x y . to_vector . should_succeed
                op x 23 . to_vector . should_succeed
                op y 23 . to_vector . should_succeed
                op x 1.5 . to_vector . should_succeed

        Test.specify "should allow to compare texts" <|
            t0 = table_builder [["X", ["a", "b", "c"]], ["Y", ["a", "b", "d"]]]
            t = t0.cast "X" (Value_Type.Char size=1 variable_length=False)

            [(<), (<=), (>), (>=)].each op->
                op (t.at "X") (t.at "Y") . value_type . should_equal Value_Type.Boolean
                op (t.at "X") (t.at "Y") . to_vector . should_succeed
                op (t.at "X") "abc" . to_vector . should_succeed

        Test.specify "should allow to compare booleans" <|
            t = table_builder [["X", [True, False, True]], ["Y", [False, True, True]]]

            ((t.at "X") < (t.at "Y")).to_vector . should_equal [False, True, False]
            ((t.at "X") >= (t.at "Y")).to_vector . should_equal [True, False, True]
            ((t.at "X") <= (t.at "Y")).to_vector . should_equal [False, True, True]
            ((t.at "X") > (t.at "Y")).to_vector . should_equal [True, False, False]

            ((t.at "X") < True).to_vector . should_equal [False, True, False]
            ((t.at "X") >= True).to_vector . should_equal [True, False, True]
            ((t.at "X") <= True).to_vector . should_equal [True, True, True]
            ((t.at "X") > True).to_vector . should_equal [False, False, False]

        Test.specify "should report error if incomparable types are compared" <|
            t = table_builder [["X", [1, 2]], ["Y", ["a", "b"]], ["Z", [True, False]]]

            [(<), (<=), (>), (>=)].each op->
                r1 = op (t.at "X") (t.at "Y")
                r1.should_fail_with Invalid_Value_Type
                r1.catch . should_be_a Invalid_Value_Type.Incomparable

                op (t.at "X") "FOO" . should_fail_with Invalid_Value_Type
                op (t.at "Y") 42 . should_fail_with Invalid_Value_Type
                op (t.at "Y") False . should_fail_with Invalid_Value_Type
                op (t.at "Z") 32 . should_fail_with Invalid_Value_Type
                op (t.at "Z") (t.at "X") . should_fail_with Invalid_Value_Type

        Test.specify "Between should return null if any of the values are null" pending="TODO" <|
            a = [2, 3, Nothing, 7,       5,       Nothing]
            b = [0, 5, 7,       Nothing, 7,       Nothing]
            c = [9, 8, 7,       7,       Nothing, Nothing]
            r = [True, False, Nothing, Nothing, Nothing, Nothing]

            t = table_builder [["A", a], ["B", b], ["C", c]]
            ((t.at "A").between (t.at "B") (t.at "C")) . to_vector . should_equal r

    Test.group prefix+"Arithmetic Column Operations" <|
        Test.specify "should allow basic operations" <|
            (x + y).to_vector . should_equal [3, 7.25, 10, Nothing]
            (x - y).to_vector . should_equal [-1.0, 0.75, 0.0, Nothing]
            (x * y).to_vector . should_equal [2.0, 13.0, 25.0, Nothing]

        Test.specify "should allow combining a column with a scalar" pending="TODO null handling" <|
            (x + 100).to_vector . should_equal [101, 104, 105, Nothing]
            (x * 10).to_vector . should_equal [10, 40, 50, Nothing]
            (x - 10).to_vector . should_equal [-9, -6, -5, Nothing]

        Test.specify "should correctly infer the types" <|
            (x + x).value_type . is_integer . should_be_true
            (x + y).value_type . is_floating_point . should_be_true
            (x + 2).value_type . is_integer . should_be_true
            (x + 1.5).value_type . is_floating_point . should_be_true

            (x - x).value_type . is_integer . should_be_true
            (x - y).value_type . is_floating_point . should_be_true
            (x - 2).value_type . is_integer . should_be_true
            (x - 1.5).value_type . is_floating_point . should_be_true

            (x * x).value_type . is_integer . should_be_true
            (x * y).value_type . is_floating_point . should_be_true
            (x * 2).value_type . is_integer . should_be_true
            (x * 1.5).value_type . is_floating_point . should_be_true

            (x ^ x).value_type . is_numeric . should_be_true

        Test.specify "should check types" <|
            t = table_builder [["X", [1, 2]], ["Y", ["a", "b"]], ["Z", [True, False]]]
            x = t.at "X"
            y = t.at "Y"
            z = t.at "Z"

            (x + z) . should_fail_with Illegal_Argument
            (x + False) . should_fail_with Illegal_Argument

            # Mixing text and integers should not be allowed
            (x + y) . should_fail_with Illegal_Argument
            (x + "foo") . should_fail_with Illegal_Argument

            (x - z).should_fail_with Invalid_Value_Type
            (x - "a").should_fail_with Invalid_Value_Type
            (y - "a").should_fail_with Invalid_Value_Type
            (y - 42).should_fail_with Invalid_Value_Type

            (x * z).should_fail_with Invalid_Value_Type
            (x * "a").should_fail_with Invalid_Value_Type
            (y * "a").should_fail_with Invalid_Value_Type
            (y * 42).should_fail_with Invalid_Value_Type

            (x / z).should_fail_with Invalid_Value_Type
            (x / "a").should_fail_with Invalid_Value_Type
            (y / "a").should_fail_with Invalid_Value_Type
            (y / 42).should_fail_with Invalid_Value_Type

            (x ^ z).should_fail_with Invalid_Value_Type
            (x ^ "a").should_fail_with Invalid_Value_Type
            (y ^ "a").should_fail_with Invalid_Value_Type
            (y ^ 42).should_fail_with Invalid_Value_Type

        case setup.test_selection.is_nan_and_nothing_distinct of
            True ->
                t = table_builder [["X", [1.5, 3.0, Number.positive_infinity, Number.negative_infinity, Number.nan, Nothing]], ["Y", [1, 2, 3, 4, 5, Nothing]], ["Z", ["1", "2", "3", "4", "5", Nothing]]]

                Test.specify "should support is_nan" <|
                    t.at "X" . is_nan . to_vector . should_equal [False, False, False, False, True, Nothing]
                    t.at "Y" . is_nan . to_vector . should_equal [False, False, False, False, False, Nothing]
                    t.at "Z" . is_nan . to_vector . should_fail_with Invalid_Value_Type

                Test.specify "should support is_infinite" <|
                    t.at "X" . is_infinite . to_vector . should_equal [False, False, True, True, False, Nothing]
                    t.at "Y" . is_infinite . to_vector . should_equal [False, False, False, False, False, Nothing]
                    t.at "Z" . is_infinite . to_vector . should_fail_with Invalid_Value_Type
            False ->
                Test.specify "should report that is_nan is not supported" <|
                    t = table_builder [["X", [1.5]]]
                    t.at "X" . is_nan . should_fail_with Unsupported_Database_Operation

                Test.specify "should support is_infinite" <|
                    t = table_builder [["X", [1.5, 3.0, Number.positive_infinity, Number.negative_infinity, Nothing]], ["Y", [1, 2, 3, 4, Nothing]], ["Z", ["1", "2", "3", "4", Nothing]]]
                    t.at "X" . is_infinite . to_vector . should_equal [False, False, True, True, Nothing]
                    t.at "Y" . is_infinite . to_vector . should_equal [False, False, False, False, Nothing]
                    t.at "Z" . is_infinite . to_vector . should_fail_with Invalid_Value_Type

        Test.specify "should support is_blank" <|
            t = table_builder [["X", [1.5, 2, Number.nan, Nothing]], ["Y", [1, Nothing, 3, 4]]]
            t.at "X" . is_blank treat_nans_as_blank=True . to_vector . should_equal [False, False, True, True]
            t.at "Y" . is_blank treat_nans_as_blank=True . to_vector . should_equal [False, True, False, False]

        Test.specify "division should be aligned with the Enso arithmetic" <|
            a = [1, 5, 10, 100]
            b = [2, 2, 4, 5]
            r = [0.5, 2.5, 2.5, 20.0]
            a.zip b (/) . should_equal r

            t = table_builder [["A", a], ["B", b]]
            t.at "A" . value_type . is_integer . should_be_true
            t.at "B" . value_type . is_integer . should_be_true

            r2 = (t.at "A") / (t.at "B")
            r2 . to_vector . should_equal r
            r2.value_type . is_floating_point . should_be_true

            r3 = (t.at "A") / 2
            r3 . to_vector . should_equal [0.5, 2.5, 5.0, 50.0]
            r3.value_type . is_floating_point . should_be_true

            a2 = [1.2, 5, 10.2, 100]
            b2 = [1.2, 2, 2, 5]
            r4 = [1.0, 2.5, 5.1, 20.0]
            a2.zip b2 (/) . should_equal r4

            t2 = table_builder [["A", a2], ["B", b2]]
            t2.at "A" . value_type . is_floating_point . should_be_true
            t2.at "B" . value_type . is_floating_point . should_be_true

            r5 = (t2.at "A") / (t2.at "B")
            r5 . to_vector . should_equal r4
            r5.value_type . is_floating_point . should_be_true

            r6 = (t2.at "A") / 2
            r6 . to_vector . should_equal [0.6, 2.5, 5.1, 50.0]
            r6.value_type . is_floating_point . should_be_true

        db_pending = if setup.is_database then "Arithmetic error handling is currently not implemented for the Database backend."
        Test.specify "should allow division by 0 and report warnings" pending=db_pending <|
            t = table_builder [["a", [3, 1, 0]], ["b", [2, 0, 0]], ["c", [1.5, 1.5, 0.0]], ["d", [1.5, 0.0, 0.0]]]
            a = t.at "a"
            b = t.at "b"
            c = t.at "c"
            d = t.at "d"

            has_div_warnings location expected_rows result =
                Test.with_clue location <|
                    warnings = Problems.get_attached_warnings result
                    msg = "Division by zero (at rows " + expected_rows.to_text + ")."
                    warnings.first . should_equal (Arithmetic_Error.Error msg)

            r1 = a / b
            r1.to_vector.to_text . should_equal "[1.5, Infinity, NaN]"
            has_div_warnings "[a] / [b]" [1, 2] r1
            r2 = c / d
            r2.to_vector.to_text . should_equal "[1.0, Infinity, NaN]"
            has_div_warnings "[c] / [d]" [1, 2] r2
            r3 = a / d
            r3.to_vector.to_text . should_equal "[2.0, Infinity, NaN]"
            has_div_warnings "[a] / [d]" [1, 2] r3
            r4 = a / 0
            r4.to_vector.to_text . should_equal "[Infinity, Infinity, NaN]"
            has_div_warnings "[a] / 0" [0, 1, 2] r4
            r5 = c / 0
            r5.to_vector.to_text . should_equal "[Infinity, Infinity, NaN]"
            has_div_warnings "[c] / 0" [0, 1, 2] r5

            r6 = a % b
            r6.to_vector.to_text . should_equal "[1, Nothing, Nothing]"
            has_div_warnings "[a] % [b]" [1, 2] r6
            r7 = c % d
            r7.to_vector.to_text . should_equal "[0.0, NaN, NaN]"
            has_div_warnings "[c] % [d]" [1, 2] r7
            r8 = a % d
            r8.to_vector.to_text . should_equal "[0.0, NaN, NaN]"
            has_div_warnings "[a] % [d]" [1, 2] r8
            r9 = a % 0
            r9.to_vector.to_text . should_equal "[Nothing, Nothing, Nothing]"
            has_div_warnings "[a] % 0" [0, 1, 2] r9
            r10 = c % 0
            r10.to_vector.to_text . should_equal "[NaN, NaN, NaN]"
            has_div_warnings "[c] % 0" [0, 1, 2] r10

        Test.specify "should limit the number of rows listed in the message" pending=db_pending <|
            t1 = table_builder [["a", 0.up_to 200 . to_vector]]
            zero = t1.at "a" - t1.at "a"
            div = t1.at "a" / zero
            warnings = Problems.get_attached_warnings div
            warnings.not_empty.should_be_true
            warning = warnings.first
            warning.should_be_a Arithmetic_Error
            warning.message . should_equal "Division by zero (at rows [0, 1, 2, 3, 4, 5, 6, 7, 8, ...])."

        Test.specify "should return null if one of arguments is missing" <|
            nulls = [Nothing, Nothing, Nothing, Nothing]
            (x + Nothing).to_vector . should_equal nulls
            (x - Nothing).to_vector . should_equal nulls
            (x * Nothing).to_vector . should_equal nulls
            (x / Nothing).to_vector . should_equal nulls

    Test.group prefix+"Rounding-like operations" <|
        Test.specify "should name a rounding column correctly" <|
            table = table_builder [["x", [0.1, 0.9, 3.1, 3.9, -0.1, -0.9, -3.1, -3.9]]]
            table.at "x" . round . name . should_equal "round([x])"

        test_floatlike type =
            Test.specify "should allow round on a "+type.to_text+" column" <|
                table = table_builder [["x", [0.1, 0.9, 3.1, 3.9, -0.1, -0.9, -3.1, -3.9]]]
                result = table.at "x" . cast type . round
                result.to_vector.should_equal [0, 1, 3, 4, 0, -1, -3, -4]

            Test.specify "should allow round on a float column (to >0 decimal places)" <|
                table = table_builder [["x", [0.51, 0.59, 3.51, 3.59, -0.51, -0.59, -3.51, -3.59]]]
                result = table.at "x" . cast type . round 1
                result.to_vector.should_equal [0.5, 0.6, 3.5, 3.6, -0.5, -0.6, -3.5, -3.6]

            Test.specify "should allow round on a float column (to <0 decimal places)" <|
                table = table_builder [["x", [51.2, 59.3, 351.45, 359.11, -51.2, -59.3, -351.23, -359.69]]]
                result = table.at "x" . cast type . round -1
                result.to_vector.should_equal [50.0, 60.0, 350.0, 360.0, -50.0, -60.0, -350.0, -360.0]

            Test.specify "should allow truncate on a "+type.to_text+" column" <|
                table = table_builder [["x", [0.1, 0.9, 3.1, 3.9, -0.1, -0.9, -3.1, -3.9]]]
                result = table.at "x" . cast type . truncate
                result.to_vector.should_equal [0, 0, 3, 3, 0, 0, -3, -3]

            Test.specify "should allow ceil on a "+type.to_text+" column" <|
                table = table_builder [["x", [0.1, 0.9, 3.1, 3.9, -0.1, -0.9, -3.1, -3.9]]]
                result = table.at "x" . cast type . ceil
                result.to_vector.should_equal [1, 1, 4, 4, 0, 0, -3, -3]

            Test.specify "should allow floor on a "+type.to_text+" column" <|
                table = table_builder [["x", [0.1, 0.9, 3.1, 3.9, -0.1, -0.9, -3.1, -3.9]]]
                result = table.at "x" . cast type . floor
                result.to_vector.should_equal [0, 0, 3, 3, -1, -1, -4, -4]

        test_floatlike Value_Type.Float
        if setup.test_selection.supports_decimal_type then
            test_floatlike Value_Type.Decimal

        Test.specify "should allow round on an int column" <|
            table = table_builder [["x", [1, 9, 31, 39, -1, -9, -31, -39]]]
            result = table.at "x" . round -1
            result.to_vector.should_equal [0, 10, 30, 40, 0, -10, -30, -40]

        Test.specify "should allow truncate on an int column" <|
            table = table_builder [["x", [0, 3, -3, 1, -2]]]
            result = table.at "x" . truncate
            result.to_vector.should_equal [0, 3, -3, 1, -2]

        Test.specify "should allow ceil on an int column" <|
            table = table_builder [["x", [0, 3, -3, 1, -2]]]
            result = table.at "x" . ceil
            result.to_vector.should_equal [0, 3, -3, 1, -2]

        Test.specify "should allow floor on an int column" <|
            table = table_builder [["x", [0, 3, -3, 1, -2]]]
            result = table.at "x" . floor
            result.to_vector.should_equal [0, 3, -3, 1, -2]

        Test.specify "should fail on decimal_places out of range" <|
            table = table_builder [["x", [0, 3, -3, 1, -2]]]
            table.at "x" . round 16 . should_fail_with Illegal_Argument

        if setup.test_selection.supports_decimal_type then
            Test.specify "should return decimals when rounding decimals" <|
                i1 = 9223372036854775807 - 1
                c = table_builder [["X", [i1]]] . at "X"
                decimal_col = c.cast Value_Type.Decimal
                decimal_col.value_type.is_decimal . should_be_true
                decimal_col2 = decimal_col + decimal_col*decimal_col
                [(.floor), (.ceil), (.truncate), (x-> x.round 0), (x-> x.round 2)].each op->
                    op decimal_col2 . to_vector . should_equal [i1 + i1*i1]

        Test.specify "should allow Nothing/NULL" <|
            table = table_builder [["x", [Nothing, 0.51, 0.59, 3.51, Nothing, 3.59, -0.51, -0.59, -3.51, -3.59]]]
            result = table.at "x" . round 1
            result.to_vector.should_equal [Nothing, 0.5, 0.6, 3.5, Nothing, 3.6, -0.5, -0.6, -3.5, -3.6]

        Test.specify "should fail on bad column type" <|
            table = table_builder [["x", ["a", "b"]]]
            table.at "x" . round . should_fail_with Invalid_Value_Type

    Test.group prefix+"Rounding numeric tests" <|
        Test.specify "Can round positive decimals correctly" <|
            do_round 3.0 . should_equal 3
            do_round 3.00001 . should_equal 3
            do_round 3.3 . should_equal 3
            do_round 3.49999 . should_equal 3
            do_round 3.5 . should_equal 4
            do_round 3.50001 . should_equal 4
            do_round 3.99999 . should_equal 4

        Test.specify "Can round negative decimals correctly" <|
            do_round -3.0 . should_equal -3
            do_round -3.00001 . should_equal -3
            do_round -3.3 . should_equal -3
            do_round -3.49999 . should_equal -3
            do_round -3.5 . should_equal -4
            do_round -3.50001 . should_equal -4
            do_round -3.99999 . should_equal -4

        Test.specify "Explicit and implicit 0 decimal places work the same" <|
            do_round 3.00001 0 . should_equal 3
            do_round 3.3 0 . should_equal 3
            do_round 3.00001 . should_equal 3
            do_round 3.3 . should_equal 3

        Test.specify "Can round zero and small decimals correctly" <|
            do_round 0.0 . should_equal 0
            do_round 0.00001 . should_equal 0
            do_round -0.00001 . should_equal 0

        Test.specify "Can round decimals to a specified number of decimal places" <|
            do_round 3.0001 2 . should_equal 3.0
            do_round 3.1414 2 . should_equal 3.14
            do_round 3.1415 2 . should_equal 3.14
            do_round 3.1416 2 . should_equal 3.14
            do_round 3.9999 2 . should_equal 4.0

            do_round 3.0001 3 . should_equal 3.0
            do_round 3.1414 3 . should_equal 3.141
            do_round 3.1415 3 . should_equal 3.142
            do_round 3.1416 3 . should_equal 3.142
            do_round 3.9999 3 . should_equal 4.0

        Test.specify "Can round positive decimals to a specified negative number of decimal places" <|
            do_round 1234.0 -1 . should_equal 1230
            do_round 1234.0 -2 . should_equal 1200
            do_round 1234.0 -3 . should_equal 1000
            do_round 1234.0 -4 . should_equal 0

            do_round 1499.0 -1 . should_equal 1500
            do_round 1499.0 -2 . should_equal 1500
            do_round 1499.0 -3 . should_equal 1000

            do_round 1495.0 -1 . should_equal 1500
            do_round 1494.0 -1 . should_equal 1490
            do_round 1495.0 -2 . should_equal 1500
            do_round 1494.0 -2 . should_equal 1500

        Test.specify "Can round negative decimals to a specified negative number of decimal places" <|
            do_round -1234.0 -1 . should_equal -1230
            do_round -1234.0 -2 . should_equal -1200
            do_round -1234.0 -3 . should_equal -1000
            do_round -1234.0 -4 . should_equal 0

            do_round -1499.0 -1 . should_equal -1500
            do_round -1499.0 -2 . should_equal -1500
            do_round -1499.0 -3 . should_equal -1000

            do_round -1495.0 -1 . should_equal -1500
            do_round -1494.0 -1 . should_equal -1490
            do_round -1495.0 -2 . should_equal -1500
            do_round -1494.0 -2 . should_equal -1500

        Test.specify "Banker's rounding handles half-way values correctly" <|
            do_round -3.5 use_bankers=True . should_equal -4
            do_round -2.5 use_bankers=True . should_equal -2
            do_round -1.5 use_bankers=True . should_equal -2
            do_round -0.5 use_bankers=True . should_equal 0
            do_round 0.5 use_bankers=True . should_equal 0
            do_round 1.5 use_bankers=True . should_equal 2
            do_round 2.5 use_bankers=True . should_equal 2
            do_round 3.5 use_bankers=True . should_equal 4

            do_round 0.235 2 use_bankers=True . should_equal 0.24
            do_round 0.225 2 use_bankers=True . should_equal 0.22
            do_round -0.235 2 use_bankers=True . should_equal -0.24
            do_round -0.225 2 use_bankers=True . should_equal -0.22

            do_round 12350.0 -2 use_bankers=True . should_equal 12400
            do_round 12250.0 -2 use_bankers=True . should_equal 12200
            do_round -12350.0 -2 use_bankers=True . should_equal -12400
            do_round -12250.0 -2 use_bankers=True . should_equal -12200

        Test.specify "Banker's rounding handles non-half-way values just like normal rounding" <|
            do_round 3.0 use_bankers=True . should_equal 3
            do_round 3.00001 use_bankers=True . should_equal 3
            do_round 3.3 use_bankers=True . should_equal 3
            do_round 3.49999 use_bankers=True . should_equal 3
            do_round 3.50001 use_bankers=True . should_equal 4
            do_round 3.99999 use_bankers=True . should_equal 4

            do_round -3.0 . should_equal -3
            do_round -3.00001 . should_equal -3
            do_round -3.3 . should_equal -3
            do_round -3.49999 . should_equal -3
            do_round -3.50001 . should_equal -4
            do_round -3.99999 . should_equal -4

        Test.specify "Can round correctly near the precision limit" <|
            do_round 1.22222222225 10 . should_equal 1.2222222223
            do_round 1.222222222225 11 . should_equal 1.22222222223
            do_round 1.2222222222225 12 . should_equal 1.222222222223
            do_round 1.22222222222225 13 . should_equal 1.2222222222223
            do_round 1.222222222222225 14 . should_equal 1.22222222222223

            do_round -1.22222222225 10 . should_equal -1.2222222223
            do_round -1.222222222225 11 . should_equal -1.22222222223
            do_round -1.2222222222225 12 . should_equal -1.222222222223
            do_round -1.22222222222225 13 . should_equal -1.2222222222223
            do_round -1.222222222222225 14 . should_equal -1.22222222222223

            do_round 1.22222222235 10 . should_equal 1.2222222224
            do_round 1.222222222235 11 . should_equal 1.22222222224
            do_round 1.2222222222235 12 . should_equal 1.222222222224
            do_round 1.22222222222235 13 . should_equal 1.2222222222224
            do_round 1.222222222222235 14 . should_equal 1.22222222222224

            do_round -1.22222222235 10 . should_equal -1.2222222224
            do_round -1.222222222235 11 . should_equal -1.22222222224
            do_round -1.2222222222235 12 . should_equal -1.222222222224
            do_round -1.22222222222235 13 . should_equal -1.2222222222224
            do_round -1.222222222222235 14 . should_equal -1.22222222222224

        Test.specify "Can round correctly near the precision limit, using banker's rounding" <|
            do_round 1.22222222225 10 use_bankers=True . should_equal 1.2222222222
            do_round 1.222222222225 11 use_bankers=True . should_equal 1.22222222222
            do_round 1.2222222222225 12 use_bankers=True . should_equal 1.222222222222
            do_round 1.22222222222225 13 use_bankers=True . should_equal 1.2222222222222
            do_round 1.222222222222225 14 use_bankers=True . should_equal 1.22222222222222

            do_round -1.22222222225 10 use_bankers=True . should_equal -1.2222222222
            do_round -1.222222222225 11 use_bankers=True . should_equal -1.22222222222
            do_round -1.2222222222225 12 use_bankers=True . should_equal -1.222222222222
            do_round -1.22222222222225 13 use_bankers=True . should_equal -1.2222222222222
            do_round -1.222222222222225 14 use_bankers=True . should_equal -1.22222222222222

            do_round 1.22222222235 10 use_bankers=True . should_equal 1.2222222224
            do_round 1.222222222235 11 use_bankers=True . should_equal 1.22222222224
            do_round 1.2222222222235 12 use_bankers=True . should_equal 1.222222222224
            do_round 1.22222222222235 13 use_bankers=True . should_equal 1.2222222222224
            do_round 1.222222222222235 14 use_bankers=True . should_equal 1.22222222222224

            do_round -1.22222222235 10 use_bankers=True . should_equal -1.2222222224
            do_round -1.222222222235 11 use_bankers=True . should_equal -1.22222222224
            do_round -1.2222222222235 12 use_bankers=True . should_equal -1.222222222224
            do_round -1.22222222222235 13 use_bankers=True . should_equal -1.2222222222224
            do_round -1.222222222222235 14 use_bankers=True . should_equal -1.22222222222224

        Test.specify "Decimal places out of range" <|
            do_round 3.1 16 . should_fail_with Illegal_Argument
            do_round 3.1 -16 . should_fail_with Illegal_Argument

        Test.specify "Floating point imperfect representation counter-examples" <|
            do_round 1.225 2 use_bankers=True . should_equal 1.22 # Actual result 1.23
            do_round 37.785 2 . should_equal 37.79

        Test.specify "Can round small integers to a specified number of decimal places correctly (value is unchanged)"
            do_round 0 . should_equal 0
            do_round 3 . should_equal 3
            do_round -3 . should_equal -3
            do_round 3 0 . should_equal 3
            do_round -3 0 . should_equal -3
            do_round 3 1 . should_equal 3
            do_round -3 1 . should_equal -3

        Test.specify "Can round integers to a specified number of negative places correctly"
            do_round 0 -1 . should_equal 0
            do_round 4 -1 . should_equal 0
            do_round 5 -1 . should_equal 10
            do_round 6 -1 . should_equal 10
            do_round 9 -1 . should_equal 10
            do_round 10 -1 . should_equal 10
            do_round 11 -1 . should_equal 10
            do_round 24 -1 . should_equal 20
            do_round 25 -1 . should_equal 30
            do_round 29 -1 . should_equal 30
            do_round 30 -1 . should_equal 30
            do_round 31 -1 . should_equal 30

            do_round 2000 -3 . should_equal 2000
            do_round 2001 -3 . should_equal 2000
            do_round 2412 -3 . should_equal 2000
            do_round 2499 -3 . should_equal 2000
            do_round 2500 -3 . should_equal 3000
            do_round 2501 -3 . should_equal 3000
            do_round 2511 -3 . should_equal 3000
            do_round 2907 -3 . should_equal 3000
            do_round 2999 -3 . should_equal 3000
            do_round 3000 -3 . should_equal 3000
            do_round 3001 -3 . should_equal 3000
            do_round 3098 -3 . should_equal 3000
            do_round 3101 -3 . should_equal 3000

        Test.specify "Can round negative integers to a specified number of negative places correctly"
            do_round -4 -1 . should_equal 0
            do_round -5 -1 . should_equal -10
            do_round -6 -1 . should_equal -10
            do_round -9 -1 . should_equal -10
            do_round -10 -1 . should_equal -10
            do_round -11 -1 . should_equal -10
            do_round -24 -1 . should_equal -20
            do_round -25 -1 . should_equal -30
            do_round -29 -1 . should_equal -30
            do_round -30 -1 . should_equal -30
            do_round -31 -1 . should_equal -30

            do_round -2000 -3 . should_equal -2000
            do_round -2001 -3 . should_equal -2000
            do_round -2412 -3 . should_equal -2000
            do_round -2499 -3 . should_equal -2000
            do_round -2500 -3 . should_equal -3000
            do_round -2501 -3 . should_equal -3000
            do_round -2511 -3 . should_equal -3000
            do_round -2907 -3 . should_equal -3000
            do_round -2999 -3 . should_equal -3000
            do_round -3000 -3 . should_equal -3000
            do_round -3001 -3 . should_equal -3000
            do_round -3098 -3 . should_equal -3000
            do_round -3101 -3 . should_equal -3000

        Test.specify "Can round negative integers to a specified number of negative places with banker's rounding correctly" <|
            do_round 12300 -2 use_bankers=True . should_equal 12300
            do_round 12301 -2 use_bankers=True . should_equal 12300
            do_round 12330 -2 use_bankers=True . should_equal 12300
            do_round 12349 -2 use_bankers=True . should_equal 12300
            do_round 12350 -2 use_bankers=True . should_equal 12400
            do_round 12351 -2 use_bankers=True . should_equal 12400
            do_round 12370 -2 use_bankers=True . should_equal 12400
            do_round 12430 -2 use_bankers=True . should_equal 12400
            do_round 12470 -2 use_bankers=True . should_equal 12500

            do_round 12249 -2 use_bankers=True . should_equal 12200
            do_round 12250 -2 use_bankers=True . should_equal 12200
            do_round 12251 -2 use_bankers=True . should_equal 12300

            do_round -12300 -2 use_bankers=True . should_equal -12300
            do_round -12301 -2 use_bankers=True . should_equal -12300
            do_round -12330 -2 use_bankers=True . should_equal -12300
            do_round -12349 -2 use_bankers=True . should_equal -12300
            do_round -12350 -2 use_bankers=True . should_equal -12400
            do_round -12351 -2 use_bankers=True . should_equal -12400
            do_round -12370 -2 use_bankers=True . should_equal -12400
            do_round -12430 -2 use_bankers=True . should_equal -12400
            do_round -12470 -2 use_bankers=True . should_equal -12500

            do_round -12249 -2 use_bankers=True . should_equal -12200
            do_round -12250 -2 use_bankers=True . should_equal -12200
            do_round -12251 -2 use_bankers=True . should_equal -12300

    Test.group prefix+"Text Column Operations" <|
        t3 = table_builder [["s1", ["foobar", "bar", "baz", "BAB", Nothing]], ["s2", ["foo", "ar", "a", "b", Nothing]]]
        s1 = t3.at "s1"
        s2 = t3.at "s2"
        Test.specify "should handle operations like starts_with, ends_with, contains" <|
            s1.starts_with s2 . to_vector . should_equal [True, False, False, False, Nothing]
            s1.starts_with s2 Case_Sensitivity.Insensitive . to_vector . should_equal [True, False, False, True, Nothing]
            s1.starts_with "foo" . to_vector . should_equal [True, False, False, False, Nothing]
            s1.starts_with "ba" . to_vector . should_equal [False, True, True, False, Nothing]
            s1.starts_with "ba" Case_Sensitivity.Insensitive . to_vector . should_equal [False, True, True, True, Nothing]

            s1.contains s2 . to_vector . should_equal [True, True, True, False, Nothing]
            s1.contains s2 Case_Sensitivity.Insensitive . to_vector . should_equal [True, True, True, True, Nothing]
            s1.contains "a" . to_vector . should_equal [True, True, True, False, Nothing]
            s1.contains "oo" . to_vector . should_equal [True, False, False, False, Nothing]
            s1.contains "a" Case_Sensitivity.Insensitive . to_vector . should_equal [True, True, True, True, Nothing]

            s1.ends_with s2 . to_vector . should_equal [False, True, False, False, Nothing]
            s1.ends_with s2 Case_Sensitivity.Insensitive . to_vector . should_equal [False, True, False, True, Nothing]
            s1.ends_with "ar" . to_vector . should_equal [True, True, False, False, Nothing]
            s1.ends_with "a" . to_vector . should_equal [False, False, False, False, Nothing]
            s1.ends_with "b" Case_Sensitivity.Insensitive . to_vector . should_equal [False, False, False, True, Nothing]

            s1.like s2 . to_vector . should_equal [False, False, False, False, Nothing]
            s1.like (s2+"%r") . to_vector . should_equal [True, False, False, False, Nothing]
            s1.like "%r%" . to_vector . should_equal [True, True, False, False, Nothing]

        Test.specify "should handle operations like is_empty, is_blank, fill_empty" <|
            t = table_builder [["s", ["", " ", "  ", Nothing, "foo"]], ["letters", ["a", "b", "c", "d", "e"]]]
            s = t.at "s"
            s.is_empty . to_vector . should_equal [True, False, False, True, False]
            s.is_blank . to_vector . should_equal [True, False, False, True, False]
            s.fill_empty "<>" . to_vector . should_equal ["<>", " ", "  ", "<>", "foo"]
            s.fill_empty (t.at "letters") . to_vector . should_equal ["a", " ", "  ", "d", "foo"]

        Test.specify "should check types" <|
            t4 = table_builder [["str", ['a', 'b']], ["int", [1, 2]]]
            str = t4.at "str"
            int = t4.at "int"
            str.starts_with int . should_fail_with Invalid_Value_Type
            str.ends_with int . should_fail_with Invalid_Value_Type
            str.contains int . should_fail_with Invalid_Value_Type
            str.like int . should_fail_with Invalid_Value_Type
            int.starts_with str . should_fail_with Invalid_Value_Type
            int.ends_with str . should_fail_with Invalid_Value_Type
            int.contains str . should_fail_with Invalid_Value_Type
            int.like str . should_fail_with Invalid_Value_Type
            str.starts_with 42 . should_fail_with Invalid_Value_Type
            str.ends_with 42 . should_fail_with Invalid_Value_Type
            str.contains 42 . should_fail_with Invalid_Value_Type
            str.like 42 . should_fail_with Invalid_Value_Type

            # Mixing text and integers should not be allowed
            (str + int) . should_fail_with Illegal_Argument

            int.fill_empty "<>" . should_fail_with Invalid_Value_Type
            str.fill_empty int . should_fail_with Invalid_Value_Type
            str.fill_empty 42 . should_fail_with Invalid_Value_Type

            int.is_empty . should_fail_with Invalid_Value_Type

        Test.specify "should return right types" <|
            [Case_Sensitivity.Default, Case_Sensitivity.Sensitive, Case_Sensitivity.Insensitive].each cs->
                s1.starts_with s2 case_sensitivity=cs . value_type . should_equal Value_Type.Boolean
                s1.ends_with s2 case_sensitivity=cs . value_type . should_equal Value_Type.Boolean
                s1.contains s2 case_sensitivity=cs . value_type . should_equal Value_Type.Boolean

                s1.starts_with "A" case_sensitivity=cs . value_type . should_equal Value_Type.Boolean
                s1.ends_with "A" case_sensitivity=cs . value_type . should_equal Value_Type.Boolean
                s1.contains "A" case_sensitivity=cs . value_type . should_equal Value_Type.Boolean

            s1.like s2 . value_type . should_equal Value_Type.Boolean
            s1.like "%r%" . value_type . should_equal Value_Type.Boolean

            s1.is_empty . value_type . should_equal Value_Type.Boolean
            s1.is_blank . value_type . should_equal Value_Type.Boolean
            s1.fill_empty "<>" . value_type . is_text . should_be_true
            s1.fill_empty s2 . value_type . is_text . should_be_true

        Test.specify "should support text concatenation with the + operator" <|
            c1 = s1 + s2
            c1.to_vector . should_equal ["foobarfoo", "barar", "baza", "BABb", Nothing]
            c1.value_type.is_text . should_be_true

            c2 = s1 + "_SUF"
            c2.to_vector . should_equal ["foobar_SUF", "bar_SUF", "baz_SUF", "BAB_SUF", Nothing]
            c2.value_type.is_text . should_be_true

            c3 = s1 + Nothing
            c3.to_vector . should_equal [Nothing, Nothing, Nothing, Nothing, Nothing]
            c3.value_type.is_text . should_be_true

    Test.group prefix+"Min/Max Operations" <|
        t = table_builder [["a", [1, 2, 3]], ["b", [4.5, 5.5, 6.5]], ["c", ['a', 'b', 'c']], ["d", [True, False, True]]]
        a = t.at "a"
        b = t.at "b"
        c = t.at "c"
        Test.specify "should allow one or more args and return the correct type" <|
            c1 = a.min 2
            c1.to_vector . should_equal [1, 2, 2]
            c1.value_type.is_integer . should_be_true

            c2 = a.max 2
            c2.to_vector . should_equal [2, 2, 3]
            c2.value_type.is_integer . should_be_true

            c3 = a.min [2.5, 2]
            c3.to_vector . should_equal [1, 2, 2]
            Test.with_clue "c3.value_type="+c3.value_type.to_display_text <|
                c3.value_type.is_floating_point . should_be_true

            c4 = a.max [2.5, 2]
            c4.to_vector . should_equal [2.5, 2.5, 3]
            c4.value_type.is_floating_point . should_be_true

            c5 = a.min b
            c5.to_vector . should_equal [1, 2, 3]
            Test.with_clue "c5.value_type="+c5.value_type.to_display_text+": " <|
                c5.value_type.is_floating_point . should_be_true

            c6 = a.max b
            c6.to_vector . should_equal [4.5, 5.5, 6.5]
            c6.value_type.is_floating_point . should_be_true

            c7 = a.min [a, b, 1]
            c7.to_vector . should_equal [1, 1, 1]
            c7.value_type.is_floating_point . should_be_true

            c8 = a.max [a, b, 1]
            c8.to_vector . should_equal [4.5, 5.5, 6.5]
            c8.value_type.is_floating_point . should_be_true

            c9 = (t.at "d").min False
            c9.to_vector . should_equal [False, False, False]
            c9.value_type.is_boolean . should_be_true

            c10 = (t.at "d").max False
            c10.to_vector . should_equal [True, False, True]
            c10.value_type.is_boolean . should_be_true

        Test.specify "should check types" <|
            [(.min), (.max)].each op->
                op a c . should_fail_with Invalid_Value_Type
                op a [1, 2, c] . should_fail_with Invalid_Value_Type
                op a [1, Nothing, c, Nothing] . should_fail_with Invalid_Value_Type
                op c 1 . should_fail_with Invalid_Value_Type
                op a True . should_fail_with Invalid_Value_Type

    Test.group prefix+"Column Operations - Text Replace" <|
        do_replace column term new_text case_sensitivity=Case_Sensitivity.Default only_first=False expected =
            case setup.is_database of
                True ->
                    input_type = Meta.type_of term
                    params = Replace_Params.Value input_type case_sensitivity only_first
                    supported_replace_params = setup.test_selection.supported_replace_params
                    supported_replace_params . should_be_a Set
                    are_params_supported = supported_replace_params.contains params
                    case are_params_supported of
                        True -> column.replace term new_text case_sensitivity only_first . to_vector . should_equal expected
                        False -> column.replace term new_text case_sensitivity only_first . should_fail_with Unsupported_Database_Operation
                False ->
                    column.replace term new_text case_sensitivity only_first . to_vector . should_equal expected

        Test.group prefix+"replace: literal text pattern and replacement" <|
            col0 = table_builder [["x", ['hello Hello', 'hello hello', 'HELLO HELLO']]] . at "x"
            col1 = table_builder [["x", ['a[bcd] A[bCd] a[bcd]', 'abac ad Ab aCAd']]] . at "x"

            Test.specify "case_sensitivity=sensitive/default use_regex=false only_first=false"
                do_replace col0 'hello' 'bye' expected=['bye Hello', 'bye bye', 'HELLO HELLO']
                do_replace col0 'hello' 'bye' case_sensitivity=Case_Sensitivity.Default expected=['bye Hello', 'bye bye', 'HELLO HELLO']
                do_replace col0 'hello' 'bye' case_sensitivity=Case_Sensitivity.Sensitive expected=['bye Hello', 'bye bye', 'HELLO HELLO']
                do_replace col1 'a[bcd]' 'hey' expected=['hey A[bCd] hey', 'abac ad Ab aCAd']

            Test.specify "case_sensitivity=sensitive/default use_regex=false only_first=true"
                do_replace col0 'hello' 'bye' only_first=True expected=['bye Hello', 'bye hello', 'HELLO HELLO']
                do_replace col1 'a[bcd]' 'hey' only_first=True expected=['hey A[bCd] a[bcd]', 'abac ad Ab aCAd']

            Test.specify "case_sensitivity=insensitive use_regex=false only_first=false"
                do_replace col0 'hello' 'bye' case_sensitivity=Case_Sensitivity.Insensitive expected=['bye bye', 'bye bye', 'bye bye']
                do_replace col1 'a[bcd]' 'hey' case_sensitivity=Case_Sensitivity.Insensitive expected=['hey hey hey', 'abac ad Ab aCAd']

            Test.specify "case_sensitivity=insensitive use_regex=false only_first=true"
                do_replace col0 'hello' 'bye' case_sensitivity=Case_Sensitivity.Insensitive only_first=True expected=['bye Hello', 'bye hello', 'bye HELLO']
                do_replace col1 'a[bcd]' 'hey' case_sensitivity=Case_Sensitivity.Insensitive only_first=True expected=['hey A[bCd] a[bcd]', 'abac ad Ab aCAd']

        Test.group prefix+"replace: literal regex pattern and replacement" <|
            col1 = table_builder [["x", ['a[bcd] A[bCd] a[bcd]', 'abac ad Ab aCAd']]] . at "x"

            Test.specify "case_sensitivity=sensitive/default use_regex=True only_first=false"
                do_replace col1 'a[bcd]'.to_regex 'hey' expected=['a[bcd] A[bCd] a[bcd]', 'heyhey hey Ab aCAd']

            Test.specify "case_sensitivity=sensitive/default use_regex=True only_first=true"
                do_replace col1 'a[bcd]'.to_regex 'hey' only_first=True expected=['a[bcd] A[bCd] a[bcd]', 'heyac ad Ab aCAd']

            Test.specify "case_sensitivity=insensitive use_regex=True only_first=false"
                do_replace col1 'a[bcd]'.to_regex 'hey' case_sensitivity=Case_Sensitivity.Insensitive expected=['a[bcd] A[bCd] a[bcd]', 'heyhey hey hey heyhey']

            Test.specify "case_sensitivity=insensitive use_regex=True only_first=true"
                do_replace col1 'a[bcd]'.to_regex 'hey' case_sensitivity=Case_Sensitivity.Insensitive only_first=True expected=['a[bcd] A[bCd] a[bcd]', 'heyac ad Ab aCAd']

            Test.specify "can properly escape complex regexes" <|
                regex = "^([^\(]+)|(?<foo>\w\d[a-z])+$"
                col = table_builder [["x", [regex]]] . at "x"
                do_replace col regex "asdf" ["asdf"]

        Test.group prefix+"replace: pattern and replacement columns" <|
            table = table_builder [["x", ['hello Hello', 'hello hello', 'HELLO HELLO', 'a[bcd] A[bCd] a[bcd]', 'abac ad Ab aCAd']], ["patterns", ['hello', 'hello', 'hello', 'a[bcd]', 'a[bcd]']], ["replacements", ['bye', 'bye', 'bye', 'hey', 'hey']]]
            col = table.at "x"
            patterns = table.at "patterns"
            replacements = table.at "replacements"

            Test.specify "case_sensitivity=sensitive/default use_regex=false only_first=false"
                do_replace col patterns replacements expected=['bye Hello', 'bye bye', 'HELLO HELLO', 'hey A[bCd] hey', 'abac ad Ab aCAd']
                do_replace col patterns replacements case_sensitivity=Case_Sensitivity.Default expected=['bye Hello', 'bye bye', 'HELLO HELLO', 'hey A[bCd] hey', 'abac ad Ab aCAd']
                do_replace col patterns replacements case_sensitivity=Case_Sensitivity.Sensitive expected=['bye Hello', 'bye bye', 'HELLO HELLO', 'hey A[bCd] hey', 'abac ad Ab aCAd']

            Test.specify "case_sensitivity=sensitive/default use_regex=false only_first=true"
                do_replace col patterns replacements only_first=True expected=['bye Hello', 'bye hello', 'HELLO HELLO', 'hey A[bCd] a[bcd]', 'abac ad Ab aCAd']

            Test.specify "case_sensitivity=insensitive use_regex=false only_first=false"
                do_replace col patterns replacements case_sensitivity=Case_Sensitivity.Insensitive expected=['bye bye', 'bye bye', 'bye bye', 'hey hey hey', 'abac ad Ab aCAd']

            Test.specify "case_sensitivity=insensitive use_regex=false only_first=true"
                do_replace col patterns replacements case_sensitivity=Case_Sensitivity.Insensitive only_first=True expected=['bye Hello', 'bye hello', 'bye HELLO', 'hey A[bCd] a[bcd]', 'abac ad Ab aCAd']

        if setup.is_database then
            col = table_builder [["A", ["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot"]]] . at 'A'
            Test.specify "should not allow Case_Sensitivity.Insensitive with a non-default locale" <|
                locale = Locale.new "en" "GB" "UTF-8"
                col.replace 'asdf' 'zxcv' case_sensitivity=(Case_Sensitivity.Insensitive locale) . should_fail_with Illegal_Argument

            Test.specify "column name" <|
                table = table_builder [["x", ['hello Hello', 'hello hello', 'HELLO HELLO', 'a[bcd] A[bCd] a[bcd]', 'abac ad Ab aCAd']], ["patterns", ['hello', 'hello', 'hello', 'a[bcd]', 'a[bcd]']], ["replacements", ['bye', 'bye', 'bye', 'hey', 'hey']]]
                col = table.at "x"
                patterns = table.at "patterns"
                replacements = table.at "replacements"

                supported_replace_params = setup.test_selection.supported_replace_params
                if supported_replace_params.contains (Replace_Params.Value Text Case_Sensitivity.Default False) then
                    col.replace 'hello' 'bye' . name . should_equal 'replace([x], \'hello\', \'bye\')'
                if supported_replace_params.contains (Replace_Params.Value Regex Case_Sensitivity.Default False) then
                    col.replace 'a[bcd]'.to_regex 'hey' . name . should_equal 'replace([x], \'a[bcd]\', \'hey\')'
                if supported_replace_params.contains (Replace_Params.Value Column Case_Sensitivity.Default False) then
                    col.replace patterns replacements . name . should_equal 'replace([x], [patterns], [replacements])'

    Test.group prefix+"Column Operations - Text Replace (in-memory only)" <|
        if setup.is_database.not then
            t4 = table_builder [["A", ["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot"]], ["B", ["A","O","a","E","o","O"]], ["C", [1,2,3,4,5,6]], ["D", ['',Nothing,'',Nothing,'','']]]
            a = t4.at "A"
            b = t4.at "B"
            c = t4.at "C"
            d = t4.at "D"

            Test.specify "should allow simple replacing" <|
                a.replace "a" "#" . to_vector . should_equal ["Alph#", "Br#vo", "Ch#rlie", "Delt#", "Echo", "Foxtrot"]
                a.replace "o" "#" . to_vector . should_equal ["Alpha", "Brav#", "Charlie", "Delta", "Ech#", "F#xtr#t"]
                a.replace b "#" . to_vector . should_equal ["#lpha", "Bravo", "Ch#rlie", "Delta", "Ech#", "Foxtrot"]
                a.replace "o" "#" only_first=True . to_vector . should_equal ["Alpha", "Brav#", "Charlie", "Delta", "Ech#", "F#xtrot"]
                a.replace "a" "#" Case_Sensitivity.Insensitive . to_vector . should_equal ["#lph#", "Br#vo", "Ch#rlie", "Delt#", "Echo", "Foxtrot"]
                a.replace b "#" Case_Sensitivity.Insensitive . to_vector . should_equal ["#lph#", "Brav#", "Ch#rlie", "D#lta", "Ech#", "F#xtr#t"]
                a.replace b "#" Case_Sensitivity.Insensitive only_first=True . to_vector . should_equal ["#lpha", "Brav#", "Ch#rlie", "D#lta", "Ech#", "F#xtrot"]

            Test.specify "should allow regex based replacing" <|
                a.replace "[aeiou]".to_regex "#" . to_vector . should_equal ["Alph#", "Br#v#", "Ch#rl##", "D#lt#", "Ech#", "F#xtr#t"]
                a.replace "[aeiou]".to_regex "#" . to_vector . should_equal ["Alph#", "Br#v#", "Ch#rl##", "D#lt#", "Ech#", "F#xtr#t"]
                a.replace "([aeiou])(.*?)[aeiou]".to_regex "$1$2$1" . to_vector . should_equal ["Alpha", "Brava", "Charlae", "Delte", "Echo", "Foxtrot"]

            Test.specify "should handle unicode" <|
                table = table_builder [["x", ["śćxx", "ąąasdfąą", "aﬃb"]], ["patterns", ["ć", "ąą", "ﬃ"]], ["replacements", ["abc", "def", "ghi"]]]
                col = table.at "x"
                patterns = table.at "patterns"
                replacements = table.at "replacements"

                col.replace patterns replacements . to_vector . should_equal ["śabcxx", "defasdfdef", "aghib"]

            Test.specify "should take pattern and replacement string columns" <|
                t = table_builder [["x", ["hello", "what", "yes"]], ["patterns", ["ell", "wh", "es"]], ["replacements", ["xyz", "qwer", "asdf"]]]
                col = t.at "x"
                patterns = t.at "patterns"
                replacements = t.at "replacements"

                col.replace patterns replacements . to_vector . should_equal ["hxyzo", "qwerat", "yasdf"]

            Test.specify "should only allow replace on Text columns" <|
                c.replace "a" "#" . should_fail_with Invalid_Value_Type
                a.replace 1 "#" . should_fail_with Invalid_Value_Type
                a.replace c "#" . should_fail_with Invalid_Value_Type
                a.replace "a" 1 . should_fail_with Invalid_Value_Type
                a.replace "a" c . should_fail_with Invalid_Value_Type

            Test.specify "should not replace if Empty term" <|
                a.replace '' "#" . to_vector . should_equal ["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot"]
                a.replace d "#" . to_vector . should_equal ["Alpha", "Bravo", "Charlie", "Delta", "Echo", "Foxtrot"]

            Test.specify "should infer correct return type" <|
                c = table_builder [["texts", ["foo", "bar"]]] . at "texts"

                c1 = c.replace "a" "---"
                c1.to_vector . should_equal ["foo", "b---r"]
                vt1 = c1.value_type
                Test.with_clue "c1.value_type="+vt1.to_display_text+": " <|
                    vt1.should_be_a (Value_Type.Char ...)
                    vt1.variable_length.should_be_true

            Test.specify "should infer correct return type (2)" pending=(if setup.test_selection.fixed_length_text_columns.not then "Fixed-length Char columns are not supported by this backend.") <|
                c = table_builder [["texts", ["foo", "bar"]]] . at "texts"
                c2 = c.cast (Value_Type.Char size=2 variable_length=False)
                c3 = c2.replace "a" "---"

                c3.to_vector . should_equal ["fo", "b---"]
                vt3 = c3.value_type
                Test.with_clue "c3.value_type="+vt3.to_display_text+": " <|
                    vt3.should_be_a (Value_Type.Char ...)
                    vt3.variable_length.should_be_true

    Test.group prefix+"Column Operations - Text Trim" <|
        t5 = table_builder [["A", [" A ", ' \t\n\rA\r\n\t ', "xxxAxx"]], ["B", [" ",' \t',"x"]], ["C", [1,2,3]]]
        a = t5.at "A"
        b = t5.at "B"
        c = t5.at "C"

        Test.specify "should trim whitespace by default" <|
            a.trim . to_vector . should_equal ["A", "A", "xxxAxx"]
            a.trim Location.Start . to_vector . should_equal ["A ", 'A\r\n\t ', "xxxAxx"]
            a.trim Location.End . to_vector . should_equal [" A", ' \t\n\rA', "xxxAxx"]

       Test.specify "should trim custom characters" <|
            a.trim what='x' . to_vector . should_equal [" A ", ' \t\n\rA\r\n\t ', "A"]
            a.trim what='x' Location.Start . to_vector . should_equal [" A ", ' \t\n\rA\r\n\t ', "Axx"]
            a.trim what='x' Location.End . to_vector . should_equal [" A ", ' \t\n\rA\r\n\t ', "xxxA"]
            a.trim what=' ' . to_vector . should_equal ["A", '\t\n\rA\r\n\t', "xxxAxx"]
            a.trim what=' \t' . to_vector . should_equal ["A", '\n\rA\r\n', "xxxAxx"]
            a.trim what=' \r' . to_vector . should_equal ["A", '\t\n\rA\r\n\t', "xxxAxx"]
            a.trim what=b . to_vector . should_equal ["A", '\n\rA\r\n', "A"]

        Test.specify "should only allow trim on Text columns" <|
            c.trim what="a" . should_fail_with Invalid_Value_Type
            a.trim what=1 . should_fail_with Invalid_Value_Type
            a.trim what=c . should_fail_with Invalid_Value_Type

    Test.group prefix+"Other Column Operations" <|
        Test.specify "is_in" <|
            t = table_builder [["X", [1, 2, 3, 4]], ["Y", [4, 3, 100, 200]]]
            x = t.at "X"
            y = t.at "Y"

            c1 = x.is_in  [2, 100, 5]
            c1.to_vector . should_equal [False, True, False, False]
            c1.value_type.should_equal Value_Type.Boolean

            c2 = x.is_in y
            c2.to_vector . should_equal [False, False, True, True]
            c2.value_type.should_equal Value_Type.Boolean

    Test.group prefix+"Colum Operations - Names" <|
        t = table_builder [["a", [1, 2, 3]], ["b", ['x', 'y', 'z']], ["c", [1.0, 2.0, 3.0]], ["d", [True, False, True]]]
        Test.specify "arithmetic" <|
            ((t.at "a") + 42) . name . should_equal "[a] + 42"
            ((t.at "a") - (t.at "c")) . name . should_equal "[a] - [c]"
            ((t.at "a") * (t.at "c")) . name . should_equal "[a] * [c]"
            ((t.at "a") / (t.at "c")) . name . should_equal "[a] / [c]"
            ((t.at "a") % (t.at "c")) . name . should_equal "[a] % [c]"
            ((t.at "a") ^ (t.at "c")) . name . should_equal "[a] ^ [c]"
            ((t.at "b") + 'xyz') . name . should_equal "[b] + 'xyz'"
            ((t.at "b") + '\0') . name . should_equal "[b] + '\0'"

        Test.specify "comparison" <|
            ((t.at "b") == '\0\0') . name . should_equal "[b] == '\0\0'"
            ((t.at "b") != '\0\0') . name . should_equal "[b] != '\0\0'"
            ((t.at "a") < 0) . name . should_equal "[a] < 0"
            ((t.at "a") <= 0) . name . should_equal "[a] <= 0"
            ((t.at "a") > 0) . name . should_equal "[a] > 0"
            ((t.at "b") >= 'X') . name . should_equal "[b] >= 'X'"
            ((t.at "a").between (t.at "c") 42) . name . should_equal "[a] between [c] and 42"

        Test.specify "logical" <|
            ((t.at "d") || False) . name . should_equal "[d] || False"
            ((t.at "d") && True) . name . should_equal "[d] && True"
            ((t.at "d").not) . name . should_equal "not [d]"
            ((t.at "d").iif 10 20) . name . should_equal "if [d] then 10 else 20"

        Test.specify "text" <|
            t.at "b" . equals_ignore_case "abc" . name . should_equal "equals_ignore_case([b], 'abc')"
            t.at "b" . starts_with "abc" . name . should_equal "starts_with([b], 'abc')"
            t.at "b" . contains "abc" . name . should_equal "contains([b], 'abc')"
            t.at "b" . like "%abc%" . name . should_equal "[b] like '%abc%'"
            t.at "b" . ends_with "abc" . name . should_equal "ends_with([b], 'abc')"
            t.at "b" . is_empty . name . should_equal "[b] is empty"
            t.at "b" . fill_empty "<empty>" . name . should_equal "b"

        Test.specify "nulls" <|
            t.at "a" . coalesce [Nothing, 42] . name . should_equal "coalesce([a], Nothing, 42)"
            t.at "a" . is_nothing . name . should_equal "[a] is null"
            t.at "a" . is_present . name . should_equal "is_present([a])"
            t.at "a" . is_blank . name . should_equal "is_blank([a])"
            t.at "a" . fill_nothing 100 . name . should_equal "a"

        Test.specify "misc"
            t.at "a" . min [1, 2] . name . should_equal "min([a], 1, 2)"
            t.at "a" . max 33 . name . should_equal "max([a], 33)"
            t.at "a" . is_in [1, 2, 3] . name . should_equal "[a] in [1, 2, 3]"

        Test.specify "composed operations" <|
            # These look a bit weird, but they are consistent with the column name escaping scheme.
            ((t.at "a" + 42) * (t.at "c")) . name . should_equal "[[a]] + 42] * [c]"
            ((t.at "a" + 42) * (t.at "c") - 33) . name . should_equal "[[[a]]]] + 42]] * [c]]] - 33"

        Test.specify "sort" <|
            t.at "a" . sort . name . should_equal "a"

        if setup.is_database.not then
            Test.specify "parse" <|
                t2 = table_builder [["X", ["1", "2", "3"]]]
                t2.at "X" . parse . name . should_equal "X"

            Test.specify "map and zip" <|
                t.at "a" . map (x -> x + 1) . name . should_equal "a"
                t.at "a" . zip (t.at "b") [_, _] . name . should_equal "[a] x [b]"

    Test.group prefix+"Column.rename" <|
        Test.specify "should not allow illegal names" <|
            t = table_builder [["a", [1, 2, 3]]]
            c = t.at "a"

            c.rename Nothing . should_fail_with Illegal_Argument
            c.rename '' . should_fail_with Illegal_Argument
            c.rename 'a\0b' . should_fail_with Illegal_Argument
            c.rename '\0' . should_fail_with Illegal_Argument

    Test.group prefix+"Column.const" <|
        Test.specify "Should allow the creation of constant columns" <|
            t = table_builder [["x", ["1", "2", "3"]]]
            t.at "x" . const True . to_vector . should_equal [True, True, True]
            t.at "x" . const 12 . to_vector . should_equal [12, 12, 12]
            t.at "x" . const 12.3 . to_vector . should_equal [12.3, 12.3, 12.3]
            t.at "x" . const "asdf" . to_vector . should_equal ["asdf", "asdf", "asdf"]

        Test.specify "Should create the correct column name" <|
            t = table_builder [["x", ["1", "2", "3"]]]
            t.at "x" . const 12 . name . take 9 . should_equal "Constant_"

        Test.specify "Should not allow the creation of a constant column of columns" <|
            t = table_builder [["x", ["1", "2", "3"]]]
            t.at "x" . const (t.at "x") . should_fail_with Illegal_Argument
