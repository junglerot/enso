from Standard.Base import all
import Standard.Base.Errors.Common.Incomparable_Values
import Standard.Base.Errors.Common.Index_Out_Of_Bounds
import Standard.Base.Errors.Common.Type_Error
import Standard.Base.Errors.Illegal_Argument.Illegal_Argument

from Standard.Table import Table, Column, Sort_Column, Aggregate_Column, Blank_Selector
from Standard.Table.Data.Aggregate_Column.Aggregate_Column import all hiding First, Last
import Standard.Table.Data.Type.Value_Type.Value_Type
from Standard.Table.Errors import Invalid_Column_Names, Duplicate_Output_Column_Names, No_Input_Columns_Selected, Missing_Input_Columns, No_Such_Column, Floating_Point_Equality, Invalid_Value_Type, Row_Count_Mismatch

import Standard.Visualization

import Standard.Database.Extensions.Upload_Database_Table
import Standard.Database.Extensions.Upload_In_Memory_Table
from Standard.Database import Database, SQLite, In_Memory

from Standard.Test import Test, Test_Suite, Problems
import Standard.Test.Extensions

from project.Util import all

polyglot java import java.lang.IllegalArgumentException
polyglot java import org.enso.table.data.table.Table as Java_Table

type My
    Data x y

    frobnicate self = case self of
        My.Data x1 y1 -> My.Data y1 x1

type My_Comparator
    compare left right =
        left_sum = left.x + left.y
        right_sum = right.x + right.y
        (Comparable.from left_sum) . compare left_sum right_sum

    hash my =
        sum = my.x + my.y
        Comparable.from sum . hash sum

Comparable.from (_:My) = My_Comparator

spec =
    make_varied_type_table =
        strs = ["strs", ["a", "b", "c", Nothing]]
        ints = ["ints", [Nothing, 1, 2, 4]]
        doubles = ["doubles", [0.0, 1.5, Nothing, 2.0]]
        doubles_and_ints = ["doubles_and_ints", [0, 1.5, Nothing, 2]]
        custom_objects = ["custom_objects", [My.Data 1 2, My.Data 3 4, Nothing, Nothing]]
        dates = ["dates", [Nothing, Date.new 2000, Date.new 2022 8 20, Date.new 1999 1 1]]
        times = ["times", [Time_Of_Day.new 18 00, Time_Of_Day.new 1 2 34, Nothing, Time_Of_Day.new]]
        datetimes = ["datetimes", [Date_Time.new 2000, Date_Time.new 1999 1 2 3 4 5, Nothing, Date_Time.new 2022 8 27 11 22 25]]
        mixed = ["mixed", [1, "a", Nothing, Date.new 2022 8 27]]
        mixed_dates = ["mixed_dates", [Date.new 1999 1 2, Date_Time.new 1999 1 2 3 40, Date.new 1999 1 2, Date_Time.new 1999 1 2 3 40]]
        just_nulls = ["just_nulls", [Nothing, Nothing, Nothing, Nothing]]

        Table.new [strs, ints, doubles, doubles_and_ints, custom_objects, dates, times, datetimes, mixed, mixed_dates, just_nulls]
    varied_type_table = make_varied_type_table

    Test.group "Construction" <|
        Test.specify "should allow creating a table from rows" <|
            header = ['foo', 'bar']
            rows = [[1, False], [2, True], [3, False]]
            r = Table.from_rows header rows
            r.row_count.should_equal 3
            r.at "foo" . to_vector . should_equal [1, 2, 3]
            r.at "bar" . to_vector . should_equal [False, True, False]

            r2 = Table.from_rows header []
            r2.row_count . should_equal 0
            r2.at "foo" . to_vector . should_equal []
            r2.at "bar" . to_vector . should_equal []

        Test.specify "should allow creating a table from columns" <|
            r = Table.new [["foo", [1, 2, 3]], ["bar", [False, True, False]]]
            r.row_count.should_equal 3
            r.at "foo" . to_vector . should_equal [1, 2, 3]
            r.at "bar" . to_vector . should_equal [False, True, False]

            r2 = Table.new [["foo", []], ["bar", []]]
            r2.row_count . should_equal 0
            r2.at "foo" . to_vector . should_equal []
            r2.at "bar" . to_vector . should_equal []

        Test.specify "should handle error scenarios gracefully" <|
            Table.new [["X", [1,2,3]], ["Y", [4]]] . should_fail_with Illegal_Argument
            Table.new [["X", [1]], ["X", [2]]] . should_fail_with Illegal_Argument
            Table.new [["X", [1]], ["Y", [2], "Z"]] . should_fail_with Illegal_Argument
            Table.new [["X"]] . should_fail_with Illegal_Argument
            Table.new ["X", "Y", "Z"] . should_fail_with Illegal_Argument
            Table.new [] . should_fail_with Illegal_Argument

            Table.from_rows ["X", "X"] [] . should_fail_with Illegal_Argument
            Table.from_rows ["X", "Y"] [[1,2], [1]] . should_fail_with (Map_Error.Error 1 (Index_Out_Of_Bounds.Error 1 1))
            Table.from_rows [] [] . should_fail_with Illegal_Argument
            Table.from_rows [] [[]] . should_fail_with Illegal_Argument

            Table.new [["X", [1,2,3]], ["", [4,5,6]]] . should_fail_with Invalid_Column_Names

        Test.specify "should be internally guarded against creating a table without columns" <|
            Test.expect_panic_with (Java_Table.new []) IllegalArgumentException

        Test.specify "should correctly infer storage types" <|
            varied_type_table.at "strs" . value_type . should_equal Value_Type.Char
            varied_type_table.at "ints" . value_type . should_equal Value_Type.Integer
            varied_type_table.at "doubles" . value_type . should_equal Value_Type.Float
            varied_type_table.at "doubles_and_ints" . value_type . should_equal Value_Type.Float
            varied_type_table.at "custom_objects" . value_type . should_equal Value_Type.Mixed
            varied_type_table.at "dates" . value_type . should_equal Value_Type.Date
            varied_type_table.at "times" . value_type . should_equal Value_Type.Time
            varied_type_table.at "datetimes" . value_type . should_equal Value_Type.Date_Time
            varied_type_table.at "mixed" . value_type . should_equal Value_Type.Mixed
            varied_type_table.at "mixed_dates" . value_type . should_equal Value_Type.Mixed
            varied_type_table.at "just_nulls" . value_type . should_equal Value_Type.Mixed

        pending_python_missing = if Polyglot.is_language_installed "python" . not then
            "Can't run Python tests, Python is not installed."
        Test.specify "should work with polyglot values coming from Python" pending=pending_python_missing <|
            enso_dates = ["enso_dates", [Date.new 2022 8 27, Date.new 1999 1 1]]
            py_dates = ["py_dates", [py_make_date 2022 8 27, py_make_date 1999 1 1]]
            py_objects = ["py_objects", [py_make_object "a" "b", py_make_object "foo" "bar"]]
            table = Table.new [enso_dates, py_dates, py_objects]
            table.info.at "Column" . to_vector . should_equal ["enso_dates", "py_dates", "py_objects"]
            table.info.at "Value Type" . to_vector . should_equal [Value_Type.Date, Value_Type.Date, Value_Type.Mixed]

            (table.at "enso_dates" == table.at "py_dates").to_vector . should_equal [True, True]

        Test.specify "should work with polyglot values coming from JS" <|
            enso_dates = ["enso_dates", [Date.new 2022 8 27, Date.new 1999 1 1]]
            js_dates = ["js_dates", [js_make_date 2022 8 27, js_make_date 1999 1 1]]
            js_objects = ["js_objects", [js_make_object "a" "b", js_make_object "foo" "bar"]]
            table = Table.new [enso_dates, js_dates, js_objects]
            table.info.at "Column" . to_vector . should_equal ["enso_dates", "js_dates", "js_objects"]
            table.info.at "Value Type" . to_vector . should_equal [Value_Type.Date, Value_Type.Date_Time, Value_Type.Mixed]

            enso_date_times = table.at "enso_dates" . map .to_date_time
            enso_date_times.value_type . should_equal Value_Type.Date_Time
            js_converted_dates = table.at "js_dates" . map .date
            js_converted_dates.value_type . should_equal Value_Type.Date
            (js_converted_dates == table.at "enso_dates").to_vector . should_equal [True, True]
            (enso_date_times == table.at "js_dates").to_vector . should_equal [True, True]

        Test.specify "should work with a Text value split into lines" <|
            ## This tests verifies an issue with passing through a `List<String>` to the table.
            words = 'The\nquick\nbrown\nfox\njumps\nover\nthe\nlazy\ndog'.lines
            table = Table.new [["words", words]]
            table.at "words" . value_type . should_equal Value_Type.Char
            table.at "words" . to_vector . should_equal words

        Test.specify "should handle Unicode normalization when accessing table columns" <|
            col1 = ['s\u0301ciana', [1, 2, 3]]
            col2 = ['café', [4, 5, 6]]
            t = Table.new [col1, col2]
            t.at 'ściana' . to_vector . should_equal [1, 2, 3]
            t.at 's\u0301ciana' . to_vector . should_equal [1, 2, 3]
            t.at 'cafe\u0301' . to_vector . should_equal [4, 5, 6]
            t.at 'café' . to_vector . should_equal [4, 5, 6]
            t.at 'sciana' . should_fail_with No_Such_Column

            # Cannot create two columns with the same name modulo normalization.
            r2 = Table.new [['ściana', [1, 2, 3]], ['s\u0301ciana', [4, 5, 6]]]
            r2.should_fail_with Illegal_Argument

    Test.group "Vector conversion" <|
        Test.specify "should allow converting columns to valid vectors" <|
            col_1 = Column.from_vector 'x' [1, 2, 3]
            col_1.to_vector.reduce (+) . should_equal 6

            col_2 = Column.from_vector 'y' [My.Data 1 2, My.Data 2 3]
            col_2.to_vector.map (my -> my.x + my.y) . should_equal [3, 5]

            col_3 = Column.from_vector 'z' [False, True, False]
            col_3.to_vector.map .not . should_equal [True, False, True]

    Test.group "Mapping Operations" <|
        Test.specify "should allow mapping a function over a column" <|
            c_str = Column.from_vector 'x' ['a', 'b', Nothing, 'b']
            c_str.map (+ "x") . to_vector . should_equal ['ax', 'bx', Nothing, 'bx']
            c_int = Column.from_vector 'x' [1, 2, 1, 5, 1]
            c_int.map (+ 1) . to_vector . should_equal [2, 3, 2, 6, 2]
            c_dec = Column.from_vector 'x' [1.9, 2.0, 1.2, 5.6, 1.9]
            c_dec.map (+ 1.5) . to_vector . should_equal [3.4, 3.5, 2.7, 7.1, 3.4]
            c_bool = Column.from_vector 'x' [True, False, Nothing, True, False]
            c_bool.map (_.to_text) . to_vector . should_equal ["True", "False", Nothing, "True", "False"]
            c_any = Column.from_vector 'x' [My.Data 1 6, My.Data 6 3, My.Data 2 5, My.Data 3 4, My.Data 200 300]
            c_any.map (_.frobnicate) . to_vector . should_equal [My.Data 6 1, My.Data 3 6, My.Data 5 2, My.Data 4 3, My.Data 300 200]

        Test.specify "should correctly handle storage of results" <|
            c_int = Column.from_vector 'year' [2022, 2000, 1999]
            r = c_int . map Date_Time.new
            r.to_vector . should_equal [Date_Time.new 2022, Date_Time.new 2000, Date_Time.new 1999]
            r.value_type . should_equal Value_Type.Date_Time

        Test.specify "should allow zipping columns with a custom function" <|
            b = Column.from_vector 'w' [6.3, 3.1, 5.2, 4.6, 8.0]
            a = Column.from_vector 'z' ['foo', 'bar', 'baz', 'spam', 'eggs']
            c = a.zip b x-> y-> x + y.to_text
            c.to_vector.should_equal ['foo6.3', 'bar3.1', 'baz5.2', 'spam4.6', 'eggs8.0']
            c.value_type . should_equal Value_Type.Char

            x = Column.from_vector 'a' [1, Nothing, 2, Nothing]
            y = Column.from_vector 'b' [0, 0, 0, 0]
            r = x.zip y skip_nothing=False x-> y-> if x == 1 then x else y
            r.to_vector.should_equal [1, 0, 0, 0]
            r.value_type . should_equal Value_Type.Integer

            u = Column.from_vector 'u' [12, 13, 0]
            v = Column.from_vector 'v' [0, 30, 45]
            r2 = u.zip v h-> m-> Time_Of_Day.new h m
            r2.to_vector . should_equal [Time_Of_Day.new 12 0, Time_Of_Day.new 13 30, Time_Of_Day.new 0 45]
            r2.value_type . should_equal Value_Type.Time

        Test.specify "should handle vectorized equality and fall back on non-vectorized if needed" <|
            c_str = Column.from_vector 'x' ['a', 'b', Nothing, 'b']
            (c_str == 'b').to_vector.should_equal [False, True, Nothing, True]
            c_int = Column.from_vector 'x' [1, 2, 1, 5, 1]
            (c_int == 1).to_vector.should_equal [True, False, True, False, True]
            c_dec = Column.from_vector 'x' [1.9, 2.0, 1.2, 5.6, 1.9]
            (c_dec == 1.9).to_vector.should_equal [True, False, False, False, True]
            c_bool = Column.from_vector 'x' [True, False, Nothing, True, False]
            (c_bool == False).to_vector.should_equal [False, True, Nothing, False, True]
            c_any = Column.from_vector 'x' [My.Data 1 6, My.Data 6 3, My.Data 2 5, My.Data 3 4, My.Data 200 300]
            (c_any == My.Data 7 0).to_vector.should_equal [True, False, True, True, False]

        Test.specify "should switch between maps and zips based on argument type" <|
            a = Column.from_vector 'x' [0, 1, 7, 3, 6]
            b = Column.from_vector 'w' [6.3, 3.1, 5.2, Nothing, 8]
            (a + 3.2).to_vector.should_equal [3.2, 4.2, 10.2, 6.2, 9.2]
            (a + b).to_vector.should_equal [6.3, 4.1, 12.2, Nothing, 14]
            gt_const = a > 5
            gt_const.to_vector.should_equal [False, False, True, False, True]
            gt_b = a > b
            gt_b.to_vector.should_equal [False, False, True, Nothing, False]
            both = gt_const && gt_b
            both.to_vector.should_equal [False, False, True, Nothing, False]

        Test.specify "should handle Text operations" <|
            a = Column.from_vector 'a' ["abab", "abc", Nothing, "bca", "acca"]
            nils = [Nothing, Nothing, Nothing, Nothing, Nothing]

            a.starts_with "ab" . to_vector . should_equal [True, True, Nothing, False, False]
            b = Column.from_vector 'b' ["ba", "ab", "d", Nothing, "ac"]
            a.starts_with b . to_vector . should_equal [False, True, Nothing, Nothing, True]
            a.starts_with Nothing . to_vector . should_equal nils

            a.ends_with "ca" . to_vector . should_equal [False, False, Nothing, True, True]
            c = Column.from_vector 'c' ["ab", "b", "d", Nothing, "cc"]
            a.ends_with c . to_vector . should_equal [True, False, Nothing, Nothing, False]
            a.ends_with Nothing . to_vector . should_equal nils

            a.contains "c" . to_vector . should_equal [False, True, Nothing, True, True]
            a.contains c . to_vector . should_equal [True, True, Nothing, Nothing, True]
            a.contains Nothing . to_vector . should_equal nils

        Test.specify "should take Unicode normalization into account in Text operations" <|
            x = Column.from_vector 'x' ['s', 'ś', 's\u0301']
            y = Column.from_vector 'y' ['s\u0301', 's\u0301', 'ś']

            x=='s' . to_vector . should_equal [True, False, False]
            x=='ś' . to_vector . should_equal [False, True, True]
            x=='s\u0301' . to_vector . should_equal [False, True, True]
            x=='ą' . to_vector . should_equal [False, False, False]
            x==y . to_vector . should_equal [False, True, True]

            z = Column.from_vector 'z' ['śląsk', 's\u0301ciana', 'sanok', 'rzeczywistość', 'ostros\u0301c\u0301']
            z.starts_with 's' . to_vector . should_equal [False, False, True, False, False]
            z.starts_with 'ś' . to_vector . should_equal [True, True, False, False, False]
            z.starts_with 's\u0301' . to_vector . should_equal [True, True, False, False, False]
            z.starts_with 'ą' . to_vector . should_equal [False, False, False, False, False]
            z.ends_with 'ść' . to_vector . should_equal [False, False, False, True, True]
            z.ends_with 's\u0301c\u0301' . to_vector . should_equal [False, False, False, True, True]
            z.ends_with 'ok' . to_vector . should_equal [False, False, True, False, False]
            z.contains 's' . to_vector . should_equal [True, False, True, True, True]
            z.contains 'ś' . to_vector . should_equal [True, True, False, True, True]
            z.contains 's\u0301' . to_vector . should_equal [True, True, False, True, True]

    Test.group "Masking Tables" <|
        Test.specify "should allow selecting table rows based on a boolean column" <|
            df = (enso_project.data / "simple_empty.csv").read
            r = df.filter (Column.from_vector 'x' [True, False, False, True])
            r.at "a" . to_vector . should_equal ["1", "10"]
            r.at "b" . to_vector . should_equal [2, 11]
            r.at "c" . to_vector . should_equal [Nothing, 12]
        Test.specify "should treat NA values in the mask as false and extend the mask with NAs" <|
            df = (enso_project.data / "simple_empty.csv").read
            r = df.filter (Column.from_vector 'x' [Nothing, True, False])
            r.at "a" . to_vector . should_equal ["4"]
            r.at "b" . to_vector . should_equal [Nothing]
            r.at "c" . to_vector . should_equal [6]
        Test.specify "should work correctly if a mask is bigger than the table itself" <|
            df = (enso_project.data / "simple_empty.csv").read
            r = df.filter (Column.from_vector 'x' [True, False, False, False, True])
            r.at "a" . to_vector . should_equal ["1"]
            r.at "b" . to_vector . should_equal [2]
            r.at "c" . to_vector . should_equal [Nothing]

    Test.group "Counting Values" <|
        Test.specify "should count missing and non-missing values" <|
            col = Column.from_vector 'x' [1, Nothing, 2]
            col.length . should_equal 3
            col.count . should_equal 2
            col.count_nothing . should_equal 1

    Test.group "Dropping Missing Values" <|
        Test.specify "should correctly handle NaNs with mixed type columns" <|
            t = Table.new [["X", [1, 2, 3, 4, 5]], ["Y", ["A", "", Nothing, Number.nan, 0]]]
            t1 = t.filter_blank_rows when=Blank_Selector.Any_Cell treat_nans_as_blank=False
            t1.at "X" . to_vector . should_equal [1, 4, 5]
            # Comparing text value because `Number.nan != Number.nan`.
            t1.at "Y" . to_vector . to_text . should_equal "[A, NaN, 0]"

            c = t.at "Y" . is_blank treat_nans_as_blank=True
            c.to_vector . should_equal [False, True, True, True, False]
            c.value_type . should_equal Value_Type.Boolean

            t2 = t.filter_blank_rows when=Blank_Selector.Any_Cell treat_nans_as_blank=True
            t2.at "X" . to_vector . should_equal [1, 5]
            t2.at "Y" . to_vector . should_equal ['A', 0]

            t3 = Table.new [["X", [1, 2, 3]], ["Y", ["", Nothing, Number.nan]]]
            t4 = t3.remove_blank_columns treat_nans_as_blank=True
            t4.columns . map .name . should_equal ["X"]

    Test.group "Info" <|
        Test.specify "should return Table information" <|
            a = ["strs", ["a", "b", Nothing, "a"]]
            b = ["ints", [1, 2, Nothing, Nothing]]
            c = ["objs", [1, "a", "c", Any]]
            r = Table.new [a, b, c]
            i = r.info
            i.at "Column" . to_vector . should_equal ["strs", "ints", "objs"]
            i.at "Items Count" . to_vector . should_equal [3, 2, 4]
            i.at "Value Type" . to_vector . should_equal [Value_Type.Char, Value_Type.Integer, Value_Type.Mixed]

    Test.group "Sorting Tables" <|
        Test.specify 'should respect defined comparison operations for custom types' <|
            c_1 = ['id', [1, 2, 3, 4, 5, 6]]
            c_2 = ['val', [My.Data 1 2, My.Data 3 4, My.Data 2 1, My.Data 5 2, My.Data 7 0, My.Data 4 -1]]
            df = Table.new [c_1, c_2]
            r = df.order_by (['val'])
            r.at 'id' . to_vector . should_equal [1,3,6,2,4,5]

        Test.specify 'should correctly reorder all kinds of columns and leave the original columns untouched' <|
            ord = [0, 3, 2, 4, 1]
            ints = [1, 2, 3, 4, 5]
            reals = [1.3, 4.6, 3.2, 5.2, 1.6]
            bools = [False, False, True, True, False]
            texts = ["foo", "foo", "bar", "baz", "spam"]
            dates = [Date.new 2020, Date.new 1999, Date.new 2000 10 3, Date.new 1999 12 31, Date.new 2000 2 7]
            times = [Time_Of_Day.new 12, Time_Of_Day.new 1 30 40, Time_Of_Day.new 23 59 59, Time_Of_Day.new 12 30 0, Time_Of_Day.new 10 20 30]
            datetimes = [Date_Time.new 2020 1 1 12, Date_Time.new 1999 1 1 1 30 40, Date_Time.new 2000 10 3 23 59 59, Date_Time.new 1999 12 31 12 30 0, Date_Time.new 2000 10 3 10 20 30]
            objs = [My.Data 100 2, My.Data 2 3, My.Data 6 7, My.Data 8 9, My.Data 10 30]
            mixed_dates = [Date.new 1999 1 2, Date_Time.new 1999 1 2 3 40, Date.new 1999 1 2, Date_Time.new 1999 1 2 3 40, Date.new 2000]

            df = Table.new [['ord', ord], ['ints', ints], ['reals', reals], ['bools', bools], ['texts', texts], ['objs', objs], ['dates', dates], ['times', times], ['datetimes', datetimes], ['mixed_dates', mixed_dates]]
            r = df.order_by (['ord'])

            r.at 'ints' . to_vector . should_equal [1, 5, 3, 2, 4]
            df.at 'ints' . to_vector . should_equal ints

            r.at 'reals' . to_vector . should_equal [1.3, 1.6, 3.2, 4.6, 5.2]
            df.at 'reals' . to_vector . should_equal reals

            r.at 'bools' . to_vector . should_equal [False, False, True, False, True]
            df.at 'bools' . to_vector . should_equal bools

            r.at 'texts' . to_vector . should_equal ['foo', 'spam', 'bar', 'foo', 'baz']
            df.at 'texts' . to_vector . should_equal texts

            r.at 'objs' . to_vector . should_equal [My.Data 100 2, My.Data 10 30, My.Data 6 7, My.Data 2 3, My.Data 8 9]
            df.at 'objs' . to_vector . should_equal objs

            r.at 'dates' . to_vector . should_equal [Date.new 2020, Date.new 2000 2 7, Date.new 2000 10 3, Date.new 1999, Date.new 1999 12 31]
            df.at 'dates' . to_vector . should_equal dates

            r.at 'times' . to_vector . should_equal [Time_Of_Day.new 12, Time_Of_Day.new 10 20 30, Time_Of_Day.new 23 59 59, Time_Of_Day.new 1 30 40, Time_Of_Day.new 12 30 0]
            df.at 'times' . to_vector . should_equal times

            r.at 'datetimes' . to_vector . should_equal [Date_Time.new 2020 1 1 12, Date_Time.new 2000 10 3 10 20 30, Date_Time.new 2000 10 3 23 59 59, Date_Time.new 1999 1 1 1 30 40, Date_Time.new 1999 12 31 12 30 0]
            df.at 'datetimes' . to_vector . should_equal datetimes

            # TODO move this test to Common_Table_Operations once we support dates there
            r2 = df.order_by (['dates'])
            r2.at 'dates' . to_vector . should_equal [Date.new 1999, Date.new 1999 12 31, Date.new 2000 2 7, Date.new 2000 10 3, Date.new 2020]
            r2.at 'ints' . to_vector . should_equal [2, 4, 5, 3, 1]

            r3 = df.order_by (['times'])
            r3.at 'times' . to_vector . should_equal [Time_Of_Day.new 1 30 40, Time_Of_Day.new 10 20 30, Time_Of_Day.new 12, Time_Of_Day.new 12 30 0, Time_Of_Day.new 23 59 59]
            r3.at 'ints' . to_vector . should_equal [2, 5, 1, 4, 3]

            r4 = df.order_by (['datetimes'])
            r4.at 'datetimes' . to_vector . should_equal [Date_Time.new 1999 1 1 1 30 40, Date_Time.new 1999 12 31 12 30 0, Date_Time.new 2000 10 3 10 20 30, Date_Time.new 2000 10 3 23 59 59, Date_Time.new 2020 1 1 12]
            r4.at 'ints' . to_vector . should_equal [2, 4, 5, 3, 1]

            r5 = df.order_by (['objs'])
            r5.at 'objs' . to_vector . should_equal [My.Data 2 3, My.Data 6 7, My.Data 8 9, My.Data 10 30, My.Data 100 2]
            r5.at 'ints' . to_vector . should_equal [2, 3, 4, 5, 1]

            r6 = df.order_by (['mixed_dates'])
            r6 . should_fail_with Incomparable_Values

    Test.group "Sorting Columns" <|
        Test.specify 'should sort columns with specified ordering and missing placement' <|
            c = Column.from_vector 'foo' [1, 7, Nothing, 4, 8, Nothing]

            r_1 = c.sort
            r_1.to_vector.should_equal [1,4,7,8,Nothing,Nothing]

            r_2 = c.sort Sort_Direction.Descending
            r_2.to_vector.should_equal [8,7,4,1,Nothing,Nothing]

            r_3 = c.sort Sort_Direction.Descending missing_last=False
            r_3.to_vector.should_equal [Nothing,Nothing,8,7,4,1]

        Test.specify 'should respect defined comparison operations for custom types' <|
            c = Column.from_vector 'foo'  [My.Data 1 2, My.Data 3 4, My.Data 2 1, My.Data 5 2, My.Data 7 0, My.Data 4 -1]
            r = c.sort
            r.to_vector.should_equal [My.Data 1 2, My.Data 2 1, My.Data 4 -1, My.Data 3 4, My.Data 5 2, My.Data 7 0]


        Test.specify 'should allow passing a custom comparator' <|
            c = Column.from_vector 'foo' [My.Data 1 2, My.Data 2 5, My.Data 3 4, My.Data 6 3, Nothing, My.Data 1 0]
            cmp a b = Ordering.compare (a.x-a.y).abs (b.x-b.y).abs
            r = c.sort by=cmp
            r.to_vector.should_equal [Nothing, My.Data 1 2, My.Data 3 4, My.Data 1 0, My.Data 2 5, My.Data 6 3]

            d = Column.from_vector 'foo' [1,3,2,4,Nothing,5]
            cmp2 a b = Ordering.compare -a -b
            r2 = d.sort by=cmp2
            r2.to_vector.should_equal [5,4,3,2,1,Nothing]
            r3 = d.sort by=cmp2 missing_last=False
            r3.to_vector.should_equal [Nothing,5,4,3,2,1]

        Test.specify 'should handle Unicode characters correctly' <|
            c = Column.from_vector 'c' ['z', 'a', 'd', 'f', 's', 'e\u0301', 'ś', 'ą', 's\u0301', 'w', 'b']
            c.sort.to_vector . should_equal ['a', 'ą', 'b', 'd', 'e\u0301', 'f', 's', 's\u0301', 'ś', 'w', 'z']

    Test.group "Slicing Tables" <|
        Test.specify 'should allow taking first n rows' <|
            i_1 = ['ix', [1, 2, 3]]
            c_1 = ['col', [5, 6, 7]]
            c_2 = ['col2', ["a", Nothing, "c"]]
            c_3 = ['col3', [False, True, Nothing]]
            t_1 = Table.new [i_1, c_1, c_2, c_3]

            t_1.take (First 10) . at 'col' . to_vector . should_equal (t_1.at 'col' . to_vector)
            t_1.take 10 . at 'col' . to_vector . should_equal (t_1.at 'col' . to_vector)

            t_2 = t_1.take (First 2)
            t_2.at 'col' . to_vector . should_equal (t_1.at 'col' . to_vector . take (First 2))
            t_2.at 'col2' . to_vector . should_equal (t_1.at 'col2' . to_vector . take (First 2))
            t_2.at 'col3' . to_vector . should_equal (t_1.at 'col3' . to_vector . take (First 2))

            t_3 = t_1.take 2
            t_3.at 'col' . to_vector . should_equal (t_1.at 'col' . to_vector . take 2)
            t_3.at 'col2' . to_vector . should_equal (t_1.at 'col2' . to_vector . take 2)
            t_3.at 'col3' . to_vector . should_equal (t_1.at 'col3' . to_vector . take 2)

            t_1.at 'col' . take (First 2) . to_vector . should_equal (t_1.at 'col' . to_vector . take (First 2))
            t_1.at 'col' . take 2 . to_vector . should_equal (t_1.at 'col' . to_vector . take 2)

        Test.specify "should allow taking the last n rows" <|
            i_1 = ['ix', [1, 2, 3]]
            c_1 = ['col1', [5, 6, 7]]
            c_2 = ['col2', ["a", Nothing, "c"]]
            c_3 = ['col3', [False, True, Nothing]]
            t_1 = Table.new [i_1, c_1, c_2, c_3]

            t_1.take (Last 10) . at 'col1' . to_vector . should_equal (t_1.at 'col1' . to_vector)

            t_2 = t_1.take (Last 2)
            t_2.at 'col1' . to_vector . should_equal (t_1.at 'col1' . to_vector . take (Last 2))
            t_2.at 'col2' . to_vector . should_equal (t_1.at 'col2' . to_vector . take (Last 2))
            t_2.at 'col3' . to_vector . should_equal (t_1.at 'col3' . to_vector . take (Last 2))

            t_1.at 'col1' . take (Last 2) . to_vector . should_equal (t_1.at 'col1' . to_vector . take (Last 2))

        Test.specify "should allow taking/dropping a prefix of rows that satisfy a predicate" <|
            t1 = Table.new [["X", [1, 2, 3, 4, 5, 5]], ["Y", [9, 8, 7, 2, 10, 5]]]

            t2 = t1.take (Index_Sub_Range.While row-> row.to_vector.compute Statistic.Sum == 10)
            t2.at "X" . to_vector . should_equal [1, 2, 3]
            t2.at "Y" . to_vector . should_equal [9, 8, 7]

            t3 = t1.drop (Index_Sub_Range.While row-> row.to_vector.compute Statistic.Sum == 10)
            t3.at "X" . to_vector . should_equal [4, 5, 5]
            t3.at "Y" . to_vector . should_equal [2, 10, 5]

            t4 = t1.take (Index_Sub_Range.While row-> row.at "X" < 3)
            t4.at "X" . to_vector . should_equal [1, 2]
            t4.at "Y" . to_vector . should_equal [9, 8]

            t5 = t1.drop (Index_Sub_Range.While row-> row.at 1 > 3)
            t5.at "X" . to_vector . should_equal [4, 5, 5]
            t5.at "Y" . to_vector . should_equal [2, 10, 5]

            t6 = t1.take (Index_Sub_Range.While row-> row.at "X" > 1)
            t6.at "X" . to_vector . should_equal []
            t6.at "Y" . to_vector . should_equal []

        Test.specify "should allow reversing the table" <|
            i_1 = ['ix', [1, 2, 3]]
            c_1 = ['col1', [5, 6, 7]]
            c_2 = ['col2', ["a", Nothing, "c"]]
            c_3 = ['col3', [False, True, Nothing]]
            t_1 = Table.new [i_1, c_1, c_2, c_3]

            expected_i_1 = ['ix', [3, 2, 1]]
            expected_c_1 = ['col1', [7, 6, 5]]
            expected_c_2 = ['col2', ["c", Nothing, "a"]]
            expected_c_3 = ['col3', [Nothing, True, False]]
            expected = Table.new [expected_i_1, expected_c_1, expected_c_2, expected_c_3]

            t_2 = t_1.reverse

            t_2.at 'col1' . to_vector . should_equal (expected.at 'col1' . to_vector)
            t_2.at 'col2' . to_vector . should_equal (expected.at 'col2' . to_vector)
            t_2.at 'col3' . to_vector . should_equal (expected.at 'col3' . to_vector)

    Test.group "fill"
        Test.specify "should allow to fill_nothing from a value" <|
            col0 = Column.from_vector "col0" [0, Nothing, 4, 5, Nothing, Nothing]
            col1 = Column.from_vector "col1" [Nothing, 200, Nothing, 400, 500, Nothing]
            default = 1000
            t = Table.new [col0, col1]
            actual = t.fill_nothing ["col0", "col1"] default
            actual.at "col0" . to_vector . should_equal [0, 1000, 4, 5, 1000, 1000]
            actual.at "col1" . to_vector . should_equal [1000, 200, 1000, 400, 500, 1000]

        Test.specify "should allow to fill_nothing from other columns" <|
            col0 = Column.from_vector "col0" [0, Nothing, 4, 5, Nothing, Nothing]
            col1 = Column.from_vector "col1" [Nothing, 200, Nothing, 400, 500, Nothing]
            defaults = Column.from_vector "def0" [1, 2, 10, 20, Nothing, 30]
            t = Table.new [col0, col1]
            actual = t.fill_nothing ["col0", "col1"] defaults
            actual.at "col0" . to_vector . should_equal [0, 2, 4, 5, Nothing, 30]
            actual.at "col1" . to_vector . should_equal [1, 200, 10, 400, 500, 30]

        Test.specify "should allow to fill_empty from a value" <|
            col0 = Column.from_vector "col0" ["0", Nothing, "4", "5", Nothing, Nothing]
            col1 = Column.from_vector "col1" [Nothing, "200", Nothing, "400", "500", Nothing]
            default = "1000"
            t = Table.new [col0, col1]
            actual = t.fill_empty ["col0", "col1"] default
            actual.at "col0" . to_vector . should_equal ["0", "1000", "4", "5", "1000", "1000"]
            actual.at "col1" . to_vector . should_equal ["1000", "200", "1000", "400", "500", "1000"]

        Test.specify "should allow to fill_empty from other columns" <|
            col0 = Column.from_vector "col0" ["0", Nothing, "4", "5", Nothing, Nothing]
            col1 = Column.from_vector "col1" [Nothing, "200", Nothing, "400", "500", Nothing]
            defaults = Column.from_vector "def0" ["1", "2", "10", "20", Nothing, "30"]
            t = Table.new [col0, col1]
            actual = t.fill_empty ["col0", "col1"] defaults
            actual.at "col0" . to_vector . should_equal ["0", "2", "4", "5", Nothing, "30"]
            actual.at "col1" . to_vector . should_equal ["1", "200", "10", "400", "500", "30"]

        Test.specify "fill_nothing should leave other columns alone" <|
            col0 = Column.from_vector "col0" [0, Nothing, 4, 5, Nothing, Nothing]
            col_between = Column.from_vector "col_between" [3, 4, 5, 6, 7, 8]
            col1 = Column.from_vector "col1" [Nothing, 200, Nothing, 400, 500, Nothing]
            default = 1000
            t = Table.new [col0, col_between, col1]
            actual = t.fill_nothing ["col0", "col1"] default
            actual.at "col0" . to_vector . should_equal [0, 1000, 4, 5, 1000, 1000]
            actual.at "col_between" . to_vector . should_equal [3, 4, 5, 6, 7, 8]
            actual.at "col1" . to_vector . should_equal [1000, 200, 1000, 400, 500, 1000]
            actual.column_names . should_equal ["col0", "col_between", "col1"]

        Test.specify "fill_nothing should work with integer column selectors" <|
            col0 = Column.from_vector "col0" [0, Nothing, 4, 5, Nothing, Nothing]
            col_between = Column.from_vector "col_between" [3, 4, 5, 6, 7, 8]
            col1 = Column.from_vector "col1" [Nothing, 200, Nothing, 400, 500, Nothing]
            default = 1000
            t = Table.new [col0, col_between, col1]
            actual = t.fill_nothing [0, 2] default
            actual.at "col0" . to_vector . should_equal [0, 1000, 4, 5, 1000, 1000]
            actual.at "col_between" . to_vector . should_equal [3, 4, 5, 6, 7, 8]
            actual.at "col1" . to_vector . should_equal [1000, 200, 1000, 400, 500, 1000]
            actual.column_names . should_equal ["col0", "col_between", "col1"]

    Test.group "Use First Row As Names" <|
        expect_column_names names table =
            table.columns . map .name . should_equal names frames_to_skip=2

        Test.specify "should work happily with mixed types" <|
            c_0 = ['A', ["H", "B", "C"]]
            c_1 = ['B', [Date.new 1980, Date.new 1979, Date.new 2000]]
            c_2 = ['x', [1, 2, 3]]
            c_3 = ['Y', [5.3, 56.2, 6.3]]
            c_4 = ['Z', [True, False, True]]
            table = Table.new [c_0, c_1, c_2, c_3, c_4]
            expect_column_names ["H", "1980-01-01", "1", "5.3", "True"] table.use_first_row_as_names

        Test.specify "should correctly handle problems: invalid names ''" <|
            c_0 = ['A', ["", "B", "C"]]
            c_1 = ['B', [Date.new 1980, Date.new 1979, Date.new 2000]]
            c_2 = ['x', [1, 2, 3]]
            c_3 = ['Y', [5.3, 56.2, 6.3]]
            c_4 = ['Z', [True, False, True]]
            table = Table.new [c_0, c_1, c_2, c_3, c_4]
            action = table.use_first_row_as_names on_problems=_
            tester = expect_column_names ["Column 1", "1980-01-01", "1", "5.3", "True"]
            problems = [Invalid_Column_Names.Error [""]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: invalid names Nothing" <|
            c_0 = ['A', ["A", "B", "C"]]
            c_1 = ['B', [Date.new 1980, Date.new 1979, Date.new 2000]]
            c_2 = ['x', [Nothing, 2, 3]]
            c_3 = ['Y', [5.3, 56.2, 6.3]]
            c_4 = ['Z', [True, False, True]]
            table = Table.new [c_0, c_1, c_2, c_3, c_4]
            action = table.use_first_row_as_names on_problems=_
            tester = expect_column_names ["A", "1980-01-01", "Column 1", "5.3", "True"]
            problems = [Invalid_Column_Names.Error [Nothing]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: multiple invalid names" <|
            c_0 = ['A', ["", "B", "C"]]
            c_1 = ['B', [Date.new 1980, Date.new 1979, Date.new 2000]]
            c_2 = ['x', [Nothing, 2, 3]]
            c_3 = ['Y', [5.3, 56.2, 6.3]]
            c_4 = ['Z', [True, False, True]]
            table = Table.new [c_0, c_1, c_2, c_3, c_4]
            action = table.use_first_row_as_names on_problems=_
            tester = expect_column_names ["Column 1", "1980-01-01", "Column 2", "5.3", "True"]
            problems = [Invalid_Column_Names.Error ["", Nothing]]
            Problems.test_problem_handling action problems tester

        Test.specify "should correctly handle problems: duplicate names" <|
            c_0 = ['A', ["A", "B", "C"]]
            c_1 = ['B', ["A", "B", "C"]]
            c_2 = ['x', ["A", "B", "C"]]
            c_3 = ['C', ["A", "B", "C"]]
            table = Table.new [c_0, c_1, c_2, c_3]
            action = table.use_first_row_as_names on_problems=_
            tester = expect_column_names ["A", "A 1", "A 2", "A 3"]
            problems = [Duplicate_Output_Column_Names.Error ["A", "A", "A"]]
            Problems.test_problem_handling action problems tester

    Test.group "[In-Memory] Table.aggregate" <|
        Test.specify "should return columns with correct types" <|
            dates = ["dates", [Date.new 1999, Date.new 2000, Date.new 2000, Date.new 2000]]
            texts = ["texts", ["a", "bb", "a", "bb"]]
            mixed = ["mixed", [1, "a", "a", 1]]
            ints = ["ints", [0, 1, 1, 0]]
            floats = ["floats", [0.1, 1.0, 2.0, 1.5]]
            objects = ["objects", [My.Data 0 1, My.Data 0 1, My.Data 2 2, My.Data 2 2]]
            table = Table.new [dates, texts, mixed, ints, floats, objects]

            t1 = table.aggregate [Group_By "dates", Shortest "texts", Aggregate_Column.First "texts", Aggregate_Column.First "objects", Aggregate_Column.First "ints", Aggregate_Column.Last "mixed"]
            t1.info.at "Column" . to_vector . should_equal ["dates", "Shortest texts", "First texts", "First objects", "First ints", "Last mixed"]
            t1.info.at "Value Type" . to_vector . should_equal [Value_Type.Date, Value_Type.Char, Value_Type.Char, Value_Type.Mixed, Value_Type.Integer, Value_Type.Mixed]

            t2 = table.aggregate [Mode "dates", Count_Not_Nothing "objects", Count_Distinct "texts", Minimum "ints", Maximum "floats"]
            t2.info.at "Column" . to_vector . should_equal ["Mode dates", "Count Not Nothing objects", "Count Distinct texts", "Minimum ints", "Maximum floats"]
            t2.info.at "Value Type" . to_vector . should_equal [Value_Type.Date, Value_Type.Integer, Value_Type.Integer, Value_Type.Integer, Value_Type.Float]

            t3 = table.aggregate [Group_By "texts", Group_By "ints", Aggregate_Column.Last "floats"]
            t3.info.at "Column" . to_vector . should_equal ["texts", "ints", "Last floats"]
            t3.info.at "Value Type" . to_vector . should_equal [Value_Type.Char, Value_Type.Integer, Value_Type.Float]

            t4 = table.aggregate [Group_By "mixed", Sum "ints", Sum "floats"]
            t4.info.at "Column" . to_vector . should_equal ["mixed", "Sum ints", "Sum floats"]
            t4.info.at "Value Type" . to_vector . should_equal [Value_Type.Mixed, Value_Type.Float, Value_Type.Float]

        Test.specify "should take Unicode normalization into account when grouping by Text" <|
            texts = ["texts", ['ściana', 'ściana', 'łąka', 's\u0301ciana', 'ła\u0328ka', 'sciana']]
            ints = ["ints", [1, 2, 4, 8, 16, 32]]
            table = Table.new [texts, ints]
            r1 = table.aggregate [Group_By "texts", Sum "ints"] . order_by ([Sort_Column.Name "texts"])
            r1.at "texts" . to_vector . should_equal ['sciana', 'ściana', 'łąka']
            r1.at "Sum ints" . to_vector . should_equal [32, 11, 20]

            r2 = table.aggregate [Count_Distinct "texts"]
            r2.at "Count Distinct texts" . to_vector . should_equal [3]

        Test.specify "should be able to aggregate over enso Types" <|
            weekday_table  = Table.new [["days", [Day_Of_Week.Monday, Day_Of_Week.Monday, Day_Of_Week.Monday, Day_Of_Week.Tuesday, Day_Of_Week.Sunday]], ["group", [1,1,2,1,2]]]

            r1 = weekday_table.aggregate [Group_By "days"] . order_by "days"
            r1.at "days" . to_vector . should_equal [Day_Of_Week.Sunday, Day_Of_Week.Monday, Day_Of_Week.Tuesday]

            r2 = weekday_table.aggregate [Group_By "group", Minimum "days" "min", Maximum "days" "max"] . order_by "group"
            r2.at "group" . to_vector . should_equal [1, 2]
            r2.at "min" . to_vector . should_equal [Day_Of_Week.Monday, Day_Of_Week.Sunday]
            r2.at "max" . to_vector . should_equal [Day_Of_Week.Tuesday, Day_Of_Week.Monday]

    ## We have a separate set of tests for In-Memory distinct as it gives us
       more guarantees: preserving order of rows and always selecting the first
       row of ones sharing the same distinctness key. For database tests (to be
       added later) we can not rely on ordering.
    Test.group "[In-Memory] Table.distinct" <|
        Test.specify "should allow to select distinct rows based on a subset of columns, returning the first row from each group" <|
            a = ["A", ["a", "a", "a", "a", "a", "a"]]
            b = ["B", [1, 1, 2, 2, 1, 2]]
            c = ["C", [0.1, 0.2, 0.3, 0.4, 0.5, 0.6]]
            t = Table.new [a, b, c]

            r2 = t.distinct ["A", "B"] on_problems=Report_Error
            r2.at "A" . to_vector . should_equal ["a", "a"]
            r2.at "B" . to_vector . should_equal [1, 2]
            r2.at "C" . to_vector . should_equal [0.1, 0.3]

        Test.specify "should handle nulls correctly and preserve original ordering" <|
            a = ["A", ["a", Nothing, "b", "a", "b", Nothing, "a", "b"]]
            b = ["B", [1, 2, 3, 4, 5, 6, 7, 8]]
            t = Table.new [a, b]
            r = t.distinct ["A"] on_problems=Report_Error
            r.at "A" . to_vector . should_equal ["a", Nothing, "b"]
            r.at "B" . to_vector . should_equal [1, 2, 3]

        Test.specify "should handle Unicode normalization of keys correctly" <|
            t1 = Table.new [["X", ['ś', 's\u0301', 's', 'ś']]]
            t1.distinct . at "X" . to_vector . should_equal ['ś', 's']

        Test.specify "should allow to control case-sensitivity of keys, correctly handling Unicode folding" <|
            x = ["X", ['A', 'a', 'enso', 'śledź', 'Enso', 'A', 's\u0301ledz\u0301']]
            y = ["Y", [1, 2, 3, 4, 5, 6, 7]]
            t1 = Table.new [x, y]
            d1 = t1.distinct ["X"] on_problems=Report_Error
            d1.at "X" . to_vector . should_equal ['A', 'a', 'enso', 'śledź', 'Enso']
            d1.at "Y" . to_vector . should_equal [1, 2, 3, 4, 5]

            d2 = t1.distinct ["X"] case_sensitivity=Case_Sensitivity.Insensitive on_problems=Report_Error
            d2.at "X" . to_vector . should_equal ['A', 'enso', 'śledź']
            d2.at "Y" . to_vector . should_equal [1, 3, 4]

            t2 = Table.new [["X", ["łąka", "STRASSE", "Straße", "ﬃ", "ŁĄka", "ffi"]]]
            t2.distinct case_sensitivity=Case_Sensitivity.Insensitive . at "X" . to_vector . should_equal ["łąka", "STRASSE", "ﬃ"]

        Test.specify "should report a warning if the key contains floating point values" <|
            t1 = Table.new [["X", [3.0, 1.0, 2.0, 2.0, 1.0]]]
            action1 = t1.distinct on_problems=_
            tester1 table =
                table.at "X" . to_vector . should_equal [3.0, 1.0, 2.0]
            problems1 = [Floating_Point_Equality.Error "X"]
            Problems.test_problem_handling action1 problems1 tester1

            t2 = Table.new [["X", [1.00000000000001, -0.3, 1.00000000000002, 1.5, 1.00000000000002, 1.00000000000002]]]
            action2 = t2.distinct on_problems=_
            tester2 table =
                table.at "X" . to_vector . should_equal [1.00000000000001, -0.3, 1.00000000000002, 1.5]
            problems2 = [Floating_Point_Equality.Error "X"]
            Problems.test_problem_handling action2 problems2 tester2

        Test.specify "should be able to create distinct on Enso objects" <|
            t = Table.new [["X", [My.Data 1 2, My.Data 3 4, My.Data 1 2]]]
            t.distinct ["X"] . at "X" . to_vector . should_equal [My.Data 1 2, My.Data 3 4]

            t2 = Table.new [["X", [Day_Of_Week.Monday, Day_Of_Week.Tuesday, Day_Of_Week.Monday, Day_Of_Week.Monday, Day_Of_Week.Tuesday, Day_Of_Week.Wednesday]]]
            t2.distinct ["X"] . at "X" . to_vector . should_equal [Day_Of_Week.Monday, Day_Of_Week.Tuesday, Day_Of_Week.Wednesday]

    Test.group "[In-Memory] Table.filter" <|
        Test.specify "by a custom predicate" <|
            t = Table.new [["ix", [1, 2, 3, 4, 5]], ["X", [5, 0, 4, 5, 1]]]
            t1 = t.filter "X" (x -> x % 2 == 0)
            t1.at "ix" . to_vector . should_equal [2, 3]
            t1.at "X" . to_vector . should_equal [0, 4]

            t2 = t.filter 1 (>2)
            t2.at "ix" . to_vector . should_equal [1, 3, 4]
            t2.at "X" . to_vector . should_equal [5, 4, 5]

            t3 = t.filter (t.at "X" + 1) (x -> x % 2 == 0)
            t3.at "ix" . to_vector . should_equal [1, 4, 5]
            t3.at "X" . to_vector . should_equal [5, 5, 1]

        Test.specify "by custom object comparisons" <|
            t = Table.new [["ix", [1, 2, 3, 4, 5]], ["X", [My.Data 1 2, My.Data 300 400, My.Data 100 200, My.Data 5 6, My.Data 7 8]]]
            t1 = t.filter "X" (Filter_Condition.Between (My.Data 10 20) (My.Data 300 400))
            t1.at "ix" . to_vector . should_equal [2, 3]
            t1.at "X" . to_vector . should_equal [My.Data 300 400, My.Data 100 200]
            t.filter "X" (Filter_Condition.Less than=(My.Data 5 6)) . at "X" . to_vector . should_equal [My.Data 1 2]
            t.filter "X" (Filter_Condition.Equal_Or_Less than=(My.Data 5 6)) . at "X" . to_vector . should_equal [My.Data 1 2, My.Data 5 6]
            t.filter "X" (Filter_Condition.Greater than=(My.Data 5 6)) . at "X" . to_vector . should_equal [My.Data 300 400, My.Data 100 200, My.Data 7 8]
            t.filter "X" (Filter_Condition.Equal_Or_Greater than=(My.Data 5 6)) . at "X" . to_vector . should_equal [My.Data 300 400, My.Data 100 200, My.Data 5 6, My.Data 7 8]
            t.filter "X" (Filter_Condition.Equal to=(My.Data 2 1)) . at "X" . to_vector . should_equal [My.Data 1 2]
            t.filter "X" (Filter_Condition.Equal to=42) . at "X" . to_vector . should_equal []

            c = Column.from_vector "Y" [My.Data 2 1, My.Data 400 300, My.Data 101 202, My.Data 10 10, My.Data 15 0]
            t.filter "X" (Filter_Condition.Equal to=c) . at "X" . to_vector . should_equal [My.Data 1 2, My.Data 300 400, My.Data 7 8]
            t.filter "X" (Filter_Condition.Less than=c) . at "X" . to_vector . should_equal [My.Data 100 200, My.Data 5 6]
            t.filter "X" (Filter_Condition.Greater than=c) . at "X" . to_vector . should_equal []

        Test.specify "by a boolean mask of varying length" <|
            t = Table.new [["A", [1, 2, 3]], ["B", [4, 5, 6]]]

            t1 = t.filter (Column.from_vector "f" [False, True])
            t1.at "A" . to_vector . should_equal [2]
            t1.at "B" . to_vector . should_equal [5]

            t2 = t.filter (Column.from_vector "f" [False, True, True, True, True, True, True, True])
            t2.at "A" . to_vector . should_equal [2, 3]
            t2.at "B" . to_vector . should_equal [5, 6]

        Test.specify "by an Is_In check, on various types of columns" <|
            ins = Table.new <|
                str = ["str", ["c", "b", Nothing, Nothing]]
                int = ["int", [1, 2, 3, 3]]
                int2 = ["int2", [1, Nothing, Nothing, 1]]
                dbl = ["dbl", [0.0, 0.0, Nothing, Nothing]]
                dates = ["dates", [Date.new 2000, Date.new 1999 1 1, Date.new 1999 1 1, Date_Time.new 2022 8 20]]
                dts = ["dts", [Date_Time.new 2022 8 27 11 22 25, Nothing, Date_Time.new 2030, Date.new 2000]]
                tod = ["tod", [Time_Of_Day.new 18 00, Time_Of_Day.new 18 19, Date_Time.new 2000 1 1, Time_Of_Day.new 18 19]]
                mix = ["mix", [42, Date_Time.new 2022 8 27, 1, 1]]
                nulls = ["nulls", [Nothing, Nothing, Nothing, 0]]
                custom = ["custom", [2, My.Data 2 1, Nothing, Nothing]]
                [str, int, int2, dbl, dates, dts, tod, mix, nulls, custom]
            varied_type_table.filter "strs" (Filter_Condition.Is_In (ins.at "str")) . at "strs" . to_vector . should_equal ["b", "c", Nothing]
            varied_type_table.filter "strs" (Filter_Condition.Is_In (ins.at "str" . to_vector)) . at "strs" . to_vector . should_equal ["b", "c", Nothing]
            varied_type_table.filter "ints" (Filter_Condition.Is_In (ins.at "int")) . at "ints" . to_vector . should_equal [1, 2]
            varied_type_table.filter "ints" (Filter_Condition.Is_In (ins.at "int" . to_vector)) . at "ints" . to_vector . should_equal [1, 2]
            varied_type_table.filter "ints" (Filter_Condition.Is_In (ins.at "int2")) . at "ints" . to_vector . should_equal [Nothing, 1]
            varied_type_table.filter "ints" (Filter_Condition.Is_In (ins.at "int2" . to_vector)) . at "ints" . to_vector . should_equal [Nothing, 1]
            varied_type_table.filter "doubles" (Filter_Condition.Is_In (ins.at "dbl")) . at "doubles" . to_vector . should_equal [0.0, Nothing]
            varied_type_table.filter "doubles" (Filter_Condition.Is_In (ins.at "dbl" . to_vector)) . at "doubles" . to_vector . should_equal [0.0, Nothing]
            varied_type_table.filter "dates" (Filter_Condition.Is_In (ins.at "dates")) . at "dates" . to_vector . should_equal [Date.new 2000, Date.new 1999 1 1]
            varied_type_table.filter "dates" (Filter_Condition.Is_In (ins.at "dates" . to_vector)) . at "dates" . to_vector . should_equal [Date.new 2000, Date.new 1999 1 1]
            varied_type_table.filter "datetimes" (Filter_Condition.Is_In (ins.at "dts")) . at "datetimes" . to_vector . should_equal [Nothing, Date_Time.new 2022 8 27 11 22 25]
            varied_type_table.filter "datetimes" (Filter_Condition.Is_In (ins.at "dts" . to_vector)) . at "datetimes" . to_vector . should_equal [Nothing, Date_Time.new 2022 8 27 11 22 25]
            varied_type_table.filter "times" (Filter_Condition.Is_In (ins.at "tod")) . at "times" . to_vector . should_equal [Time_Of_Day.new 18 00]
            varied_type_table.filter "times" (Filter_Condition.Is_In (ins.at "tod" . to_vector)) . at "times" . to_vector . should_equal [Time_Of_Day.new 18 00]
            varied_type_table.filter "mixed" (Filter_Condition.Is_In [42, "a", 1, Nothing, Date.new 2022 8 27, Date_Time.new 2022 8 27]) . at "mixed" . to_vector . should_equal [1, "a", Nothing, Date.new 2022 8 27]
            varied_type_table.filter "mixed" (Filter_Condition.Is_In (ins.at "mix")) . at "mixed" . to_vector . should_equal [1]
            varied_type_table.filter "mixed" (Filter_Condition.Is_In (ins.at "mix" . to_vector)) . at "mixed" . to_vector . should_equal [1]
            varied_type_table.filter "just_nulls" (Filter_Condition.Is_In []) . at "just_nulls" . to_vector . should_equal []
            varied_type_table.filter "just_nulls" (Filter_Condition.Is_In (ins.at "nulls")) . at "just_nulls" . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]
            varied_type_table.filter "just_nulls" (Filter_Condition.Is_In (ins.at "nulls" . to_vector)) . at "just_nulls" . to_vector . should_equal [Nothing, Nothing, Nothing, Nothing]
            varied_type_table.filter "just_nulls" (Filter_Condition.Is_In [0]) . at "just_nulls" . to_vector . should_equal []
            varied_type_table.filter "custom_objects" (Filter_Condition.Is_In (ins.at "custom")) . at "custom_objects" . to_vector . should_equal [My.Data 1 2, Nothing, Nothing]
            varied_type_table.filter "custom_objects" (Filter_Condition.Is_In (ins.at "custom" . to_vector)) . at "custom_objects" . to_vector . should_equal [My.Data 1 2, Nothing, Nothing]

            t2 = Table.new [["ints", [1, 2, 3]], ["doubles", [1.2, 0.0, 1.0]]]
            t2.filter "ints" (Filter_Condition.Is_In [2.0, 1.5, 3, 4]) . at "ints" . to_vector . should_equal [2, 3]
            t2.filter "doubles" (Filter_Condition.Is_In [0.1, 1, 3, 1.2]) . at "doubles" . to_vector . should_equal [1.2, 1.0]
            t3 = Table.new [["ints", [0, 2]], ["doubles", [1.0, 2.0]]]
            t2.filter "ints" (Filter_Condition.Is_In (t3.at "doubles")) . at "ints" . to_vector . should_equal [1, 2]
            t2.filter "doubles" (Filter_Condition.Is_In (t3.at "ints")) . at "doubles" . to_vector . should_equal [0.0]

            # We test these very carefully as our implementation relies on some short-circuit logic that is not as trivial as the hashmap checks which are done for other builtin types.
            [True, False].each has_nulls->
                [True, False].each has_true->
                    [True, False].each has_false->
                        vec_builder = Vector.new_builder
                        if has_nulls then vec_builder.append Nothing
                        if has_true then vec_builder.append True
                        if has_false then vec_builder.append False
                        in_vector = vec_builder.to_vector

                        vectors = [[True, False, Nothing], [Nothing, Nothing, Nothing], [False, False, True], [True, True, True], [False, False, False], [Nothing, True, True], [False, Nothing, False]]
                        vectors.each column_vector->
                            not x = case x of
                                True -> False
                                False -> True
                                Nothing -> Nothing
                            negated_column_vector = column_vector.map not
                            ## A workaround to ensure that X has Boolean type.
                               It can be removed with
                            t0 = Table.new [["X", [True]+column_vector]]
                            t = t0.drop 1
                            in_column = Column.from_vector "in" in_vector

                            expected_vector = column_vector.filter (Filter_Condition.Is_In in_vector)
                            expected_neg_vector = negated_column_vector.filter (Filter_Condition.Is_In in_vector)

                            Test.with_clue "(Is_In "+in_vector.to_text+"): " <|
                                t.filter "X" (Filter_Condition.Is_In in_vector) . at "X" . to_vector . should_equal expected_vector
                                t.filter "X" (Filter_Condition.Is_In in_column) . at "X" . to_vector . should_equal expected_vector
                                t2 = t.set (t.at "X" . not) new_name="Y"
                                t2.filter "Y" (Filter_Condition.Is_In in_vector) . at "Y" . to_vector . should_equal expected_neg_vector
                                t2.filter "Y" (Filter_Condition.Is_In in_column) . at "Y" . to_vector . should_equal expected_neg_vector

    Test.group "[In-Memory-specific] Table.join" <|
        Test.specify "should correctly report unsupported cross-backend joins" <|
            t = Table.new [["X", [1, 2, 3]]]
            Panic.recover Type_Error (t.join 42) . should_fail_with Type_Error

            db_connection = Database.connect (SQLite In_Memory)
            db_table = (Table.new [["Y", [4, 5, 6]]]).select_into_database_table db_connection "test"

            r = t.join db_table
            r.should_fail_with Illegal_Argument
            r.catch.message . contains "cross-backend" . should_be_true

    Test.group "[In-Memory-specific] Table.set" <|
        Test.specify "should allow using vector and range for a new column" <|
            t = Table.new [["X", [1, 2, 3]]]

            t_vec = t.set [10, 20, 30]
            t_vec.column_names.should_equal ["X", "Vector"]
            t_vec.at "Vector" . to_vector . should_equal [10, 20, 30]

            t_range = t.set (100.up_to 103)
            t_range.column_names.should_equal ["X", "Range"]
            t_range.at "Range" . to_vector . should_equal [100, 101, 102]

            t_date_range = t.set ((Date.new 2020 1 1).up_to (Date.new 2020 1 4))
            t_date_range.column_names.should_equal ["X", "Date Range"]
            t_date_range.at "Date Range" . to_vector . should_equal [Date.new 2020 1 1, Date.new 2020 1 2, Date.new 2020 1 3]

        Test.specify "should fail if there is a length mismatch on a new column" <|
            t = Table.new [["X", [1, 2, 3]]]

            c = Column.from_vector "Column" [10, 20]
            t.set c . should_fail_with Row_Count_Mismatch
            t.set [10, 20] . should_fail_with Row_Count_Mismatch
            t.set (100.up_to 102) . should_fail_with Row_Count_Mismatch
            t.set ((Date.new 2020 1 1).up_to (Date.new 2020 1 3)) . should_fail_with Row_Count_Mismatch

main = Test_Suite.run_main spec

## JS indexes months form 0, so we need to subtract 1.
foreign js js_make_date year month day = """
    return new Date(year, month - 1, day)

foreign js js_make_object key value = """
    var obj = {}
    obj[key] = value
    return obj

foreign python py_make_date year month day = """
    import datetime
    return datetime.date(year, month, day)

foreign python py_make_object key value = """
    return {key: value}
