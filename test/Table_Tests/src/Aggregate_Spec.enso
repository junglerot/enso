from Standard.Base import all

import Standard.Table
from Standard.Table.Data.Column_Selector import By_Name, By_Index
from Standard.Table.Data.Aggregate_Column import all
from Standard.Table.Error as Error_Module import Missing_Input_Columns, Column_Indexes_Out_Of_Range, No_Output_Columns, Duplicate_Output_Column_Names, Invalid_Output_Column_Names, Invalid_Aggregation, Floating_Point_Grouping, Unquoted_Delimiter, Additional_Warnings

import Standard.Test
import Standard.Test.Problems
import Standard.Base.Error.Problem_Behavior

type Test_Selection problem_handling=True advanced_stats=True text_concat=True text_shortest_longest=True first_last=True first_last_row_order=True std_dev=True multi_distinct=True aggregation_problems=True

all_tests = Test_Selection True True True True True True True True True

spec =
    file_contents = (Enso_Project.data / "data.csv") . read
    table = Table.from_csv file_contents
    empty_table = Table.new <| table.columns.map c->[c.name, []]
    materialize = x->x
    here.aggregate_spec "[In-Memory] " table empty_table materialize

## Runs the common aggregate tests.

   Arguments:
   - prefix: A name to prepend to test groups to identify the tested backend.
   - table: A table using the tested backend containing data from
     `data/data.csv`.
   - empty_table: An empty table using the tested backend.
   - materialize: A helper function which materializes a table from the tested
     backend as an in-memory table. Used to easily inspect results of a
     particular query/operation.
   - test_selection: A selection of which suites should be run. Can be used to
     skip checks for backends which do not support particular features.
   - pending: An optional mark to disable all test groups. Can be used to
     indicate that some tests are disabled due to missing test setup.
aggregate_spec prefix table empty_table materialize test_selection=here.all_tests pending=Nothing =
    expect_column_names names table =
        table.columns . map .name . should_equal names frames_to_skip=2

    find_row key table (columns=Nothing) =
        table_columns = if columns.is_nothing then table.columns else columns.map x->(table.columns.at x)
        0.up_to table.row_count . find i->
            0.up_to key.length . all j-> (table_columns.at j . at i)==(key.at j)

    Test.group prefix+"Table.aggregate should summarize whole table" pending=pending <|
        Test.specify "should be able to count" <|
            grouped = table.aggregate [Count Nothing]
            materialized = materialize grouped
            ## TODO check row count of not materialized one
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 1
            materialized.columns.at 0 . name . should_equal "Count"
            materialized.columns.at 0 . at 0 . should_equal 2500

        Test.specify "should be able to count missing values" <|
            grouped = table.aggregate [Count_Nothing "Hexadecimal", Count_Not_Nothing "Hexadecimal", Count_Empty "TextWithNothing", Count_Not_Empty "TextWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 4
            materialized.columns.at 0 . name . should_equal "Count Nothing Hexadecimal"
            materialized.columns.at 0 . at 0 . should_equal 236
            materialized.columns.at 1 . name . should_equal "Count Not Nothing Hexadecimal"
            materialized.columns.at 1 . at 0 . should_equal 2264
            materialized.columns.at 2 . name . should_equal "Count Empty TextWithNothing"
            materialized.columns.at 2 . at 0 . should_equal 249
            materialized.columns.at 3 . name . should_equal "Count Not Empty TextWithNothing"
            materialized.columns.at 3 . at 0 . should_equal 2251

        Test.specify "should be able to count distinct values" <|
            grouped = table.aggregate [Count_Distinct "Code", Count_Distinct "Index", Count_Distinct "Flag"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 3
            materialized.columns.at 0 . name . should_equal "Count Distinct Code"
            materialized.columns.at 0 . at 0 . should_equal 2333
            materialized.columns.at 1 . name . should_equal "Count Distinct Index"
            materialized.columns.at 1 . at 0 . should_equal 10
            materialized.columns.at 2 . name . should_equal "Count Distinct Flag"
            materialized.columns.at 2 . at 0 . should_equal 2

        Test.specify "should be able to count distinct values over multiple columns" (pending=if test_selection.multi_distinct.not then "Not supported.") <|
            ## TODO [RW] add Count_Distinct with overridden ignore_nothing! also need to modify data.csv to include some nulls on index and flag
            grouped = table.aggregate [Count_Distinct (By_Name ["Index", "Flag"])]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 1
            materialized.columns.at 0 . name . should_equal "Count Distinct Index Flag"
            materialized.columns.at 0 . at 0 . should_equal 20

        Test.specify "should be able to compute sum and average of values" <|
            grouped = table.aggregate [Sum "Value", Sum "ValueWithNothing", Average "Value", Average "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 4
            materialized.columns.at 0 . name . should_equal "Sum Value"
            materialized.columns.at 0 . at 0 . should_equal -932.411550 epsilon=0.000001
            materialized.columns.at 1 . name . should_equal "Sum ValueWithNothing"
            materialized.columns.at 1 . at 0 . should_equal 2757.09 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Average Value"
            materialized.columns.at 2 . at 0 . should_equal -0.372965 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Average ValueWithNothing"
            materialized.columns.at 3 . at 0 . should_equal 1.228650 epsilon=0.000001

        Test.specify "should be able to compute standard deviation of values" (pending=if test_selection.std_dev.not then "Not supported.") <|
            grouped = table.aggregate [Standard_Deviation "Value", Standard_Deviation "ValueWithNothing", (Standard_Deviation "Value" population=True), (Standard_Deviation "ValueWithNothing" population=True)]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 4
            materialized.columns.at 0 . name . should_equal "Standard Deviation Value"
            materialized.columns.at 0 . at 0 . should_equal 56.708660 epsilon=0.000001
            materialized.columns.at 1 . name . should_equal "Standard Deviation ValueWithNothing"
            materialized.columns.at 1 . at 0 . should_equal 58.588610 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Standard Deviation Value_1"
            materialized.columns.at 2 . at 0 . should_equal 56.697317 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Standard Deviation ValueWithNothing_1"
            materialized.columns.at 3 . at 0 . should_equal 58.575554 epsilon=0.000001

        Test.specify "should be able to create median, mode and percentile values" (pending=if test_selection.advanced_stats.not then "Not supported.") <|
            grouped = table.aggregate [Median "Index", Median "Value", Median "ValueWithNothing", Mode "Index", Percentile 0.25 "Value", Percentile 0.40 "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 6
            materialized.columns.at 0 . name . should_equal "Median Index"
            materialized.columns.at 0 . at 0 . should_equal 5 epsilon=0.000001
            materialized.columns.at 1 . name . should_equal "Median Value"
            materialized.columns.at 1 . at 0 . should_equal 1.298375 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Median ValueWithNothing"
            materialized.columns.at 2 . at 0 . should_equal 2.235 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Mode Index"
            materialized.columns.at 3 . at 0 . should_equal 7
            materialized.columns.at 4 . name . should_equal "25%-ile Value"
            materialized.columns.at 4 . at 0 . should_equal -49.962710 epsilon=0.000001
            materialized.columns.at 5 . name . should_equal "40%-ile ValueWithNothing"
            materialized.columns.at 5 . at 0 . should_equal -17.960000 epsilon=0.000001

        Test.specify "should be able to get first and last values" (pending=if test_selection.first_last.not then "Not supported.") <|
            grouped = table.aggregate [First "Index" (order_by = By_Name ["Hexadecimal", "TextWithNothing"]), Last "ValueWithNothing" (order_by = By_Name ["Value"])]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 2
            materialized.columns.at 0 . name . should_equal "First Index"
            materialized.columns.at 0 . at 0 . should_equal 9
            materialized.columns.at 1 . name . should_equal "Last ValueWithNothing"
            materialized.columns.at 1 . at 0 . should_equal -89.78 epsilon=0.000001

        Test.specify "should be able to get first and last values with default row order" (pending=if test_selection.first_last_row_order.not then "Not supported.") <|
            grouped = table.aggregate [First "Index", Last "Value"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 2
            materialized.columns.at 0 . name . should_equal "First Index"
            materialized.columns.at 0 . at 0 . should_equal 7
            materialized.columns.at 1 . name . should_equal "Last Value"
            materialized.columns.at 1 . at 0 . should_equal 70.99931 epsilon=0.000001

        Test.specify "should be able to get minimum and maximum values" <|
            grouped = table.aggregate [Minimum "Value", Maximum "Value", Minimum "ValueWithNothing", Maximum "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 4
            materialized.columns.at 0 . name . should_equal "Minimum Value"
            materialized.columns.at 0 . at 0 . should_equal -99.964200 epsilon=0.000001
            materialized.columns.at 1 . name . should_equal "Maximum Value"
            materialized.columns.at 1 . at 0 . should_equal 99.977480 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Minimum ValueWithNothing"
            materialized.columns.at 2 . at 0 . should_equal -99.99 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Maximum ValueWithNothing"
            materialized.columns.at 3 . at 0 . should_equal 99.95 epsilon=0.000001

        Test.specify "should be able to get shortest and longest text values" (pending=if test_selection.text_shortest_longest.not then "Not supported.")  <|
            grouped = table.aggregate [Shortest "TextWithNothing", Longest "TextWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 2
            materialized.columns.at 0 . name . should_equal "Shortest TextWithNothing"
            materialized.columns.at 0 . at 0 . should_equal "f5"
            materialized.columns.at 1 . name . should_equal "Longest TextWithNothing"
            materialized.columns.at 1 . at 0 . should_equal "setp295gjvbanana"

        Test.specify "should be able to get concatenated text values" (pending=if test_selection.text_concat.not then "Not supported.")  <|
            grouped = table.aggregate [Concatenate "Code"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 1
            materialized.columns.at 0 . name . should_equal "Concatenate Code"
            materialized.columns.at 0 . at 0 . length . should_equal 7500

    Test.group prefix+"Table.aggregate should summarize empty table" pending=pending <|
        Test.specify "should be able to count" <|
            grouped = empty_table.aggregate [Count Nothing]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 1
            materialized.columns.at 0 . name . should_equal "Count"
            materialized.columns.at 0 . at 0 . should_equal 0

        Test.specify "should be able to count missing values" <|
            grouped = empty_table.aggregate [Count_Nothing "Hexadecimal", Count_Not_Nothing "Hexadecimal", Count_Empty "TextWithNothing", Count_Not_Empty "TextWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 4
            materialized.columns.at 0 . name . should_equal "Count Nothing Hexadecimal"
            materialized.columns.at 0 . at 0 . should_equal 0
            materialized.columns.at 1 . name . should_equal "Count Not Nothing Hexadecimal"
            materialized.columns.at 1 . at 0 . should_equal 0
            materialized.columns.at 2 . name . should_equal "Count Empty TextWithNothing"
            materialized.columns.at 2 . at 0 . should_equal 0
            materialized.columns.at 3 . name . should_equal "Count Not Empty TextWithNothing"
            materialized.columns.at 3 . at 0 . should_equal 0

        Test.specify "should be able to count distinct values" <|
            grouped = empty_table.aggregate [Count_Distinct "Code"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 1
            materialized.columns.at 0 . name . should_equal "Count Distinct Code"
            materialized.columns.at 0 . at 0 . should_equal 0

        Test.specify "should be able to compute sum and average of values" <|
            grouped = empty_table.aggregate [Sum "Value", Average "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 2
            materialized.columns.at 0 . name . should_equal "Sum Value"
            materialized.columns.at 0 . at 0 . should_equal Nothing
            materialized.columns.at 1 . name . should_equal "Average ValueWithNothing"
            materialized.columns.at 1 . at 0 . should_equal Nothing

        Test.specify "should be able to compute standard deviation of values" (pending=if test_selection.std_dev.not then "Not supported.") <|
            grouped = empty_table.aggregate [Standard_Deviation "Value", (Standard_Deviation "ValueWithNothing" population=True)]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 2
            materialized.columns.at 0 . name . should_equal "Standard Deviation Value"
            materialized.columns.at 0 . at 0 . should_equal Nothing
            materialized.columns.at 1 . name . should_equal "Standard Deviation ValueWithNothing"
            materialized.columns.at 1 . at 0 . should_equal Nothing

        Test.specify "should be able to create median, mode and percentile values" (pending=if test_selection.advanced_stats.not then "Not supported.") <|
            grouped = empty_table.aggregate [Median "Index", Mode "Index", Percentile 0.25 "Value"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 3
            materialized.columns.at 0 . name . should_equal "Median Index"
            materialized.columns.at 0 . at 0 . should_equal Nothing
            materialized.columns.at 1 . name . should_equal "Mode Index"
            materialized.columns.at 1 . at 0 . should_equal Nothing
            materialized.columns.at 2 . name . should_equal "25%-ile Value"
            materialized.columns.at 2 . at 0 . should_equal Nothing

        Test.specify "should be able to get first and last values" (pending=if test_selection.first_last.not then "Not supported.") <|
            grouped = empty_table.aggregate [First "Index" (order_by = By_Name ["Hexadecimal", "TextWithNothing"]), Last "ValueWithNothing" (order_by = By_Name ["Value"])]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 2
            materialized.columns.at 0 . name . should_equal "First Index"
            materialized.columns.at 0 . at 0 . should_equal Nothing
            materialized.columns.at 1 . name . should_equal "Last ValueWithNothing"
            materialized.columns.at 1 . at 0 . should_equal Nothing

        Test.specify "should be able to get first and last values with default row order" (pending=if test_selection.first_last_row_order.not then "Not supported.") <|
            grouped = empty_table.aggregate [First "Index", Last "Value"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 2
            materialized.columns.at 0 . name . should_equal "First Index"
            materialized.columns.at 0 . at 0 . should_equal Nothing
            materialized.columns.at 1 . name . should_equal "Last Value"
            materialized.columns.at 1 . at 0 . should_equal Nothing

        Test.specify "should be able to get minimum and maximum values" <|
            grouped = empty_table.aggregate [Minimum "Value", Maximum "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 2
            materialized.columns.at 0 . name . should_equal "Minimum Value"
            materialized.columns.at 0 . at 0 . should_equal Nothing
            materialized.columns.at 1 . name . should_equal "Maximum ValueWithNothing"
            materialized.columns.at 1 . at 0 . should_equal Nothing

        Test.specify "should be able to get shortest and longest text values" (pending=if test_selection.text_shortest_longest.not then "Not supported.") <|
            grouped = empty_table.aggregate [Shortest "TextWithNothing", Longest "TextWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 2
            materialized.columns.at 0 . name . should_equal "Shortest TextWithNothing"
            materialized.columns.at 0 . at 0 . should_equal Nothing
            materialized.columns.at 1 . name . should_equal "Longest TextWithNothing"
            materialized.columns.at 1 . at 0 . should_equal Nothing

        Test.specify "should be able to get concatenated text values" (pending=if test_selection.text_concat.not then "Not supported.") <|
            grouped = empty_table.aggregate [Concatenate "Code"]
            materialized = materialize grouped
            grouped.row_count . should_equal 1
            materialized.columns.length . should_equal 1
            materialized.columns.at 0 . name . should_equal "Concatenate Code"
            materialized.columns.at 0 . at 0 . should_equal Nothing

    Test.group prefix+"Table.aggregate should not summarize empty table when grouped" pending=pending <|
        Test.specify "should be able to count" <|
            grouped = empty_table.aggregate [Group_By 0, Count Nothing]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.columns.length . should_equal 2
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "Count"

        Test.specify "should be able to count missing values" <|
            grouped = empty_table.aggregate [Group_By 0, Count_Nothing "Hexadecimal", Count_Not_Nothing "Hexadecimal", Count_Empty "TextWithNothing", Count_Not_Empty "TextWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.columns.length . should_equal 5
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "Count Nothing Hexadecimal"
            materialized.columns.at 2 . name . should_equal "Count Not Nothing Hexadecimal"
            materialized.columns.at 3 . name . should_equal "Count Empty TextWithNothing"
            materialized.columns.at 4 . name . should_equal "Count Not Empty TextWithNothing"

        Test.specify "should be able to count distinct values" <|
            grouped = empty_table.aggregate [Group_By 0, Count_Distinct "Code"]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.columns.length . should_equal 2
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "Count Distinct Code"

        Test.specify "should be able to compute sum and average of values" <|
            grouped = empty_table.aggregate [Group_By 0, Sum "Value", Average "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.columns.length . should_equal 3
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "Sum Value"
            materialized.columns.at 2 . name . should_equal "Average ValueWithNothing"

        Test.specify "should be able to compute standard deviation of values" (pending=if test_selection.std_dev.not then "Not supported.") <|
            grouped = empty_table.aggregate [Group_By 0, Standard_Deviation "Value", (Standard_Deviation "ValueWithNothing" population=True)]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.columns.length . should_equal 3
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "Standard Deviation Value"
            materialized.columns.at 2 . name . should_equal "Standard Deviation ValueWithNothing"

        Test.specify "should be able to create median values" (pending=if test_selection.advanced_stats.not then "Not supported.") <|
            grouped = empty_table.aggregate [Group_By 0, Median "Index", Mode "Index", Percentile 0.25 "Value"]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.columns.length . should_equal 4
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "Median Index"
            materialized.columns.at 2 . name . should_equal "Mode Index"
            materialized.columns.at 3 . name . should_equal "25%-ile Value"

        Test.specify "should be able to get first and last values" (pending=if test_selection.first_last.not then "Not supported.") <|
            grouped = empty_table.aggregate [Group_By 0, First "Index" (order_by = By_Name ["Hexadecimal", "TextWithNothing"]), Last "ValueWithNothing" (order_by = By_Name ["Value"])]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.columns.length . should_equal 3
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "First Index"
            materialized.columns.at 2 . name . should_equal "Last ValueWithNothing"

        Test.specify "should be able to get first and last values with default row order" (pending=if test_selection.first_last_row_order.not then "Not supported.") <|
            grouped = empty_table.aggregate [Group_By 0, First "Index", Last "Value"]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.columns.length . should_equal 3
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "First Index"
            materialized.columns.at 2 . name . should_equal "Last Value"

        Test.specify "should be able to get minimum and maximum values" <|
            grouped = empty_table.aggregate [Group_By 0, Minimum "Value", Maximum "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.columns.length . should_equal 3
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "Minimum Value"
            materialized.columns.at 2 . name . should_equal "Maximum ValueWithNothing"

        Test.specify "should be able to get shortest and longest text values" (pending=if test_selection.text_shortest_longest.not then "Not supported.") <|
            grouped = empty_table.aggregate [Group_By 0, Shortest "TextWithNothing", Longest "TextWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.columns.length . should_equal 3
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "Shortest TextWithNothing"
            materialized.columns.at 2 . name . should_equal "Longest TextWithNothing"

        Test.specify "should be able to get concatenated text values" (pending=if test_selection.text_concat.not then "Not supported.") <|
            grouped = empty_table.aggregate [Group_By 0, Concatenate "Code"]
            materialized = materialize grouped
            grouped.row_count . should_equal 0
            materialized.columns.length . should_equal 2
            materialized.columns.at 0 . name . should_equal "Code"
            materialized.columns.at 1 . name . should_equal "Concatenate Code"

    Test.group prefix+"Table.aggregate should be able to group on single field" pending=pending <|
        Test.specify "should be able to count" <|
            grouped = table.aggregate [Group_By "Index", Count Nothing]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.columns.length . should_equal 2
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Count"
            materialized.columns.at 1 . at idx . should_equal 261

        Test.specify "should be able to count missing values" <|
            grouped = table.aggregate [Group_By "Index", Count_Nothing "Hexadecimal", Count_Not_Nothing "Hexadecimal", Count_Empty "TextWithNothing", Count_Not_Empty "TextWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.columns.length . should_equal 5
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Count Nothing Hexadecimal"
            materialized.columns.at 1 . at idx . should_equal 24
            materialized.columns.at 2 . name . should_equal "Count Not Nothing Hexadecimal"
            materialized.columns.at 2 . at idx . should_equal 237
            materialized.columns.at 3 . name . should_equal "Count Empty TextWithNothing"
            materialized.columns.at 3 . at idx . should_equal 31
            materialized.columns.at 4 . name . should_equal "Count Not Empty TextWithNothing"
            materialized.columns.at 4 . at idx . should_equal 230

        Test.specify "should be able to count distinct values" <|
            grouped = table.aggregate [Group_By "Index", Count_Distinct "Code", Count_Distinct "Index", Count_Distinct "Flag"]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.columns.length . should_equal 4
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Count Distinct Code"
            materialized.columns.at 1 . at idx . should_equal 260
            materialized.columns.at 2 . name . should_equal "Count Distinct Index"
            materialized.columns.at 2 . at idx . should_equal 1
            materialized.columns.at 3 . name . should_equal "Count Distinct Flag"
            materialized.columns.at 3 . at idx . should_equal 2

        Test.specify "should be able to count distinct values over multiple columns" (pending=if test_selection.multi_distinct.not then "Not supported.") <|
            ## TODO probably should use different cols for multi-distinct and also should check ignore_nothing
            grouped = table.aggregate [Group_By "Index", Count_Distinct (By_Name ["Index", "Flag"])]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.columns.length . should_equal 2
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Count Distinct Index Flag"
            materialized.columns.at 1 . at idx . should_equal 2

        Test.specify "should be able to compute sum and average of values" <|
            grouped = table.aggregate [Group_By "Index", Sum "Value", Sum "ValueWithNothing", Average "Value", Average "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.columns.length . should_equal 5
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Sum Value"
            materialized.columns.at 1 . at idx . should_equal -447.847390 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Sum ValueWithNothing"
            materialized.columns.at 2 . at idx . should_equal 151.86 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Average Value"
            materialized.columns.at 3 . at idx . should_equal -1.715890 epsilon=0.000001
            materialized.columns.at 4 . name . should_equal "Average ValueWithNothing"
            materialized.columns.at 4 . at idx . should_equal 0.646213 epsilon=0.000001

        Test.specify "should be able to compute standard deviation of values" (pending=if test_selection.std_dev.not then "Not supported.") <|
            grouped = table.aggregate [Group_By "Index", Standard_Deviation "Value", Standard_Deviation "ValueWithNothing", (Standard_Deviation "Value" population=True), (Standard_Deviation "ValueWithNothing" population=True)]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.columns.length . should_equal 5
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Standard Deviation Value"
            materialized.columns.at 1 . at idx . should_equal 60.272158 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Standard Deviation ValueWithNothing"
            materialized.columns.at 2 . at idx . should_equal 56.798691 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Standard Deviation Value_1"
            materialized.columns.at 3 . at idx . should_equal 60.156583 epsilon=0.000001
            materialized.columns.at 4 . name . should_equal "Standard Deviation ValueWithNothing_1"
            materialized.columns.at 4 . at idx . should_equal 56.677714 epsilon=0.000001

        Test.specify "should be able to create median values" (pending=if test_selection.advanced_stats.not then "Not supported.") <|
            grouped = table.aggregate [Group_By "Index", Median "Index", Median "Value", Median "ValueWithNothing", Mode "Index", Percentile 0.25 "Value", Percentile 0.40 "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.columns.length . should_equal 7
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Median Index"
            materialized.columns.at 1 . at idx . should_equal 6 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Median Value"
            materialized.columns.at 2 . at idx . should_equal 2.041150 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Median ValueWithNothing"
            materialized.columns.at 3 . at idx . should_equal 1.38 epsilon=0.000001
            materialized.columns.at 4 . name . should_equal "Mode Index"
            materialized.columns.at 4 . at idx . should_equal 6
            materialized.columns.at 5 . name . should_equal "25%-ile Value"
            materialized.columns.at 5 . at idx . should_equal -56.019100 epsilon=0.000001
            materialized.columns.at 6 . name . should_equal "40%-ile ValueWithNothing"
            materialized.columns.at 6 . at idx . should_equal -18.802000 epsilon=0.000001

        Test.specify "should be able to get first and last values" (pending=if test_selection.first_last.not then "Not supported.") <|
            grouped = table.aggregate [Group_By "Index", First "TextWithNothing" (order_by = By_Name ["Hexadecimal", "Flag"]), Last "ValueWithNothing" (order_by = By_Name ["Value"])]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.columns.length . should_equal 3
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "First TextWithNothing"
            materialized.columns.at 1 . at idx . should_equal "v78nbv8fr1"
            materialized.columns.at 2 . name . should_equal "Last ValueWithNothing"
            materialized.columns.at 2 . at idx . should_equal 19.77 epsilon=0.000001

        Test.specify "should be able to get first and last values with default row order" (pending=if test_selection.first_last_row_order.not then "Not supported.") <|
            grouped = table.aggregate [Group_By "Index", First "TextWithNothing", Last "Value"]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.columns.length . should_equal 3
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "First TextWithNothing"
            materialized.columns.at 1 . at idx . should_equal "kmqxqkl6qx"
            materialized.columns.at 2 . name . should_equal "Last Value"
            materialized.columns.at 2 . at idx . should_equal 56.15916 epsilon=0.000001

        Test.specify "should be able to get minimum and maximum values" <|
            grouped = table.aggregate [Group_By "Index", Minimum "Value", Maximum "Value", Minimum "ValueWithNothing", Maximum "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.columns.length . should_equal 5
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Minimum Value"
            materialized.columns.at 1 . at idx . should_equal -99.605880 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Maximum Value"
            materialized.columns.at 2 . at idx . should_equal 99.12739 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Minimum ValueWithNothing"
            materialized.columns.at 3 . at idx . should_equal -99.99 epsilon=0.000001
            materialized.columns.at 4 . name . should_equal "Maximum ValueWithNothing"
            materialized.columns.at 4 . at idx . should_equal 99.79 epsilon=0.000001

        Test.specify "should be able to get shortest and longest text values" (pending=if test_selection.text_shortest_longest.not then "Not supported.") <|
            grouped = table.aggregate [Group_By "Index", Shortest "TextWithNothing", Longest "TextWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.columns.length . should_equal 3
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [1] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Shortest TextWithNothing"
            materialized.columns.at 1 . at idx . should_equal "f5"
            materialized.columns.at 2 . name . should_equal "Longest TextWithNothing"
            materialized.columns.at 2 . at idx . should_equal "byo6kn5l3sz"

        Test.specify "should be able to get concatenated text values" (pending=if test_selection.text_concat.not then "Not supported.") <|
            grouped = table.aggregate [Group_By "Index", Concatenate "Code"]
            materialized = materialize grouped
            grouped.row_count . should_equal 10
            materialized.columns.length . should_equal 2
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row [6] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Concatenate Code"
            materialized.columns.at 1 . at idx . length . should_equal 783

    Test.group prefix+"Table.aggregate should be able to group on multiple fields not in left columns" pending=pending <|
        Test.specify "should be able to count" <|
            grouped = table.aggregate [Group_By "Flag", Count Nothing, Group_By "Index"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.columns.length . should_equal 3
            materialized.columns.at 0 . name . should_equal "Flag"
            materialized.columns.at 2 . name . should_equal "Index"
            idx = find_row ["False", 6] materialized [0, 2]
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Count"
            materialized.columns.at 1 . at idx . should_equal 127

        Test.specify "should be able to count missing values" <|
            grouped = table.aggregate [Count_Nothing "Hexadecimal", Count_Not_Nothing "Hexadecimal", Group_By "Index", Count_Empty "TextWithNothing", Group_By "Flag", Count_Not_Empty "TextWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.columns.length . should_equal 6
            materialized.columns.at 4 . name . should_equal "Flag"
            materialized.columns.at 2 . name . should_equal "Index"
            idx = find_row ["False", 6] materialized [4, 2]
            idx.is_nothing . should_be_false
            materialized.columns.at 0 . name . should_equal "Count Nothing Hexadecimal"
            materialized.columns.at 0 . at idx . should_equal 8
            materialized.columns.at 1 . name . should_equal "Count Not Nothing Hexadecimal"
            materialized.columns.at 1 . at idx . should_equal 119
            materialized.columns.at 3 . name . should_equal "Count Empty TextWithNothing"
            materialized.columns.at 3 . at idx . should_equal 12
            materialized.columns.at 5 . name . should_equal "Count Not Empty TextWithNothing"
            materialized.columns.at 5 . at idx . should_equal 115

        Test.specify "should be able to count distinct values" <|
            grouped = table.aggregate [Group_By "Index", Count_Distinct "Code", Count_Distinct "Index", Count_Distinct "Flag", Group_By "Flag"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.columns.length . should_equal 5
            materialized.columns.at 0 . name . should_equal "Index"
            materialized.columns.at 4 . name . should_equal "Flag"
            idx = find_row ["False", 6] materialized [4, 0]
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Count Distinct Code"
            materialized.columns.at 1 . at idx . should_equal 127
            materialized.columns.at 2 . name . should_equal "Count Distinct Index"
            materialized.columns.at 2 . at idx . should_equal 1
            materialized.columns.at 3 . name . should_equal "Count Distinct Flag"
            materialized.columns.at 3 . at idx . should_equal 1

        Test.specify "should be able to count distinct values over multiple columns" (pending=if test_selection.multi_distinct.not then "Not supported.") <|
            ## TODO probably should use different cols for multi-distinct and also should check ignore_nothing
            grouped = table.aggregate [Group_By "Index", Count_Distinct (By_Name ["Index", "Flag"]), Group_By "Flag"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.columns.length . should_equal 3
            materialized.columns.at 0 . name . should_equal "Index"
            materialized.columns.at 2 . name . should_equal "Flag"
            idx = find_row ["False", 6] materialized [2, 0]
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Count Distinct Index Flag"
            materialized.columns.at 1 . at idx . should_equal 1

        Test.specify "should be able to compute sum and average of values" <|
            grouped = table.aggregate [Group_By "Index", Sum "Value", Sum "ValueWithNothing", Average "Value", Average "ValueWithNothing", Group_By "Flag"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.columns.length . should_equal 6
            materialized.columns.at 0 . name . should_equal "Index"
            materialized.columns.at 5 . name . should_equal "Flag"
            idx = find_row ["False", 6] materialized [5, 0]
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Sum Value"
            materialized.columns.at 1 . at idx . should_equal -103.050170 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Sum ValueWithNothing"
            materialized.columns.at 2 . at idx . should_equal 533.57 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Average Value"
            materialized.columns.at 3 . at idx . should_equal -0.811419 epsilon=0.000001
            materialized.columns.at 4 . name . should_equal "Average ValueWithNothing"
            materialized.columns.at 4 . at idx . should_equal 4.721858 epsilon=0.000001

        Test.specify "should be able to compute standard deviation of values" (pending=if test_selection.std_dev.not then "Not supported.") <|
            grouped = table.aggregate [Group_By "Index", Group_By "Flag", Standard_Deviation "Value", Standard_Deviation "ValueWithNothing", (Standard_Deviation "Value" population=True), (Standard_Deviation "ValueWithNothing" population=True)]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.columns.length . should_equal 6
            materialized.columns.at 0 . name . should_equal "Index"
            materialized.columns.at 1 . name . should_equal "Flag"
            idx = find_row ["False", 6] materialized [1, 0]
            idx.is_nothing . should_be_false
            materialized.columns.at 2 . name . should_equal "Standard Deviation Value"
            materialized.columns.at 2 . at idx . should_equal 58.979275 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Standard Deviation ValueWithNothing"
            materialized.columns.at 3 . at idx . should_equal 57.561756 epsilon=0.000001
            materialized.columns.at 4 . name . should_equal "Standard Deviation Value_1"
            materialized.columns.at 4 . at idx . should_equal 58.746614 epsilon=0.000001
            materialized.columns.at 5 . name . should_equal "Standard Deviation ValueWithNothing_1"
            materialized.columns.at 5 . at idx . should_equal 57.306492 epsilon=0.000001

        Test.specify "should be able to create median values" (pending=if test_selection.advanced_stats.not then "Not supported.") <|
            grouped = table.aggregate [Median "Index", Median "Value", Median "ValueWithNothing", Mode "Index", Group_By "Index", Group_By "Flag", Percentile 0.25 "Value", Percentile 0.40 "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.columns.length . should_equal 8
            materialized.columns.at 5 . name . should_equal "Flag"
            materialized.columns.at 4 . name . should_equal "Index"
            idx = find_row ["False", 6] materialized [5, 4]
            idx.is_nothing . should_be_false
            materialized.columns.at 0 . name . should_equal "Median Index"
            materialized.columns.at 0 . at idx . should_equal 6 epsilon=0.000001
            materialized.columns.at 1 . name . should_equal "Median Value"
            materialized.columns.at 1 . at idx . should_equal 2.041150 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Median ValueWithNothing"
            materialized.columns.at 2 . at idx . should_equal 3.55 epsilon=0.000001
            materialized.columns.at 3 . name . should_equal "Mode Index"
            materialized.columns.at 3 . at idx . should_equal 6
            materialized.columns.at 6 . name . should_equal "25%-ile Value"
            materialized.columns.at 6 . at idx . should_equal -52.628925 epsilon=0.000001
            materialized.columns.at 7 . name . should_equal "40%-ile ValueWithNothing"
            materialized.columns.at 7 . at idx . should_equal -17.174000 epsilon=0.000001

        Test.specify "should be able to get first and last values" (pending=if test_selection.first_last.not then "Not supported.") <|
            grouped = table.aggregate [Group_By "Flag", First "TextWithNothing" (order_by = By_Name ["Hexadecimal", "Flag"]), Last "ValueWithNothing" (order_by = By_Name ["Value"]), Group_By "Index"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.columns.length . should_equal 4
            materialized.columns.at 0 . name . should_equal "Flag"
            materialized.columns.at 3 . name . should_equal "Index"
            idx = find_row ["False", 6] materialized [0, 3]
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "First TextWithNothing"
            materialized.columns.at 1 . at idx . should_equal "v78nbv8fr1"
            materialized.columns.at 2 . name . should_equal "Last ValueWithNothing"
            materialized.columns.at 2 . at idx . should_equal 42.17 epsilon=0.000001

        Test.specify "should be able to get first and last values with default row order" (pending=if test_selection.first_last_row_order.not then "Not supported.") <|
            grouped = table.aggregate [Group_By "Flag", First "TextWithNothing", Last "Value", Group_By "Index"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.columns.length . should_equal 4
            materialized.columns.at 0 . name . should_equal "Flag"
            materialized.columns.at 3 . name . should_equal "Index"
            idx = find_row ["False", 6] materialized [0, 3]
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "First TextWithNothing"
            materialized.columns.at 1 . at idx . should_equal "kmqxqkl6qx"
            materialized.columns.at 2 . name . should_equal "Last Value"
            materialized.columns.at 2 . at idx . should_equal 56.15916 epsilon=0.000001

        Test.specify "should be able to get minimum and maximum values" <|
            grouped = table.aggregate [Group_By "Index", Minimum "Value", Maximum "Value", Group_By "Flag", Minimum "ValueWithNothing", Maximum "ValueWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.columns.length . should_equal 6
            materialized.columns.at 3 . name . should_equal "Flag"
            materialized.columns.at 0 . name . should_equal "Index"
            idx = find_row ["False", 6] materialized [3, 0]
            idx.is_nothing . should_be_false
            materialized.columns.at 1 . name . should_equal "Minimum Value"
            materialized.columns.at 1 . at idx . should_equal -99.605880 epsilon=0.000001
            materialized.columns.at 2 . name . should_equal "Maximum Value"
            materialized.columns.at 2 . at idx . should_equal 96.488390 epsilon=0.000001
            materialized.columns.at 4 . name . should_equal "Minimum ValueWithNothing"
            materialized.columns.at 4 . at idx . should_equal -99.99 epsilon=0.000001
            materialized.columns.at 5 . name . should_equal "Maximum ValueWithNothing"
            materialized.columns.at 5 . at idx . should_equal 97.17 epsilon=0.000001

        Test.specify "should be able to get shortest and longest text values" (pending=if test_selection.text_shortest_longest.not then "Not supported.") <|
            grouped = table.aggregate [Group_By "Index", Group_By "Flag", Shortest "TextWithNothing", Longest "TextWithNothing"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.columns.length . should_equal 4
            materialized.columns.at 0 . name . should_equal "Index"
            materialized.columns.at 1 . name . should_equal "Flag"
            idx = find_row [1, "False"] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 2 . name . should_equal "Shortest TextWithNothing"
            materialized.columns.at 2 . at idx . should_equal "f5"
            materialized.columns.at 3 . name . should_equal "Longest TextWithNothing"
            materialized.columns.at 3 . at idx . should_equal "byo6kn5l3sz"

        Test.specify "should be able to get concatenated text values" (pending=if test_selection.text_concat.not then "Not supported.") <|
            grouped = table.aggregate [Group_By "Index", Group_By "Flag", Concatenate "Code"]
            materialized = materialize grouped
            grouped.row_count . should_equal 20
            materialized.columns.length . should_equal 3
            materialized.columns.at 0 . name . should_equal "Index"
            materialized.columns.at 1 . name . should_equal "Flag"
            idx = find_row [6, "False"] materialized
            idx.is_nothing . should_be_false
            materialized.columns.at 2 . name . should_equal "Concatenate Code"
            materialized.columns.at 2 . at idx . length . should_equal 381

    problem_pending = case pending.is_nothing of
        False -> pending
        True -> if test_selection.problem_handling.not then "Not supported."
    Test.group prefix+"Table.aggregate should raise warnings when there are issues" pending=problem_pending <|
        table =
            col1 = ["Index", [1, 2, 3]]
            col2 = ["Value", [1, 2, 3]]
            Table.new [col1, col2]

        Test.specify "should raise a warning when there are no output columns" <|
            action = table.aggregate [] on_problems=_
            problems = [No_Output_Columns]
            tester = expect_column_names []
            Problems.test_problem_handling action problems tester

        Test.specify "should raise a warning when can't find a column by name" <|
            action = table.aggregate [Group_By "Missing", Group_By "Index"] on_problems=_
            problems = [Missing_Input_Columns ["Missing"]]
            tester = expect_column_names ["Index"]
            Problems.test_problem_handling action problems tester

        Test.specify "should raise a warning when an invalid column index" <|
            action = table.aggregate [Group_By -3, Group_By "Index"] on_problems=_
            problems = [Column_Indexes_Out_Of_Range [-3]]
            tester = expect_column_names ["Index"]
            Problems.test_problem_handling action problems tester

        Test.specify "should raise warnings when an invalid column index and no valid output" <|
            action = table.aggregate [Group_By -3] on_problems=_
            problems = [Column_Indexes_Out_Of_Range [-3], No_Output_Columns]
            tester = expect_column_names []
            Problems.test_problem_handling action problems tester

        Test.specify "should raise a warning when an invalid output name" <|
            action = table.aggregate [Group_By "Index" ""] on_problems=_
            problems = [Invalid_Output_Column_Names [""]]
            tester = expect_column_names ["Column"]
            Problems.test_problem_handling action problems tester

        Test.specify "should raise a warning when a duplicate column name" <|
            action = table.aggregate [Group_By "Index", Group_By 0] on_problems=_
            problems = [Duplicate_Output_Column_Names ["Index"]]
            tester = expect_column_names ["Index", "Index_1"]
            Problems.test_problem_handling action problems tester

        Test.specify "should raise a warning when a duplicate column name and rename default names first" <|
            action = table.aggregate [Group_By "Value", Group_By "Index" "Value"] on_problems=_
            problems = [Duplicate_Output_Column_Names ["Value"]]
            tester = expect_column_names ["Value_1", "Value"]
            Problems.test_problem_handling action problems tester

        Test.specify "should allow partial matches on Count_Distinct" <|
            action = table.aggregate [Count_Distinct (By_Name ["Missing", "Value"])] on_problems=_
            problems = [Missing_Input_Columns ["Missing"]]
            tester = expect_column_names ["Count Distinct Value"]
            Problems.test_problem_handling action problems tester

        Test.specify "should ignore Count_Distinct if no columns matched" <|
            action = table.aggregate [Count_Distinct (By_Index [-100])] on_problems=_
            problems = [Column_Indexes_Out_Of_Range [-100], No_Output_Columns]
            tester = expect_column_names []
            Problems.test_problem_handling action problems tester

    aggregate_pending = case pending.is_nothing of
        False -> pending
        True -> if test_selection.aggregation_problems.not then "Not supported."
    Test.group prefix+"Table.aggregate should raise warnings when there are issues computing aggregation" pending=aggregate_pending <|
        table =
            col1 = ["Index", [1, 2, 3]]
            col2 = ["Value", [1, 2, 3.1]]
            col3 = ["Text", ["A", ",", "C"]]
            col4 = ["Mixed", ["A", 1, "C"]]
            Table.new [col1, col2, col3, col4]

        Test.specify "should warn if grouping on a floating point" <|
            action = table.aggregate [Group_By 1] on_problems=_
            problems = [Floating_Point_Grouping "GroupBy" [2]]
            tester = expect_column_names ["Value"]
            Problems.test_problem_handling action problems tester

        Test.specify "should warn if totaling on a non number" <|
            action = table.aggregate [Sum "Text"] on_problems=_
            problems = [Invalid_Aggregation "Sum Text" [0] "Cannot convert to a number."]
            tester = expect_column_names ["Sum Text"]
            Problems.test_problem_handling action problems tester

        Test.specify "should warn if averaging on a non number" <|
            action = table.aggregate [Average "Text"] on_problems=_
            problems = [Invalid_Aggregation "Average Text" [0] "Cannot convert to a number."]
            tester = expect_column_names ["Average Text"]
            Problems.test_problem_handling action problems tester

        Test.specify "should warn if calculating standard deviation on a non number" <|
            action = table.aggregate [Standard_Deviation "Text"] on_problems=_
            problems = [Invalid_Aggregation "Standard Deviation Text" [0] "Cannot convert to a number."]
            tester = expect_column_names ["Standard Deviation Text"]
            Problems.test_problem_handling action problems tester

        Test.specify "should warn if median on a non number" <|
            action = table.aggregate [Median "Text"] on_problems=_
            problems = [Invalid_Aggregation "Median Text" [0] "Cannot convert to a number."]
            tester = expect_column_names ["Median Text"]
            Problems.test_problem_handling action problems tester

        Test.specify "should warn if trying shortest on a non text" <|
            action = table.aggregate [Shortest "Index"] on_problems=_
            problems = [Invalid_Aggregation "Shortest Index" [0] "Not a text value."]
            tester = expect_column_names ["Shortest Index"]
            Problems.test_problem_handling action problems tester

        Test.specify "should warn if trying count empties on a non text" <|
            action = table.aggregate [Count_Empty "Index"] on_problems=_
            problems = [Invalid_Aggregation "Count Empty Index" [0] "Not a text value."]
            tester = expect_column_names ["Count Empty Index"]
            Problems.test_problem_handling action problems tester

        Test.specify "should warn if trying concatenate on a non text" <|
            action = table.aggregate [Concatenate "Index"] on_problems=_
            problems = [Invalid_Aggregation "Concatenate Index" [0] "Not a text value."]
            tester = expect_column_names ["Concatenate Index"]
            Problems.test_problem_handling action problems tester

        Test.specify "should warn if trying concatenate unquoted delimiters" <|
            column = Concatenate "Text" separator=","
            action = table.aggregate [column] on_problems=_
            problems = [Unquoted_Delimiter "Concatenate Text" [1]]
            tester = expect_column_names ["Concatenate Text"]
            Problems.test_problem_handling action problems tester

        Test.specify "should warn if can't compare value for Min or Max" <|
            action = table.aggregate [Maximum "Mixed"] on_problems=_
            problems = [Invalid_Aggregation "Maximum Mixed" [1] "Cannot compare values."]
            tester = expect_column_names ["Maximum Mixed"]
            Problems.test_problem_handling action problems tester

    Test.group prefix+"Table.aggregate should merge warnings when issues computing aggregation" pending=aggregate_pending <|
        table =
            col1 = ["Key", ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O"]]
            col2 = ["Value", [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5]]
            col3 = ["Float", col2.second.map x->(1.5*x)]
            Table.new [col1, col2, col3]

        Test.specify "should merge Invalid Aggregation warnings" <|
            new_table = table.aggregate [Group_By "Key", Concatenate "Value"]
            problems = Warning.get_all new_table . map .value
            problems.length . should_equal 1
            problems.at 0 . is_an Invalid_Aggregation . should_be_true
            problems.at 0 . rows . length . should_equal 15

        Test.specify "should merge Floating Point Grouping warnings" <|
            new_table = table.aggregate [Group_By "Float", Count Nothing]
            problems = Warning.get_all new_table . map .value
            problems.length . should_equal 1
            problems.at 0 . is_an Floating_Point_Grouping . should_be_true
            problems.at 0 . rows . length . should_equal 9

main = Test.Suite.run_main here.spec
