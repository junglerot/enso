from Base import all

import Base.Test

Integer.is_even = this % 2 == 0

spec =
    almost_max_long = 9223372036854775806
    almost_max_long_times_three = 27670116110564327418
    hundred_factorial = 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
    describe "Integers" <|
        it "should be of unbound size when multiplied" <|
            1.upto 101 . fold 1 (*) . should_equal hundred_factorial
        it "should be of unbound size when added" <|
            (almost_max_long + almost_max_long + almost_max_long).should_equal almost_max_long_times_three
        it "should be of unbound size when subtracted" <|
            (0 - almost_max_long - almost_max_long - almost_max_long).should_equal almost_max_long_times_three.negate
        it "should be of unbound size when dividing" <|
            expected = 3372816184472482867110284450043137767873196479305249187406461598235841786750685581361224832688174410089430537516012695688121622150430744676
            ((1.upto 101 . fold 1 (*)) / 3*almost_max_long).should_equal expected
        it "should be of unbound size when taking remainder" <|
            expected = 3191479909175673432
            ((1.upto 101 . fold 1 (*)) % 3*almost_max_long).should_equal expected
        it "should allow defining extension methods through the Integer type for any number size" <|
            876543.is_even.should_be_false
            (1.upto 101 . fold 1 (*)).is_even.should_be_true
        it "should handle the negation edge cases" <|
            x = 9223372036854775808
            y = -x
            z = -9223372036854775808
            y.should_equal z
        it "should handle equality between small and big integers" <|
            (1 == hundred_factorial).should_be_false
            (hundred_factorial == 1).should_be_false
        it "should properly handle going to big numbers and back" <|
            ((almost_max_long * 3) / 3) . should_equal almost_max_long

