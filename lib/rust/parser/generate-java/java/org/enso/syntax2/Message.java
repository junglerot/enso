package org.enso.syntax2;

import java.io.File;
import java.nio.charset.StandardCharsets;

final class Message {
    private final java.nio.ByteBuffer buffer;
    private final java.nio.ByteBuffer context;
    private final int base;
    private final long metadata;
    private boolean encounteredUnsupportedSyntax;

    public Message(java.nio.ByteBuffer bufferIn, java.nio.ByteBuffer contextIn, long baseIn, long metadataIn) {
        buffer = bufferIn;
        context = contextIn;
        base = (int)baseIn;
        metadata = metadataIn;
    }

    public long get64() {
        return buffer.getLong();
    }

    public int get32() {
        return buffer.getInt();
    }

    public boolean getBoolean() {
        switch (buffer.get()) {
            case 0: return false;
            case 1: return true;
            default: throw new FormatException("Boolean out of range");
        }
    }

    public String getString() {
        int len = (int)get64();
        byte[] dst = new byte[len];
        buffer.get(dst);
        return new String(dst, StandardCharsets.UTF_8);
    }

    public java.nio.ByteBuffer context() {
        return context;
    }

    public int offset(int xLow32) {
        // Given the low bits of `x`, the low bits of `base`, and the invariant `x >= base`,
        // return `x - base`.
        int tmp = xLow32 - base;
        if (tmp < 0) {
            tmp += Integer.MAX_VALUE;
            tmp += 1;
        }
        return tmp;
    }

    String getLocation() {
        return "Message[buffer=" + buffer.position() + "]";
    }

    public boolean getEncounteredUnsupportedSyntax() {
        return encounteredUnsupportedSyntax;
    }

    public void markEncounteredUnsupportedSyntax() {
        encounteredUnsupportedSyntax = true;
    }

    public java.util.UUID getUuid(long nodeOffset, long nodeLength) {
        long high = Parser.getUuidHigh(metadata, nodeOffset, nodeLength);
        long low = Parser.getUuidLow(metadata, nodeOffset, nodeLength);
        if (high == 0 && low == 0) {
            // The native interface uses the Nil UUID value as a marker to indicate that no UUID was attached.
            // The Nil UUID will never collide with a real UUID generated by any scheme.
            return null;
        }
        return new java.util.UUID(high, low);
    }
}
