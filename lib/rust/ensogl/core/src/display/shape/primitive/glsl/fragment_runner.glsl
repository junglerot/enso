//! This code is the body of the fragment shader main function of a GLSL shape.



// =======================
// === Shape Rendering ===
// =======================
// The shape is first rendered by sampling the SDF equation generated by EnsoGL shape system and
// then it is clipped by a rectangle of the canvas size. The clipping is performed because the
// sprite size is slightly bigger than the canvas size in order to display anti-aliased border
// pixels when the sprite coordinates are not integers or if the scene is zoomed. See the docs
// attached to the shape system's geometry material to learn more.

vec2 position = input_local.xy ;
Shape view_box = debug_shape(rect(position, input_size));
Shape shape = run(position);
shape = intersection_no_blend(shape, view_box);
float alpha = shape.color.repr.raw.a;



// ===========================
// === Object ID Rendering ===
// ===========================

float alpha_no_aa = alpha > ID_ALPHA_THRESHOLD ? 1.0 : 0.0;
// We need to set a default value for `output_id`, as shader optimizer may remove the following
// branching which results in a code that does never write to `output_id` shader output. Such a code
// is an invalid shader, as every shader has to have a code that writes to all outputs (even if it
// does not happen if some conditions are met).
output_id = vec4(0.0);
if (pointer_events_enabled) {
    output_id = encode(input_global_instance_id,alpha_no_aa);
}



// =====================
// === Display Modes ===
// =====================

if (input_display_mode == DISPLAY_MODE_NORMAL) {
    output_color = srgba(shape.color).raw;
    output_color.rgb *= alpha;

} else if (input_display_mode == DISPLAY_MODE_CACHED_SHAPES_TEXTURE) {
    output_color = rgba(shape.color).raw;
    // The signed distance is stored in the texture's alpha channel in a special way. See
    // [`crate::display::shape::primitive::system::cached`] documentation for details.
    output_color.a = -shape.sdf.distance / CACHED_SHAPE_MAX_DISTANCE / 2.0 + 0.5;

} else if (input_display_mode == DISPLAY_MODE_DEBUG_SHAPE_AA_SPAN) {
    output_color = srgba(shape.color).raw;
    output_color.rgb *= alpha;
    output_color = outside_of_uv() ? vec4(1.0, 0.0, 0.0, 1.0) : output_color;

} else if (input_display_mode == DISPLAY_MODE_DEBUG_SDF) {
    float zoom = zoom();
    float factor = 200.0/zoom * input_pixel_ratio;
    Rgb col = distance_meter(shape.sdf.distance, factor, factor);
    output_color = rgba(col).raw;
    output_color.a = alpha_no_aa;
    output_color.rgb *= alpha_no_aa;

} else if (input_display_mode == DISPLAY_MODE_DEBUG_INSTANCE_ID) {
    float hue = float((input_global_instance_id + input_mouse_click_count % 10) * 7 % 100) / 100.0;
    Srgb color = srgb(hsv(hue, 1.0, 0.5));
    output_color.rgb = color.raw.rgb;
    output_color.a = alpha_no_aa;
    output_color.rgb *= alpha_no_aa;

} else if (input_display_mode == DISPLAY_MODE_DEBUG_SPRITE_OVERVIEW) {
    float hue_seed = float(input_global_instance_id + input_mouse_click_count % 10) * 17.0;
    float hue = mod(hue_seed, 100.0) / 100.0;
    output_color = srgba(hsva(hue, 1.0, 1.0, alpha_no_aa)).raw;
    output_color = outside_of_uv() ? vec4(output_color.rgb, 1.0) : output_color;
    output_color.a *= clamp(float(input_mouse_position.x)/1000.0, 0.1, 1.0);
    output_color.rgb *= output_color.a;

} else if (input_display_mode == DISPLAY_MODE_DEBUG_SPRITE_GRID) {
    float hue = float((input_global_instance_id + input_mouse_click_count % 10) * 7 % 100) / 100.0;
    Srgba color = srgba(hsv(hue, 1.0, 0.8), 1.0);
    Srgba grid_color = srgba(hsv(hue, 1.0, 0.6), 1.0);
    output_color = vec4(color.raw.rgb, clamp(float(input_mouse_position.x)/100.0, 0.1, 1.0));
    output_color *= alpha_no_aa;
    output_color = draw_grid(position, 1, grid_color.raw, output_color);
    output_color = draw_grid(position, 2, grid_color.raw, output_color);
    output_color = draw_grid(position, 3, grid_color.raw, output_color);

} else if (input_display_mode == DISPLAY_MODE_DEBUG_SPRITE_UV) {
     bool overflow = input_uv.x >= 1.0 || input_uv.y >= 1.0;
     float blue = overflow? .5 : .0;
     output_color = vec4(input_uv, blue, 1.0);

} else {
    // Unknown code, display a debug checkerboard.
    float stripe_width = input_size.x / 4.0;
    float stripe_height = input_size.y / 4.0;
    bool vertical = mod(position.x, stripe_width * 2.0) < stripe_width;
    bool horizontal = mod(position.y, stripe_height * 2.0) < stripe_height;
    bool filled = (vertical || horizontal) && !(vertical && horizontal);
    output_color = filled ? vec4(1.0,0.0,0.0,1.0) : vec4(0.0,0.0,0.0,1.0);
}
