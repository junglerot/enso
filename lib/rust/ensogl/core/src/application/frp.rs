//! FRP utilities for defining application components.



/// Generate a set of structures allowing for nice management of FRP inputs, outputs, and commands.
///
/// Given the definition:
///
/// ```compile_fail
///     define_endpoints! { [GLOBAL_OPTS] <GENERIC_PARAMETERS>
///         Input { [INPUT_OPTS]
///             input1 (f32),
///             input2 (),
///         }
///         Output { [OUTPUT_OPTS]
///             output1 (String),
///             output2 (bool),
///             output3 (),
///         }
///     }
/// ```
///
/// The `INPUT_OPTS`, `OUTPUT_OPTS`, and `GLOBAL_OPTS` are optional and will be passed directly to
/// input, output, or both FRP network definitions, respectively. For example, you can add the
/// `TRACE_ALL` option this way.
///
/// The `GENERIC_PARAMETERS` are also optional and makes all structures generated by this macro
/// parametrized by given generics. The parameters may have trait bounds in the same way as in
/// struct declarations, _except_ that all bounds must be in parenthesis; for example:
/// `<Foo:(Clone+Debug), Bar:(Debug+'static)>`.
///
/// The code presented below will be generated. Please note that additional fields are added
/// automatically. In particular, an output `focused(bool)`, and inputs `focus()`, `defocus()`,
/// and `set_focus(bool)` are always defined and connected. They are mainly used for shortcut
/// manager to send commands only to focused GUI elements.
///
/// ```compile_fail
///     /// Frp network and endpoints.
///     #[derive(Debug, Clone, CloneRef)]
///     #[allow(missing_docs)]
///     pub struct Frp {
///         pub network: frp::Network,
///         pub output: FrpEndpoints,
///     }
///
///     impl Frp {
///         /// Constructor.
///         pub fn new(network: frp::Network, output: FrpEndpoints) -> Self {
///             Self { network, output }
///         }
///
///         /// Create Frp with network, inputs and outputs.
///         pub fn new_network() -> Self {
///             let network = frp::Network::new();
///             let frp_inputs = FrpInputs::new(&network);
///             let frp_endpoints = FrpEndpoints::new(&network, frp_inputs);
///             Self::new(network, frp_endpoints)
///         }
///     }
///
///     impl Deref for Frp {
///         type Target = FrpEndpoints;
///         fn deref(&self) -> &Self::Target {
///             &self.output
///         }
///     }
///
///     /// Frp inputs.
///     #[derive(Debug, Clone, CloneRef)]
///     #[allow(missing_docs)]
///     #[allow(unused_parens)]
///     pub struct FrpInputs {
///         pub focus     : frp::Source<()>,
///         pub defocus   : frp::Source<()>,
///         pub set_focus : frp::Source<bool>,
///         pub input1    : frp::Source<f32>,
///         pub input2    : frp::Source<()>,
///     }
///
///     #[allow(unused_parens)]
///     impl FrpInputs {
///         /// Constructor.
///         pub fn new(network: &frp::Network) -> Self {
///             frp::extend! { network
///                 focus     <- source();
///                 defocus   <- source();
///                 set_focus <- source();
///                 input1    <- source();
///                 input2    <- source ( ) ;
///             }
///             Self {focus,defocus,set_focus,input1,input2}
///         }
///
///         #[allow(missing_docs)]
///         pub fn focus(&self) {
///             self.focus.emit(());
///         }
///
///         #[allow(missing_docs)]
///         pub fn defocus(&self) {
///             self.defocus.emit(());
///         }
///
///         #[allow(missing_docs)]
///         pub fn set_focus(&self, t1: impl IntoParam<bool>) {
///             self.set_focus.emit(t1);
///         }
///
///         #[allow(missing_docs)]
///         pub fn input1(&self, t1: impl IntoParam<f32>) {
///             self.input1.emit(t1);
///         }
///
///         #[allow(missing_docs)]
///         pub fn input2(&self) {
///             self.input2.emit(());
///         }
///     }
///     /// Frp outputs.
///     #[derive(Debug, Clone, CloneRef)]
///     #[allow(missing_docs)]
///     pub struct FrpEndpoints {
///         pub input         : FrpInputs,
///         pub(crate) source : FrpOutputsSource,
///         pub status_map    : Rc<RefCell<HashMap<String,frp::Sampler<bool>>>>,
///         pub command_map   : Rc<RefCell<HashMap<String,Command>>>,
///         pub focused       : frp::Sampler<bool>,
///         pub output1       : frp::Sampler<String>,
///         pub output2       : frp::Sampler<bool>,
///         pub output3       : frp::Sampler<>,
///     }
///
///     impl Deref for FrpEndpoints {
///         type Target = FrpInputs;
///         fn deref(&self) -> &Self::Target {
///             &self.input
///         }
///     }
///
///     impl FrpEndpoints {
///         /// Constructor.
///         pub fn new(network: &frp::Network, input: FrpInputs) -> Self {
///             use ::ensogl_core::application::command::*;
///             let source = FrpOutputsSource::new(network);
///             let mut status_map: HashMap<String, frp::Sampler<bool>> = default();
///             let mut command_map: HashMap<String, Command> = default();
///             frp::extend! { network
///                 focused <- source.focused.sampler();
///                 output1 <- source.output1.sampler();
///                 output2 <- source.output2.sampler();
///                 output3 <- source.output3.sampler();
///                 focus_events <- bool(&input.defocus,&input.focus);
///                 focused      <- any(&input.set_focus,&focus_events);
///                 source.focused <+ focused;
///             }
///
///             status_map.insert("focused".into(), focused.clone_ref());
///             status_map.insert("output2".into(), output2.clone_ref());
///             command_map.insert("focus".into(), Command::new((input.focus).clone_ref()));
///             command_map.insert("defocus".into(), Command::new((input.defocus).clone_ref()));
///             command_map.insert("input2".into(), Command::new((input.input2).clone_ref()));
///             let status_map  = Rc::new(RefCell::new(status_map));
///             let command_map = Rc::new(RefCell::new(command_map));
///             Self {source,input,status_map,command_map,focused,output1,output2,output3}
///         }
///     }
///
///     /// Frp output setters.
///     #[derive(Debug, Clone, CloneRef)]
///     pub(crate) struct FrpOutputsSource {
///         focused : frp::Any<bool>,
///         output1 : frp::Any<String>,
///         output2 : frp::Any<bool>,
///         output3 : frp::Any<>,
///     }
///
///     impl FrpOutputsSource {
///         /// Constructor.
///         pub fn new(network: &frp::Network) -> Self {
///             frp::extend! { network
///                 focused <- any(...);
///                 output1 <- any(...);
///                 output2 <- any(...);
///                 output3 <- any(...);
///             }
///             Self {focused,output1,output2,output3}
///         }
///     }
///
///     impl CommandApi for Frp {
///         fn command_api(&self) -> Rc<RefCell<HashMap<String,Command>>> {
///             self.command_map.clone()
///         }
///
///         fn status_api(&self) -> Rc<RefCell<HashMap<String, frp::Sampler<bool>>>> {
///             self.status_map.clone()
///         }
///     }
/// ```
#[macro_export]
macro_rules! define_endpoints {
    (
        $([$($global_opts:tt)*])?
        $(<$($param:ident $(:($($constraints:tt)*))?),*>)?

        $(Input { $([$($input_opts:tt)*])?
            $($(#[doc=$($in_doc:tt)*])*
            $in_field : ident ($($in_field_type : tt)*)),* $(,)?
        })?

        $(Output { $([$($output_opts:tt)*])?
            $($(#[doc=$($out_doc:tt)*])*
            $out_field : ident ($($out_field_type : tt)*)),* $(,)?
        })?
    ) => {
        $crate::define_endpoints! {
            NORMALIZED
            $([$($global_opts)*])?
            $(<$($param $(:($($constraints)*))?),*>)?

            Input { $($([$($input_opts)*])?)?
                /// Focus the element. Focused elements are meant to receive shortcut events.
                focus(),
                /// Defocus the element. Non-focused elements are meant to be inactive and don't
                /// receive shortcut events.
                defocus(),
                /// Wrapper for `focus` and `defocus`.
                set_focus(bool),
                $($($(#[doc=$($in_doc )*])*
                $in_field ($($in_field_type )*)),*)?
            }

            Output { $($([$($output_opts)*])?)?
                /// Focus state checker.
                focused(bool),
                $($($(#[doc=$($out_doc)*])*
                $out_field ($($out_field_type)*)),*)?
            }
        }
    };

    (
        NORMALIZED
        $([$($global_opts:tt)*])?
        $(<$($param:ident $(:($($constraints:tt)*))?),*>)?

        Input { $([$($input_opts:tt)*])?
            $($(#[doc=$($in_doc :tt)*])*
            $in_field : ident ($($in_field_type : tt)*)),* $(,)?
        }

        Output { $([$($output_opts:tt)*])?
            $($(#[doc=$($out_doc:tt)*])*
            $out_field : ident ($($out_field_type : tt)*)),* $(,)?
        }
    ) => {
        use $crate::frp::IntoParam;

        /// Frp network and endpoints.
        #[derive(Debug,CloneRef,Derivative)]
        #[derivative(Clone(bound=""))]
        #[allow(missing_docs)]
        pub struct Frp $(<$($param $(:$($constraints)*)?),*>)? {
            pub network : $crate::frp::Network,
            pub output  : FrpEndpoints $(<$($param),*>)?,
        }

        impl $(<$($param $(:$($constraints)*)?),*>)? Frp $(<$($param),*>)? {
            /// Create Frp endpoints within and the associated network.
            pub fn new() -> Self {
                let network = $crate::frp::Network::new(file!());
                let output  = Self::extend(&network);
                Self {network,output}
            }

            /// Create Frp endpoints within the provided network.
            pub fn extend(network:&$crate::frp::Network) -> FrpEndpoints $(<$($param),*>)? {
                let input = FrpInputs::new(network);
                FrpEndpoints::new(network,input)
            }
        }

        impl $(<$($param $(:$($constraints)*)?),*>)? Default for Frp $(<$($param),*>)? {
            fn default() -> Self {
                Self::new()
            }
        }

        impl $(<$($param $(:$($constraints)*)?),*>)? Deref for Frp $(<$($param),*>)? {
            type Target = FrpEndpoints $(<$($param),*>)?;
            fn deref(&self) -> &Self::Target {
                &self.output
            }
        }

        /// Frp inputs.
        #[derive(Debug,CloneRef,Derivative)]
        #[derivative(Clone(bound=""))]
        #[allow(missing_docs)]
        #[allow(unused_parens)]
        // Clippy thinks `_param` is a field we want to add in future, but it is not: it is to
        // suppress "not used generic param" error.
        #[allow(clippy::manual_non_exhaustive)]
        pub struct FrpInputs $(<$($param $(:$($constraints)*)?),*>)? {
            $( $(#[doc=$($in_doc)*])* pub $in_field : $crate::frp::Any<($($in_field_type)*)>,)*
            _params : ($($(PhantomData<$param>),*)?),
        }

        #[allow(unused_parens)]
        impl $(<$($param $(:$($constraints)*)?),*>)? FrpInputs $(<$($param),*>)? {
            /// Constructor.
            pub fn new(network:&$crate::frp::Network) -> Self {
                $crate::frp::extend! { $($($global_opts)*)? $($($input_opts)*)? network
                    $($in_field <- any_mut();)*
                }
                let _params = default();
                Self { $($in_field),*, _params }
            }

            $($crate::define_endpoints_emit_alias!{$in_field ($($in_field_type)*)})*
        }

        /// Frp outputs.
        #[derive(Debug,CloneRef,Derivative)]
        #[derivative(Clone(bound=""))]
        #[allow(unused_parens)]
        #[allow(missing_docs)]
        // Clippy thinks `_param` is a field we want to add in future, but it is not: it is to
        // suppress "not used generic param" error.
        #[allow(clippy::manual_non_exhaustive)]
        pub struct FrpEndpoints $(<$($param $(:$($constraints)*)?),*>)? {
            pub input         : FrpInputs $(<$($param),*>)?,
            // TODO[WD]: Consider making it private and exposing only on-demand with special macro
            //           usage syntax.
            pub(crate) source : FrpOutputsSource $(<$($param),*>)?,
            pub status_map    : Rc<RefCell<HashMap<String,$crate::frp::Sampler<bool>>>>,
            pub command_map   : Rc<RefCell<HashMap<String,$crate::application::command::Command>>>,
            $($(#[doc=$($out_doc)*])*
                pub $out_field  : $crate::frp::Sampler<($($out_field_type)*)>,
            )*
            _params : ($($(PhantomData<$param>),*)?),
        }

        impl $(<$($param $(:$($constraints)*)?),*>)? Deref for FrpEndpoints $(<$($param),*>)? {
            type Target = FrpInputs $(<$($param),*>)?;
            fn deref(&self) -> &Self::Target {
                &self.input
            }
        }

        impl $(<$($param $(:$($constraints)*)?),*>)? FrpEndpoints $(<$($param),*>)? {
            /// Constructor.
            pub fn new(network:&$crate::frp::Network, input:FrpInputs $(<$($param),*>)?) -> Self {
                use $crate::application::command::*;
                let source = FrpOutputsSource::new(network);
                let mut status_map  : HashMap<String,$crate::frp::Sampler<bool>> = default();
                let mut command_map : HashMap<String,Command> = default();
                $crate::frp::extend! { $($($global_opts)*)? $($($output_opts)*)? network
                    $($out_field <- source.$out_field.sampler();)*
                    focus_events   <- bool(&input.defocus,&input.focus);
                    focused        <- any(&input.set_focus,&focus_events);
                    source.focused <+ focused;
                }
                $($crate::build_status_map!
                    {status_map $out_field ($($out_field_type)*) $out_field })*
                $($crate::build_command_map!
                    {command_map $in_field ($($in_field_type)*) input.$in_field })*
                let status_map  = Rc::new(RefCell::new(status_map));
                let command_map = Rc::new(RefCell::new(command_map));
                let _params     = default();
                Self {source,input,status_map,command_map,$($out_field),*,_params}
            }
        }

        /// Frp output setters.
        #[derive(Debug,CloneRef,Derivative)]
        #[derivative(Clone(bound=""))]
        #[allow(unused_parens)]
        // Clippy thinks `_param` is a field we want to add in future, but it is not: it is to
        // suppress "not used generic param" error.
        #[allow(clippy::manual_non_exhaustive)]
        pub(crate) struct FrpOutputsSource $(<$($param $(:$($constraints)*)?),*>)? {
            $(pub(crate) $out_field : $crate::frp::Any<($($out_field_type)*)>,)*
            _params : ($($(PhantomData<$param>),*)?),
        }

        impl $(<$($param $(:$($constraints)*)?),*>)? FrpOutputsSource $(<$($param),*>)? {
            /// Constructor.
            pub fn new(network:&$crate::frp::Network) -> Self {
                $crate::frp::extend! { network
                    $($out_field <- any(...);)*
                }
                let _params = default();
                Self {$($out_field),*,_params}
            }
        }

        impl $(<$($param $(:$($constraints)*)?),*>)?  $crate::application::command::CommandApi for Frp $(<$($param),*>)?  {
            fn command_api(&self)
            -> Rc<RefCell<HashMap<String,$crate::application::command::Command>>> {
                self.command_map.clone()
            }

            fn status_api(&self) -> Rc<RefCell<HashMap<String,$crate::frp::Sampler<bool>>>> {
                self.status_map.clone()
            }
        }

        impl $(<$($param $(:$($constraints)*)?),*>)?  $crate::application::command::FrpNetworkProvider for Frp $(<$($param),*>)?  {
            fn network(&self) -> &$crate::frp::Network { &self.network }
        }
    };
}

/// Internal helper of `define_endpoints` macro.
#[macro_export]
macro_rules! build_status_map {
    ($map:ident $field:ident (bool) $frp:expr) => {
        $map.insert(stringify!($field).into(), $frp.clone_ref());
    };
    ($($ts:tt)*) => {};
}

/// Internal helper of `define_endpoints` macro.
#[macro_export]
macro_rules! build_command_map {
    ($map:ident $field:ident () $frp:expr) => {
        $map.insert(stringify!($field).into(), Command::new($frp.clone_ref()));
    };
    ($($ts:tt)*) => {};
}

/// Defines a method which is an alias to FRP emit method. Used internally by the `define_endpoints`
/// macro.
#[macro_export]
macro_rules! define_endpoints_emit_alias {
    ($field:ident ()) => {
        #[allow(missing_docs)]
        pub fn $field(&self) {
            self.$field.emit(());
        }
    };

    ($field:ident ($t1:ty,$t2:ty)) => {
        #[allow(missing_docs)]
        pub fn $field(&self, t1: impl IntoParam<$t1>, t2: impl IntoParam<$t2>) {
            let t1 = t1.into_param();
            let t2 = t2.into_param();
            self.$field.emit((t1, t2));
        }
    };

    ($field:ident ($t1:ty,$t2:ty,$t3:ty)) => {
        #[allow(missing_docs)]
        pub fn $field(
            &self,
            t1: impl IntoParam<$t1>,
            t2: impl IntoParam<$t2>,
            t3: impl IntoParam<$t3>,
        ) {
            let t1 = t1.into_param();
            let t2 = t2.into_param();
            let t3 = t3.into_param();
            self.$field.emit((t1, t2, t3));
        }
    };

    ($field:ident ($t1:ty,$t2:ty,$t3:ty,$t4:ty)) => {
        #[allow(missing_docs)]
        pub fn $field(
            &self,
            t1: impl IntoParam<$t1>,
            t2: impl IntoParam<$t2>,
            t3: impl IntoParam<$t3>,
            t4: impl IntoParam<$t4>,
        ) {
            let t1 = t1.into_param();
            let t2 = t2.into_param();
            let t3 = t3.into_param();
            let t4 = t4.into_param();
            self.$field.emit((t1, t2, t3, t4));
        }
    };

    ($field:ident ($t1:ty,$t2:ty,$t3:ty,$t4:ty,$t5:ty)) => {
        #[allow(missing_docs)]
        pub fn $field(
            &self,
            t1: impl IntoParam<$t1>,
            t2: impl IntoParam<$t2>,
            t3: impl IntoParam<$t3>,
            t4: impl IntoParam<$t4>,
            t5: impl IntoParam<$t5>,
        ) {
            let t1 = t1.into_param();
            let t2 = t2.into_param();
            let t3 = t3.into_param();
            let t4 = t4.into_param();
            let t5 = t5.into_param();
            self.$field.emit((t1, t2, t3, t4, t5));
        }
    };

    ($field:ident $t1:ty) => {
        #[allow(missing_docs)]
        pub fn $field(&self, t1: impl IntoParam<$t1>) {
            self.$field.emit(t1);
        }
    };
}

/// Trait that describes the structure of the FRP API in terms of its public and private parts. This
/// trait allows the `Component` (`lib/rust/ensogl/component/gui/src/component.rs`) to distinguish
/// between public and private APIs for any API generated through the `define_endpoints_2` macro.
pub trait API {
    /// Public part of this API. To be used when sending events into the API and receiving
    /// events from the API.
    type Public: crate::application::command::CommandApi;
    /// Private part of this API. To be used when receiving events sent into the public API and
    /// creating events to the public API outputs.
    type Private;

    /// Getter for `Self::Private`.
    fn private(&self) -> &Self::Private;
    /// Getter for `Self::Public`
    fn public(&self) -> &Self::Public;
}


/// Generate a set of structures allowing for management of FRP inputs, outputs, and commands.
/// Supersedes `define_endpoints`, which should no longer be used.
///
/// Given the definition:
///
/// ```compile_fail
///     define_endpoints_2! { [GLOBAL_OPTS] <GENERIC_PARAMETERS>
///         Input { [INPUT_OPTS]
///             input1 (f32),
///             input2 (),
///         }
///         Output { [OUTPUT_OPTS]
///             output1 (String),
///             output2 (bool),
///             output3 (),
///         }
///     }
/// ```
///
/// The `INPUT_OPTS`, `OUTPUT_OPTS`, and `GLOBAL_OPTS` are optional and will be passed directly to
/// input, output, or both FRP network definitions, respectively. For example, you can add the
/// `TRACE_ALL` option this way.
///
/// The `GENERIC_PARAMETERS` are also optional and makes all structures generated by this macro
/// parametrized by given generics. The parameters may have trait bounds in the same way as in
/// struct declarations, _except_ that all bounds must be in parenthesis; for example:
/// `<Foo:(Clone+Debug), Bar:(Debug+'static)>`.
///
/// The macro will create two sets of API: a public API and a private API. The public API is
/// intended to be used to send events into the API and receive events from the API, while the
/// private API is intended to process the events sent in through the public API and generate
/// the events going out though the public API.
///
/// The output of the macro will look similar to the following code.
/// Note that this example only shows the structs generated, not methods and traits, and it
/// simplifies some of the struct contents. This makes it easier to get a basic understanding of
/// the transformation that happens.
///
/// ```compile_fail
/// 
///
/// #[derive(Debug, Derivative)]
/// #[derive(CloneRef, Clone)]
/// pub struct Frp {
///     public: api::Public,
///     private: Rc<api::Private>,
/// }
///
/// pub mod api {
///     use super::*;
///
///     #[derive(Debug, CloneRef, Clone)]
///     pub struct Public {
///         pub input: public::Input,
///         pub output: public::Output,
///         pub(crate) combined: public::Combined,
///     }
///     
///     pub mod public {
///         use super::*;
///
///
///         #[derive(Debug, CloneRef, Clone)]
///         pub struct Input {
///             data: Rc<InputData>,
///         }
///
///         #[derive(Debug, CloneRef, Derivative)]
///         pub struct InputData {
///             pub input1: frp::Any<f32>,
///             pub input2: frp::Any<()>,
///         }
///         
///         #[derive(Debug, CloneRef, Clone)]
///         pub struct Output {
///             data: Rc<OutputData>,
///         }
///         
///
///         #[derive(Debug)]
///         pub struct OutputData {
///             pub output1: frp::Sampler<(f32,f32)>,
///             pub output2: frp::Sampler<bool>,
///             pub output3: frp::Sampler<()>,
///         }
///
///         #[derive(Debug, CloneRef, Clone)]
///         pub struct Combined {
///             data: Rc<CombinedData>,
///         }
///
///         #[derive(Debug)]
///         pub struct CombinedData {
///             pub input1: frp::Any<f32>,
///             pub input2: frp::Any<()>,
///             
///             pub output1: frp::Sampler<(f32,f32)>,
///             pub output2: frp::Sampler<bool>,
///             pub output3: frp::Sampler<()>,
///         }
///     }
///
///
///     #[derive(Debug)]
///     pub struct Private {
///         pub network: frp::Network,
///         pub input: private::Input,
///         pub output: private::Output,
///     }
///
///     pub mod private {
///         use super::*;
///         
///         #[derive(Debug)]
///         pub struct Input {
///             data: Rc<InputData>,
///         }
///
///         #[derive(Debug)]
///         pub struct InputData {
///             pub input1: frp::Stream<f32>,
///             pub input2: frp::Stream<()>,
///         }
///
///         #[derive(Debug)]
///         pub struct Output {
///             data: Rc<OutputData>,
///         }
///         
///         #[derive(Debug)]
///         pub struct OutputData {
///             pub output1: frp::Any<(f32, f32)>,
///             pub output2: frp::Any<bool>,
///             pub output3: frp::Any<()>,
///         }
///     }
/// }
/// ```
///
///  Public API
///  -----------
///
/// The public API contains a `Input` struct that allows access to an `Any` node for each
/// item in the `Input` definition of the macro input. These allow sending events into the API.
/// It also contains an `Output` struct that allows access to a `Sampler` for each item defined
/// in the `Output` section of the macro input. These provide the output from the API.
///
/// For convenience there is also a `Combined` struct that holds both the input and output nodes.
/// This struct is exposed on the `Input` struct through a `Deref` implementation.
///
/// ```compile_fail
///     #[derive(Debug, CloneRef, Clone)]
///     pub struct Public {
///         pub input: public::Input,
///         pub output: public::Output,
///         pub(crate) combined: public::Combined,
///     }
///
///     pub mod public {
///         use super::*;
///
///         #[derive(Debug, CloneRef, Clone)]
///         pub struct Input {
///             data: Rc<InputData>,
///         }
///
///         #[derive(Debug, CloneRef, Derivative)]
///         pub struct InputData {
///             pub input1: frp::Any<f32>,
///             pub input2: frp::Any<()>,
///         }
///         
///         #[derive(Debug, CloneRef, Clone)]
///         pub struct Output {
///             data: Rc<OutputData>,
///         }
///         
///
///         #[derive(Debug)]
///         pub struct OutputData {
///             pub output1: frp::Sampler<(f32,f32)>,
///             pub output2: frp::Sampler<bool>,
///             pub output3: frp::Sampler<()>,
///         }
///
///         #[derive(Debug, CloneRef, Clone)]
///         pub struct Combined {
///             data: Rc<CombinedData>,
///         }
///
///         #[derive(Debug)]
///         pub struct CombinedData {
///             pub input1: frp::Any<f32>,
///             pub input2: frp::Any<()>,
///             
///             pub output1: frp::Sampler<(f32,f32)>,
///             pub output2: frp::Sampler<bool>,
///             pub output3: frp::Sampler<()>,
///         }
///     }
/// ```
///
///  Private API
/// ------------
///
/// The private API provides facilities to consume the events from the inputs of public API and
/// create events for its outputs. This the relationships are inverted: the `Input` struct of the
/// private API allows access to a `Stream` for each item defined in the `Input` section of the
/// macro input and the `Output` struct allows access to a `Any` node for each item defined in the
/// `Output` section of the macro call. The private input streams receive the events generated from
/// the public input and the private output nodes propagate events to the public outputs.     
///
///```compile_fail
/// 
///     #[derive(Debug)]
///     pub struct Private {
///         pub network: frp::Network,
///         pub input: private::Input,
///         pub output: private::Output,
///     }
///
///     pub mod private {
///         use super::*;
///         
///         #[derive(Debug)]
///         pub struct Input {
///             data: Rc<InputData>,
///         }
///
///         #[derive(Debug)]
///         pub struct InputData {
///             pub input1: frp::Stream<f32>,
///             pub input2: frp::Stream<()>,
///         }
///
///         #[derive(Debug)]
///         pub struct Output {
///             data: Rc<OutputData>,
///         }
///         
///         #[derive(Debug)]
///         pub struct OutputData {
///             pub output1: frp::Any<(f32, f32)>,
///             pub output2: frp::Any<bool>,
///             pub output3: frp::Any<()>,
///         }
///     }
/// ```
///
/// Convenience methods
/// -------------------
///
/// To make working with the API easier, the `public::Input` and `public::Combined` structs also
/// generate convenience methods for the inputs that simplify emitting events.
/// For each `Any` nod there is an equivalent method that can be called and accepts the node
/// input as an argument and can be called directly. So in the above example, instead of writing
/// `api.input.input1.emit(64)` it is possible to write `api.input.input1(64)`.
///
/// The code generated for the example looks similar to this
/// ```compile_fail
/// impl InputData {
///     pub fn input1(&self, t1: impl IntoParam<f32>) {
///         self.input1.emit(t1);
///     }
///     pub fn input2(&self) {
///         self.input2.emit(());
///     }
/// }
/// ```
///
///
/// Additional Implementations
/// ---------------------------
///
/// In addition to the structures described above there also also some important traits implemented
/// for the API.
/// * The `Frp` implements: `application::command::FrpNetworkProvider `, `application::frp::API`.
/// * The `api::Public` implements: `application::command::CommandApi`.
///
/// Also note that additional fields are added automatically to the API. In particular, an
/// output `focused(bool)`, and inputs `focus()`, `defocus()`, and `set_focus(bool)` are always
/// defined and connected. They are mainly used for the shortcut manager to send commands only
/// to focused GUI elements.
///
/// Also all inputs to the API are instrumented with profiling that is available when running the
/// application with profiling at the `debug` level.
#[macro_export(local_inner_macros)]
macro_rules! define_endpoints_2 {
    (
        $([$($global_opts:tt)*])?
        $(<$($param:ident $(:($($constraints:tt)*))?),*>)?

        $(
            Input {
                $([$($input_opts:tt)*])?
                $(
                    $(#$in_field_attr:tt)*
                    $in_field:ident $in_field_type:tt
                ),* $(,)?
            }
        )?

        $(
            Output {
                $([$($output_opts:tt)*])?
                $(
                    $(#$out_field_attr:tt)*
                    $out_field:ident $out_field_type:tt
                ),* $(,)?
            }
        )?
    ) => {
        $crate::define_endpoints_2_normalized! {{
            [<$($($param $(:$($constraints)*)?),*)?>] [<$($($param),*)?>]

            Input { [$($($global_opts)*)? $($($($input_opts)*)?)?]
                /// Focus the element. Focused elements are meant to receive shortcut events.
                focus(),
                /// Defocus the element. Non-focused elements are meant to be inactive and don't
                /// receive shortcut events.
                defocus(),
                /// Wrapper for `focus` and `defocus`.
                set_focus(bool)
                $($(,
                    $(#$in_field_attr)*
                    $in_field $in_field_type
                )*)?
            }

            Output { [$($($global_opts)*)? $($($($output_opts)*)?)?]
                /// Focus state checker.
                focused(bool)
                $($(,
                    $(#$out_field_attr)*
                    $out_field $out_field_type
                )*)?
            }
        }}
    };
}

/// Generate structs with additional implementations with a wrapper that holds
/// the given struct via an `Rc` and additional trait implementations for `Deref`, to the inner
/// struct, Clone, and a constructor as given.
///
/// Note that additional type arguments for the structs have to be passed in `anglified` form
///
/// Example
/// -------
///
/// ```no_compile
/// generate_rc_structs_and_impls! {
///     [<[]>] [<[]>]
///     pub struct Output OutputData {
///         foo: f32,
///     }
///     
///     pub fn new() {
///     
///     }
/// }
/// ```
/// creates
/// ```no_compile
/// #[derive(Debug, CloneRef)]
/// pub struct Output<> {
///     data: Rc<OutputData<>>,
/// }
/// impl<> Deref for Output<[ {
///     type Target = OutputData<>;
///     fn deref(&self) -> &Self::Target {
///         &self.data
///     }
/// }
/// impl<> Clone for Output<> {
///     fn clone(&self) -> Self {
///         let data = Rc::clone(&self.data);
///         Self { data }
///     }
/// }
/// #[allow(unused_parens)]
/// #[derive(Debug)]
/// pub struct OutputData<> {
///     _phantom_type_args: PhantomData0<>,
///
///     pub foo: f32,
/// }
/// impl<> OutputData<> {
///     fn new_from_tuple(tuple: (f32, )) -> Self {
///         let _phantom_type_args = default();
///         let (foo, ) = tuple;
///         Self { _phantom_type_args, foo }
///     }
/// }
/// impl<> Output<> {
///     pub fn new() -> Self {
///         let data = Rc::new(OutputData::new());
///         Self { data }
///     }
/// }
/// #[allow(unused_parens)]
/// impl<> OutputData<> {
///     pub fn new() -> Self {
///         Self::new_from_tuple({}
///         )
///     }
/// }
/// ```
#[macro_export]
macro_rules! generate_rc_structs_and_impls {
    (
        [$($ctx:tt)*] [$($param:tt)*]
        pub struct $name:tt $data_name:tt {
            $(
                $(#$field_attr:tt)*
                $field:ident : $field_type:tt
            ),* $(,)?
        }

        pub fn new($($arg:ident : $arg_tp:tt),*) $body:tt

    ) => {
        #[derive(Debug, CloneRef)]
        pub struct $name $($ctx)* {
            data: Rc<$data_name $($param)*>
        }
        impl $($ctx)* Deref for $name $($param)* {
            type Target = $data_name $($param)*;
            fn deref(&self) -> &Self::Target {
                &self.data
            }
        }

        impl $($ctx)* Clone for $name  $($param)* {
            fn clone(&self) -> Self {
                let data = Rc::clone(&self.data);
                Self {data}
            }
        }

        #[allow(unused_parens)]
        #[derive(Debug)]
        pub struct $data_name $($ctx)* {
            _phantom_type_args: PhantomData0 $($param)*,
            $(
                $(#$field_attr)*
                pub $field : $field_type
            ),*
        }

        impl $($ctx)* $data_name $($param)* {
            fn new_from_tuple(tuple:($($field_type,)*)) -> Self {
                let _phantom_type_args = default();
                let ($($field,)*) = tuple;
                Self { _phantom_type_args, $($field),* }
            }
        }


        impl $($ctx)* $name $($param)* {
            pub fn new($($arg: $arg_tp),*) -> Self {
                let data = Rc::new($data_name::new($($arg),*));
                Self { data }
            }
        }
        #[allow(unused_parens)]
        impl $($ctx)* $data_name $($param)* {
            pub fn new($($arg: $arg_tp),*) -> Self {
                Self::new_from_tuple($body)
            }
        }
    };
}

/// Creates the structs and functionality of the public API as described in the docs of
/// `define_endpoints_2`.
#[macro_export]
macro_rules! define_endpoints_2_normalized_public {
    ({
        [$($ctx:tt)*] [$($param:tt)*]

        Input { $input_opts:tt
            $(
                $(#$in_field_attr:tt)*
                $in_field:ident $in_field_type:tt
            ),*
        }

        Output { $output_opts:tt
            $(
                $(#$out_field_attr:tt)*
                $out_field:ident $out_field_type:tt
            ),*
        }
    }) => {
        /// Public FRP Api. Contains FRP nodes for sending FRP events into the API collected
        ///in the `public::Input` and nodes for receiving events from the API in the
        /// `public::Output` struct. For convenience there is also a `public::Combined` struct
        /// that contains both input and output nodes and which is accessible via a `Deref`
        /// implementation on `Public`.
        #[derive(Debug, CloneRef, Clone)]
        pub struct Public $($ctx)* {
            pub input: public::Input $($param)*,
            pub output: public::Output $($param)*,
            pub (crate) combined: public::Combined $($param)*,
        }

        impl $($ctx)* Public $($param)* {
            pub fn new(
                input: public::Input $($param)*,
                output: public::Output $($param)*,
                combined: public::Combined $($param)*
            ) -> Self {
                Self {input, output, combined}
            }
        }

        impl $($ctx)* Deref for Public $($param)* {
            type Target = public::Combined $($param)*;
            fn deref(&self) -> &Self::Target {
                &self.combined
            }
        }

        impl $($ctx)* $crate::application::command::CommandApi for Public $($param)*  {
            fn command_api(&self)
                -> Rc<RefCell<HashMap<String,$crate::application::command::Command>>> {
                self.output.command_map.clone()
            }

            fn status_api(&self) -> Rc<RefCell<HashMap<String,$crate::frp::Sampler<bool>>>> {
                self.output.status_map.clone()
            }
        }

        pub mod public {
            use super::*;
            // === Input ===

            $crate::generate_rc_structs_and_impls! {
                [$($ctx)*] [$($param)*]
                pub struct Input InputData {
                    $(
                        $(#$in_field_attr)*
                        $in_field : ($crate::frp::Any<$in_field_type>)
                    ),*
                }

                pub fn new(network: (&$crate::frp::Network)) {
                    $crate::frp::extend! { $input_opts network
                        $($in_field <- any_mut();)*
                    }
                    ($($in_field,)*)
                }
            }

            #[allow(unused_parens)]
            impl $($ctx)* InputData $($param)* {
                $($crate::define_endpoints_emit_alias!{$in_field $in_field_type})*
            }


            // === Output ===

            $crate::generate_rc_structs_and_impls! {
                [$($ctx)*] [$($param)*]
                pub struct Output OutputData {
                    status_map: (Rc<RefCell<HashMap<String,$crate::frp::Sampler<bool>>>>),
                    command_map: (Rc<RefCell<HashMap<String,$crate::application::command::Command>>>)
                    $(,
                        $(#$out_field_attr)*
                        $out_field: ($crate::frp::Sampler<$out_field_type>)
                    )*
                }

                pub fn new(
                    network: (&$crate::frp::Network),
                    private_output: (&api::private::Output $($param)*),
                    public_input: (&Input $($param)*)
                ) {
                    use $crate::application::command::*;

                    $crate::frp::extend! { $output_opts network
                        $( $out_field <- private_output.$out_field.profile().sampler(); )*
                    }
                    let mut status_map : HashMap<String,$crate::frp::Sampler<bool>> = default();
                    let mut command_map : HashMap<String,Command> = default();
                    $(
                        $crate::build_status_map! {status_map $out_field $out_field_type $out_field}
                    )*
                    $(
                        let _in_field = &public_input.$in_field;
                        $crate::build_command_map! {command_map $in_field $in_field_type _in_field}
                    )*
                    let status_map = Rc::new(RefCell::new(status_map));
                    let command_map = Rc::new(RefCell::new(command_map));

                    (status_map,command_map,$($out_field),*)
                }
            }


            // === Combined ===

            $crate::generate_rc_structs_and_impls! {
                [$($ctx)*] [$($param)*]
                pub struct Combined CombinedData {
                    $(
                        $(#$in_field_attr)*
                        $in_field: ($crate::frp::Any<$in_field_type>),
                    )*

                    $(
                        $(#$out_field_attr)*
                        $out_field: ($crate::frp::Sampler<$out_field_type>),
                    )*
                }

                pub fn new(input: (&InputData $($param)*), output: (&OutputData $($param)*)) {
                    $(let $in_field = input.$in_field.clone_ref();)*
                    $(let $out_field = output.$out_field.clone_ref();)*
                    ( $($in_field,)* $($out_field,)* )
                }
            }

            #[allow(unused_parens)]
            impl $($ctx)* Combined $($param)* {
                $($crate::define_endpoints_emit_alias!{$in_field $in_field_type})*
            }
        }
    };
}

/// Creates the structs and functionality of the private API as described in the docs of
/// `define_endpoints_2`.
#[macro_export]
macro_rules! define_endpoints_2_normalized_private {
    ({
        [$($ctx:tt)*] [$($param:tt)*]

        Input { $input_opts:tt
            $(
                $(#$in_field_attr:tt)*
                $in_field:ident $in_field_type:tt
            ),*
        }

        Output { $output_opts:tt
            $(
                $(#$out_field_attr:tt)*
                $out_field:ident $out_field_type:tt
            ),*
        }
    }) => {
        // No Clone. We do not want `network` to be cloned easily in the future.
        #[derive(Debug)]
        pub struct Private $($ctx)* {
            pub network: $crate::frp::Network,
            pub input: private::Input $($param)*,
            pub output: private::Output $($param)*,
        }

        impl $($ctx)* Private $($param)* {
            pub fn new(
                network: $crate::frp::Network,
                input: private::Input $($param)*,
                output: private::Output $($param)*
            ) -> Self {
                Self {network, input, output}
            }
        }

        pub mod private {
            use super::*;


            // === Input ===

            $crate::generate_rc_structs_and_impls! {
                   [$($ctx)*] [$($param)*]
                    pub struct Input InputData {
                    $(
                        $(#$in_field_attr)*
                        $in_field: ($crate::frp::Stream<$in_field_type>)
                    ),*
                }

                pub fn new(
                    network: (&$crate::frp::Network),
                    public_input: (&api::public::Input $($param)*)
                ) {
                    $crate::frp::extend! { $input_opts network
                        $( $in_field <- public_input.$in_field.profile(); )*
                    }
                    $(let $in_field = $in_field.clone_ref().into();)*
                    ($($in_field,)*)
                }
            }


            // === Output ===

            $crate::generate_rc_structs_and_impls! {
                [$($ctx)*] [$($param)*]
                pub struct Output OutputData {
                    $(
                        $(#$out_field_attr)*
                        $out_field: ($crate::frp::Any<$out_field_type>)
                    ),*
                }

                pub fn new(network: (&$crate::frp::Network)) {
                    $crate::frp::extend! { $output_opts network
                        $($out_field <- any_mut();)*
                    }
                    ($($out_field,)*)
                }
            }
        }
    };
}

/// Creates the `Frp` struct related functionality as described in the docs of `define_endpoints_2`.
#[macro_export]
macro_rules! define_endpoints_2_normalized_glue {
    ({
        [$($ctx:tt)*] [$($param:tt)*]

        Input { $input_opts:tt
            $(
                $(#$in_field_attr:tt)*
                $in_field:ident $in_field_type:tt
            ),*
        }

        Output { $output_opts:tt
            $(
                $(#$out_field_attr:tt)*
                $out_field:ident $out_field_type:tt
            ),*
        }
    }) => {
            /// Frp API consisting of a public and private API. See the documentation of
            /// [define_endpoints_2] for full documentation.
            #[derive(Debug)]
            #[derive(CloneRef)]
            #[allow(missing_docs)]
            pub struct Frp $($ctx)* {
                public: api::Public $($param)*,
                // `api::Private` is not cloneable, but the Frp still needs to be `CloneRef`able for
                // API compatibility. In the future we want to make the `FRP` not cloneable, and we will
                // be able to hold the `api::Private` directly..
                private: Rc<api::Private $($param)*>,
            }

             impl $($ctx)* Frp $($param)* {
                /// Create Frp endpoints within and the associated network.
                pub fn new() -> Self {
                    let network = $crate::frp::Network::new(file!());
                    let pub_input = api::public::Input::new(&network);
                    let priv_input = api::private::Input::new(&network, &pub_input);
                    let priv_output = api::private::Output::new(&network);
                    let pub_output = api::public::Output::new(&network, &priv_output, &pub_input);
                    let combined = api::public::Combined::new(&pub_input,&pub_output);
                    let public = api::Public::new(pub_input, pub_output, combined);
                    let private = Rc::new(api::Private::new(network, priv_input, priv_output));
                    Self {public,private}
                }
            }

            impl $($ctx)*
            Default for Frp $($param)* {
                fn default() -> Self {
                    Self::new()
                }
            }

            impl $($ctx)*
            Clone for Frp $($param)* {
                fn clone(&self) -> Self {
                    let public = self.public.clone();
                    let private = self.private.clone();
                    Self {public,private}
                }
            }

            impl $($ctx)* Deref for Frp $($param)* {
                type Target = api::Public  $($param)*;
                fn deref(&self) -> &Self::Target {
                    &self.public
                }
            }

            impl $($ctx)*
            $crate::application::command::FrpNetworkProvider for Frp $($param)*  {
                fn network(&self) -> &$crate::frp::Network {
                    &self.private.network
                }
            }

            impl $($ctx)*
            $crate::application::frp::API for Frp $($param)* {
                type Public = api::Public  $($param)*;
                type Private = api::Private  $($param)*;

                fn private(&self) -> &Self::Private {
                    &self.private
                }

                fn public(&self) -> &Self::Public {
                    &self.public
                }
            }
    };
}

/// Creates the overall structure described in the docs of `define_endpoints_2`.
#[macro_export]
macro_rules! define_endpoints_2_normalized {
    ($def:tt) => {
        use $crate::frp::IntoParam;
        $crate::define_endpoints_2_normalized_glue! {$def}
        /// Module containing the implementations of the structs that make up the public
        /// (`api::Public`) and private (`api::Private`) part of the FRP API.
        #[allow(missing_docs)]
        #[allow(unused_parens)]
        #[allow(clippy::manual_non_exhaustive)]
        pub mod api {
            use super::*;
            $crate::define_endpoints_2_normalized_public! {$def}
            $crate::define_endpoints_2_normalized_private! {$def}
        }
    };
}



// =============
// === Tests ===
// =============

#[cfg(test)]
mod tests {
    use crate::prelude::*;

    use crate::application::command::FrpNetworkProvider;
    use crate::frp;

    // Check compilation of macro output.
    mod empty_api {
        use super::*;

        define_endpoints_2! {
            Input{}
            Output{}
        }
    }

    // Check compilation of macro output.
    mod tuple_type {
        use super::*;

        define_endpoints_2! {
            Input{
                set_tuple(f32,f32)
            }
            Output{
                tuple(f32,f32)
            }
        }
    }

    // Check compilation of doc example.
    mod doc_example {
        use super::*;

        define_endpoints_2! {
            Input {
                input1 (f32),
                input2 (),
            }
            Output {
                output1 ((f32,f32)),
                output2 (bool),
                output3 (),
            }
        }
    }

    // Check compilation of macro output.
    define_endpoints_2! { <Value:(Default+Debug+Clone+'static)>
        Input{
            set_radius(Value)
        }
        Output{
            radius(Value),
            diameter(Value)
        }
    }

    #[test]
    fn test_simple_api_usage() {
        let frp = Frp::<u32>::default();
        let network = frp.network();

        // Set up internal logic.
        frp::extend! { network
             frp.private.output.radius <+ frp.private.input.set_radius;
             frp.private.output.diameter <+ frp.private.input.set_radius.map(|r| 2 * r);
        }

        // Public API usage.
        frp.set_radius(2);

        assert_eq!(frp.public.output.radius.value(), 2);
        assert_eq!(frp.public.output.diameter.value(), 4);
        assert_eq!(frp.public.combined.radius.value(), 2);
        assert_eq!(frp.public.combined.diameter.value(), 4);

        assert_eq!(frp.radius.value(), 2);
        assert_eq!(frp.diameter.value(), 4);
    }

    #[test]
    fn test_generate_rc_structs_and_impls() {
        generate_rc_structs_and_impls! {
            [] []
            pub struct Output OutputData {
                foo: f32,
            }

            pub fn new() {
                (64.0,)
            }
        }
    }
}
